---
title: 数值模拟之：桁架结构受力分析（上）
layout: blog
tags: ["lean", "computation", "mathematics"]
---

好久没有更过数值模拟相关的文章了。本次尝试从桁架结构的受力分析入手，分析线性代数在这类物理问题中的应用。

## 物理部分：桁架结构的静力学

**桁架**是指一系列细杆以铰接的方式连接起来形成的结构。比如，下面这个结构就是一个桁架：

![](https://ts1.tc.mm.bing.net/th/id/R-C.3bdc9f779a47a5544068842ce8ddeb18?rik=ipvi6AQxscaaKg&riu=http%3a%2f%2fwww.jiaguhome.com%2fUploads%2fPicture%2f2020-06%2f5ed8b2b608fe4.jpg&ehk=9CADUV%2f4tICwfZvCSfbKxV5ibPIKjLGkqY3Z2Pmtr10%3d&risl=&pid=ImgRaw&r=0)

**铰接**指的是连接点连接的两个或多个杆件可以自由旋转，但是端点的位置不能任意移动。

在工程中，对桁架做受力分析时，通常用以下这种简化的受力分析图：

![truss-1](/img/truss-1.png)

这张图上，每个圆圈就是一个连接点，每条线是一个杆件。节点上有时会有特殊标记。比如，下方有一个三角形的节点表示固定铰支座，这个固定点能在横向和纵向提供任意大的拉力以保证该点的位置不变。下方有一个带圆圈的三角形表示滚动铰支座，其约束了横向的合力为0且纵向的位置不变。

我们对桁架上的每一根杆做受力分析：如果杆的自重不可忽略，那么这根杆就会受到三个力：

1. 左侧端点受力
2. 右侧端点受力
3. 自身重力

![force-diagram](/img/member-force-diagram.svg)

假设每根杆的重力已知，那么这个杆上就有四个未知数：$f_{sx}$、$f_{sy}$、$f_{ex}$和$f_{ey}$，其中矢量$\mathbf{f}_s = (f_{sx}, f_{sy})$是杆件第一个端点受到的力、$\mathbf{f}_e = (f_{ex}, f_{ey})$是第二个端点受到的力。同时，可以列出杆件的三个受力平衡方程：

1. （x方向受力平衡）

   $$f_{sx} + f_{ex} = 0$$

2. （y方向受力平衡）

   $$f_{sy} + f_{ey} - mg = 0$$

3. （力矩平衡）

   $$(f_{sx}-f_{ex})\sin\theta - (f_{sy} - f_{ey})\cos\theta = 0$$

显然，三个未知数没法约束四个变量，因此我们还需要更多的约束方程。对于每个不固定的铰接节点，其各个方向受的合力均为0，也就是以下两个方程：

1. （x方向合力为0）

   $$\sum_{\text{力}i\text{作用与节点上}}f_{ix} = 0$$

2. （y方向合力为0）

   $$\sum_{\text{力}i\text{作用与节点上}}f_{iy} = 0$$

举个例子，下面这个简单的结构：

![truss-2](/img/truss-2.png)

设两根杆各自两端共四个力分别为$f_1$、$f_2$、$f_3$和$f_4$，杆的质量为$m$，与水平方向的夹角为$\theta$，那么就有：

1. （杆1受力平衡）

   $$f_{1x} + f_{2x} = 0$$

   $$f_{1y} + f_{2y} = mg$$

   $$(f_{1x}-f_{2x})\sin\theta - (f_{1y} - f_{2y})\cos\theta = 0$$

2. （杆2受力平衡）

   $$f_{3x} + f_{4x} = 0$$

   $$f_{3y} + f_{4y} = mg$$

   $$(f_{4x}-f_{3x})\sin\theta + (f_{4y} - f_{3y})\cos\theta = 0$$

3. （连接点受力平衡）

   $$f_{2x} + f_{3x} = 0$$

   $$f_{2y} + f_{3y} = 0$$

注意到，上面的8个方程都是线性方程，因此可以将这个方程写成矩阵的形式：

$$
\begin{bmatrix}
1 & & 1 & & & & & \\
& 1 & & 1 & & & & \\
\sin\theta & -\cos\theta & -\sin\theta & \cos\theta & & & & \\
& & & & 1 & & 1 & \\
& & & & & 1 & & 1 \\
& & & & -\sin\theta & -\cos\theta & \sin\theta & \cos\theta \\
& & 1 & & 1 & & & \\
& & & 1 & & 1 & &
\end{bmatrix}
\begin{bmatrix}
f_{1x} \\ f_{1y} \\ f_{2x} \\ f_{2y} \\
f_{3x} \\ f_{3y} \\ f_{4x} \\ f_{4y}
\end{bmatrix}
=
\begin{bmatrix}
0 \\ mg \\ 0 \\ 0 \\ mg \\ 0 \\ 0 \\ 0
\end{bmatrix}
$$

将左侧的系数记作$A$，右侧的向量记作$\mathbf{b}$，那么这个问题就是一个标准的矩阵方程：

$$A\mathbf{f} = \mathbf{b}$$

也就是说，我们现在将这个物理问题转化成了一个计算问题：怎么解矩阵方程$A\mathbf{f} = \mathbf{b}$？

### 矩阵方程的物理意义

矩阵$A$的每一行都表示一个约束条件。上面的例子中比较巧的是约束条件的个数与未知数的个数恰好相等，因此整个体系的受力有唯一解。但是注意，按照上述的算法，约束条件的个数不一定等于未知数的个数。

比如下面这个例子：

![truss-3](/img/truss-3.png)

这个结构有三根杆，共有3×4=12个未知数；约束条件有3×3+2×2=13个。也就是说，约束条件比未知数要多，因此这个结构在这些约束下是无解的。至于为什么会无解，则是因为我们在做静力学分析的时候忽略了各个部件的运动，而如果把每个节点的加速度$a$考虑进来，那么变量的总个数和约束条件的总个数应当是相等的。

> 思考：如果将每个节点的加速度放进模型里，那么上面的约束条件需要怎么改写？

再比如下面这个例子：

![truss-4](/img/truss-4.png)

这个结构同样有12个未知数，但是只有3×3+1×2=11个约束条件。约束条件的个数小于未知数个数，因此这个系统有无限多个解。这里的原因是：我们的模型假定了每根杆都是不会变形的刚体，而理想刚体能够在不变形的情况下承受任意大的力。下面这跟直接连接两个固定铰接点的杆上承担的张力实际上会和它的形变程度有关。如果我们在现实中搭建一个这样的系统，即使是mm级别的长度差异可能都会在下面的杆上造成kN级别的应力，而在理想模型中，即使没有任何形变，这个杆上承载的力则可能是任何数。

## 计算部分：矩阵方程

对于$M\times N$的矩阵$A$和$M$维向量$b$，我们希望寻找一个$N$维向量$x$，使得$Af = b$。根据$M$和$N$的相对关系，可以将方程分为下面几类：

1. $M = N$：约束条件数等于方程数。只要矩阵$A$满秩，那么方程就有唯一解。
2. $M \lt N$：约束条件数小于未知数个数，方程有无穷多组解。
3. $M \gt N$：约束条件数大于未知数个数，方程大部分情况下无解。

情况1很好说，直接使用高斯消元即可求解。但是情况2和情况3我们该怎么做呢？

### 欠约束情况

对于欠约束的方程$A\mathbf{x} = \mathbf{b}$，既然它有无穷多组解，我们不妨人为地增加一些限制条件，比如：寻找**模长最小**的解$x$。也就是说，我们想要求解下面这个问题：

> 在约束条件$A\mathbf{x} = \mathbf{b}$下，最小化函数$L(x) = \mathbf{x}^T \mathbf{x}$。

这是一个典型的约束条件下的优化问题，可以使用拉格朗日乘子法求解。定义函数：

$$f(\mathbf{x}; \mathbf{\lambda}) = \mathbf{x}^T \mathbf{x} + \mathbf{\lambda}^T (A\mathbf{x} - \mathbf{b})$$

令$\frac{\partial f(\mathbf{x}; \mathbf{\lambda})}{\partial x_i}=0$：

$$\begin{equation}\frac{\partial f(x; \lambda)}{\partial x_i} = 2x_i + \sum_{j = 1}^M\lambda_jA_{ji} = 0\end{equation}$$

令$\frac{\partial f(\mathbf{x}; \mathbf{\lambda})}{\partial \lambda_j}=0$

$$\begin{equation}\frac{\partial f(\mathbf{x}; \mathbf{\lambda})}{\partial \lambda_j} = \left(\sum_{i=1}^N A_{ji}x_i\right) - b_{j} = 0\end{equation}$$

根据公式$(1)$，可得：

$$\mathbf{x} = -\frac{1}{2}A^T\mathbf{\lambda}$$

由于$\mathbf{\lambda}$是我们人为定义的一个向量，它的值可能是任意的。不妨直接令$\mathbf{\mu} = -\frac{1}{2}\mathbf{\lambda}$，则原式可以写成$\mathbf{x} = A^T\mathbf{\mu}$。

再带入我们的限制条件，有：

$$AA^T\mathbf{\mu} = \mathbf{b}$$

$$\mathbf{x} = A^T\mathbf{\mu} = A^T(AA^T)^{-1}\mathbf{b}$$

如果$A$是$M\times N$的矩阵，那么$AA^T$就是$M\times M$的方阵，可以使用常规的矩阵方程求解方法去求解出$\mathbf{\mu}$，再对其直接乘$A^T$即可得到$\mathbf{x}$。

### 过约束情况

如果约束条件多于未知数个数，而我们仍然想找到尽可能准确的解，那该怎么办呢？既然没法找到精确解，不妨找一个误差最小的解。

不妨定义$L(\mathbf{x}) = \vert A\mathbf{x} - \mathbf{b}\vert^2$作为我们的目标函数。我们希望找一个使得$L(\mathbf{x})$最小的向量$\mathbf{x}$。这是一个无约束的优化问题，并且目标函数的性质足够好，直接寻找梯度为0的点即可。

$$
\begin{align*}
\frac{\partial L(\mathbf{x})}{\partial \mathbf{x}} &= \frac{\partial (A\mathbf{x} - \mathbf{b})^T(A\mathbf{x} - \mathbf{b})}{\partial \mathbf{x}} \\
& = \frac{\partial (\mathbf{x}^TA^TA\mathbf{x} - 2\mathbf{b}^TA\mathbf{x} + \mathbf{b}^T\mathbf{b})}{\partial \mathbf{x}} \\
& = 2(A^TA)\mathbf{x} - 2A^T\mathbf{b}
\end{align*}
$$

$$2(A^TA)\mathbf{x} - 2A^T\mathbf{b} = 0$$

$$\mathbf{x} = (A^TA)^{-1}A^T\mathbf{b}$$

这个问题也可以看作是求解$N\times N$方阵$A^TA$和$N$维向量$A^T\mathbf{b}$的矩阵方程，同样可以用标准的方程求解算法来求解。

## 程序部分：Rust实现

最终结果在[这里](https://mqcreaple.github.io/app/truss-analysis/index.html)展示。欢迎测试。

### 计算

这次我选择了Rust作为编程语言，因为它能直接编译成Webassembly格式，能在web上运行同时不会损失太多性能。线性代数部分使用了`nalgebra`库。

首先定义两个类型用于表示节点和杆：

```rust
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Beam {
    pub start: usize,
    pub end: usize,
    pub mass: f64,
}

#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, FromPrimitive)]
pub enum NodeType {
    /// A hinge node allows free rotation around the node, but imposes the restriction that the sum of forces
    /// on the node must be 0.
    #[default]
    Hinge = 0,

    /// A fixed hinge node is a hinge node fixed in place. It restricts the movement of objects connecting
    /// to the node, but does not restrict the force.
    FixedHinge,
}

#[derive(Debug, Clone)]
pub struct Node {
    pub pos: na::Vector2<f64>, // unit: pixel
    pub node_type: NodeType,
    pub external_force: na::Vector2<f64>,
}
```

接下来我们可以写一个函数来从一系列节点和杆中创建矩阵$A$和$\mathbf{b}$：

```rust
/// Given the positions of nodes, a list of fixed nodes, and a list of beams, return the forces acting on each end of the
/// beams as a list of vectors.
pub fn find_forces(
    nodes: &[Node],
    beams: &[Beam],
) -> Option<Vec<[na::Vector2<f64>; 2]>> {
    // variables are aranged as [Fsx, Fsy, Fex, Fey, ...], where [Fsx, Fsy] are the force components at the start of the beam,
    // and [Fex, Fey] are the force components at the end of the beam
    let num_variables = beams.len() * 4;
    let num_constraints = beams.len() * 3
        + nodes
            .iter()
            .map(|node| node.node_type.num_force_constraints())
            .sum::<usize>();
    let mut a = na::DMatrix::<f64>::zeros(num_constraints, num_variables);
    let mut b = na::DVector::<f64>::zeros(num_constraints);
    // add the beam constraints (sum of force and torque = 0)
    for (i, beam) in beams.iter().enumerate() {
        let index = i * 3;
        let start_pos = nodes[beam.start].pos;
        let end_pos = nodes[beam.end].pos;
        let angle = f64::atan2(end_pos.y - start_pos.y, end_pos.x - start_pos.x);
        // Fsx + Fex = 0
        a[(index, i * 4 + 0)] = 1.0;
        a[(index, i * 4 + 2)] = 1.0;
        // Fsy + Fey = mg
        a[(index + 1, i * 4 + 1)] = 1.0;
        a[(index + 1, i * 4 + 3)] = 1.0;
        b[index + 1] = -beam.mass * crate::common::GRAVITY_CONST; // because the y axis on the canvas points from top to bottom
        // Torque around center of mass = 0: (Fex - Fsx) * sin(theta) - (Fey - Fsy) * cos(theta) = 0
        a[(index + 2, i * 4 + 0)] = -f64::sin(angle);
        a[(index + 2, i * 4 + 1)] = f64::cos(angle);
        a[(index + 2, i * 4 + 2)] = f64::sin(angle);
        a[(index + 2, i * 4 + 3)] = -f64::cos(angle);
    }
    // add force constraints
    // assign an index for each node. Each tuple is the index of force constraints along x and y directions
    // in matrix `a` and vector `b`.
    let mut constraint_indices = Vec::<(isize, isize)>::with_capacity(nodes.len());
    let mut next_constraint = beams.len() * 3;
    for node in nodes {
        let next = match node.node_type {
            NodeType::Hinge => {
                next_constraint += 2;
                (
                    (next_constraint - 2) as isize,
                    (next_constraint - 1) as isize,
                )
            }
            NodeType::FixedHinge => (-1, -1),
        };
        if next.0 >= 0 {
            b[next.0 as usize] = node.external_force.x;
        }
        if next.1 >= 0 {
            b[next.1 as usize] = node.external_force.y;
        }
        constraint_indices.push(next);
    }
    // the sum of forces acting on each non-fixed node must be 0
    for (i, beam) in beams.iter().enumerate() {
        // start node contributions (Fsx, Fsy)
        let (sx_idx, sy_idx) = constraint_indices[beam.start];
        if sx_idx != -1 {
            a[(sx_idx as usize, i * 4 + 0)] = 1.0;
        }
        if sy_idx != -1 {
            a[(sy_idx as usize, i * 4 + 1)] = 1.0;
        }
        // end node contributions (Fex, Fey)
        let (ex_idx, ey_idx) = constraint_indices[beam.end];
        if ex_idx != -1 {
            a[(ex_idx as usize, i * 4 + 2)] = 1.0;
        }
        if ey_idx != -1 {
            a[(ey_idx as usize, i * 4 + 3)] = 1.0;
        }
    }
    
    todo!()
}
```

填充完了矩阵的各个元素之后就可以去求解了。`nalgebra`库提供了函数`lu()`可以直接给矩阵做LU分解，而分解之后就可以用`solve()`函数逐行代入求解。

```rust
/// Find the best solution of matrix equation $Ax = b$.
///
/// For the equation to have a solution, the first dimension of `a` and the length of `b` must match.
///
/// - If `A` is an $N\times N$ square matrix, this function attempts to find the precise solution of the
///   matrix equation, if any.
/// - If `A` is an $M\times N$ matrix, where $M \lt N$, the number of constraints is less than the number of
///   free variables. The function tries to find the solution $x$ that minimizes $|x|^2$.
/// - If `A` is an $M\times N$ matrix, where $M \gt N$, the number of constraints is greater than the number
///   of free variables. The function tries to find the vector $x$ that minimizes $|Ax-b|^2$.
pub fn find_best_solution(
    a: na::DMatrix<f64>,
    b: na::DVector<f64>,
) -> (std::cmp::Ordering, Option<na::DVector<f64>>) {
    debug_assert_eq!(a.nrows(), b.nrows());
    if a.nrows() == 0 || a.ncols() == 0 {
        // return a zero-length solution
        return (
            std::cmp::Ordering::Equal,
            Some(na::DVector::<f64>::zeros(a.ncols())),
        );
    }
    if a.nrows() == a.ncols() {
        (std::cmp::Ordering::Equal, a.lu().solve(&b))
    } else if a.nrows() < a.ncols() {
        let at = a.transpose();
        let aat = &a * &at;
        let y = aat.lu().solve(&b);
        (std::cmp::Ordering::Less, y.map(|y| at * y))
    } else {
        let ata = a.transpose() * &a;
        let atb = a.transpose() * &b;
        (std::cmp::Ordering::Greater, ata.lu().solve(&atb))
    }
}
```

接下来就可以用`find_best_solution`函数去计算这个系统各个杆上的受力了。

### 可视化

可视化部分使用了`web_sys`包与canvas交互。`web_sys`其实就是用Rust写的Javascript Web DOM的封装，目前几乎所有可以在Javascript中做得操作都可以在`web_sys`里找到。

同时我还用一个侧边的canvas来可视化上面计算出来的矩阵$A$和$b$。这里使用了WebGL来渲染canvas，将矩阵$A$和向量$b$并排后作为一个贴图传进去，接着用WebGL画一个充满了整个屏幕的四边形，将贴图贴在这个四边形上。这部分的代码过于繁琐，就不展示了。可以在[GitHub仓库](https://github.com/MqCreaple/truss-analysis)里查看源码。

## 优化：稀疏矩阵求解算法

使用上述方法计算较小的矩阵还好，但是一旦矩阵变大，这个计算过程就会以$O(N^3)$的时间复杂度增加。实测中一旦节点数超过500就会有明显的卡顿，而这显然不可取。

注意观察我们会发现，矩阵$A$的绝大部分元素都是0，也就是说，矩阵$A$是**稀疏**的。而针对稀疏矩阵方程，迭代法的效率远高于直接高斯消元。

### 简单迭代法

一个朴素的思路是，对于方程$A\mathbf{x} = \mathbf{b}$，构造一个函数$g(\mathbf{x})$使得将$g(\mathbf{x})$反复作用与任何向量上之后都可以让它收敛到我们想要的结果上。我们不妨选择一个简单的函数：

$$\mathbf{x}^{(n)} = B\mathbf{x}^{(n-1)} + \mathbf{f}$$

其中$\mathbf{x}^{(n)}$表示第$n$次迭代的结果。接下来我们尝试分析：这个函数什么情况下会收敛？会收敛到什么值上？

将$\mathbf{x}^{(n)}$一路展开到$\mathbf{x}^{(0)}$，即可得到：

$$
\begin{align*}
\mathbf{x}^{(n)} & = B\mathbf{x}^{(n-1)} + \mathbf{f} \\
& = B(B\mathbf{x}^{(n-2)}+\mathbf{f})+\mathbf{f} = B^2\mathbf{x}^{(n-2)} + (I + B)\mathbf{f} \\
& = \cdots \\
& = B^n\mathbf{x}^{(0)} + \left(\sum_{i = 0}^{n - 1}B\right)\mathbf{f}
\end{align*}
$$

使用等比数列求和公式，得到：

$$\mathbf{x}^{(n)} = B^n\mathbf{x}^{(0)} + (I - B)^{-1}(I - B^n)\mathbf{f}$$

不难看出，如果$\lim_{n\to\infty} B^n = \mathbf{0}$，那么这个序列就会收敛到：

$$\lim_{n\to\infty}\mathbf{x}^{(n)} = (I - B)^{-1}\mathbf{f}$$

只要我们构造的$B$和$\mathbf{f}$满足$(I - B)^{-1}\mathbf{f} = A^{-1}\mathbf{b}$，就可以用迭代法让$x$收敛到我们想要的结果上。同时另一个明显的结论是，矩阵$B$越接近$0$，这个序列就收敛得越快。因此，最优的$B$和$f$的选择应当满足如下几个条件：

1. $B$和$f$应当可以从$A$和$b$两个量中使用简单运算（加减、矩阵乘法、不依赖大量运算的矩阵分解）中得到。
2. $(I - B)^{-1}\mathbf{f}=A^{-1}\mathbf{b}$
3. $\lim_{n\to\infty}B^n = 0$，且$\Vert B\Vert$应当尽量小。

那么具体怎么构造这里的矩阵$B$和向量$f$呢？

梯度下降法给我们提供了一个思路。不妨令损失函数

$$L(\mathbf{x}) = \frac{1}{2}\mathbf{x}^TA\mathbf{x} - \mathbf{x}^T \mathbf{b}$$

$L(x)$的梯度就是：

$$\frac{\partial L(\mathbf{x})}{\partial \mathbf{x}} = A\mathbf{x} - \mathbf{b}$$

不难看出这个函数在$\mathbf{x}=A^{-1}\mathbf{b}$这个点上取最小值。我们任取一个点$\mathbf{x}^{(0)}$作为起点，对其做固定步长的梯度下降，就得到了如下的迭代方程：

$$\mathbf{x}^{(n)} = \mathbf{x}^{(n-1)} - \lambda(A\mathbf{x}^{(n-1)} - \mathbf{b}) = (I - \lambda A)\mathbf{x}^{(n-1)} + \lambda \mathbf{b}$$

$$\begin{cases}B = I - \lambda A \\ \mathbf{f} = \lambda \mathbf{b}\end{cases}$$

如果$A$正定且$\lambda$小于$A$最大特征值的倒数，那么这个序列就会收敛，且不难验证它会收敛到$A^{-1}\mathbf{b}$上。但由于这个序列的收敛速度过慢且过于占用内存，一般不会在工业场景中使用这个算法。

#### 高斯-赛德尔迭代（Gauss-Seidel Method）

接下来的这个算法也是迭代法的一种。先看算法过程：对于$A$和$b$：

1. 初始化一个随机的向量$\mathbf{x}$
2. $i$从$0$遍历至矩阵宽度$N$
3. $$x_i\leftarrow \frac{1}{A_{ii}}\left(b_i - \sum_{j \lt i}A_{ij}x_j - \sum_{j \gt i}A_{ij}x_j\right)$$
4. 重复第2步，直到$x$与目标值足够接近后结束程序

你可能会说，这个过程看起来也不像迭代过程啊？为什么你说它也是迭代法呢？

我们不妨将$x_i$的各个历史值区分开来，用$x_i^{(n)}$标记第$n$次迭代给$x_i$赋的值。也就是说，当我们在第$n$轮遍历到$x_i^{(n)}$时，已经将所有$i$之前的$x_j$给赋值过了，但$i$之后的$x_j$则还没有赋值。也就是：

$$x_i^{(n)} = \frac{1}{A_{ii}}\left(b_i - \sum_{j \lt i}A_{ij}x_j^{(n)} - \sum_{j \gt i}A_{ij}x_j^{(n-1)}\right)$$

可能现在看起来还不是很明显。接下来我们将矩阵$A$拆开成一个严格下三角矩阵、一个对角矩阵和一个严格上三角矩阵：

$$A = L + D + U$$

$$L_{ij} = \begin{cases}A_{ij}, & j \lt i \\ 0, & \text{otherwise}\end{cases}$$

$$D_{ij} = \begin{cases}A_{ij}, & j = i \\ 0, & \text{otherwise}\end{cases}$$

$$U_{ij} = \begin{cases}A_{ij}, & j \gt i \\ 0, & \text{otherwise}\end{cases}$$

那么就可以将迭代过程写成这样的矩阵形式：

$$\mathbf{x}^{(n)} = D^{-1}(\mathbf{b} - L\mathbf{x}^{(n)}-U\mathbf{x}^{(n-1)})$$

$$(D + L)\mathbf{x}^{(n)} = \mathbf{b} - U\mathbf{x}^{(n-1)}$$

$$\mathbf{x}^{(n)} = (D + L)^{-1}\left(\mathbf{b} - U\mathbf{x}^{(n-1)}\right)$$

也就是说，这个过程也可以写成$\mathbf{x}^{(n)} = B\mathbf{x}^{(n-1)} + \mathbf{f}$的形式！其中的$B$矩阵是$-(D + L)^{-1}U$，$\mathbf{f}$向量是$(D + L)^{-1}\mathbf{b}$。同样可以代入之前的三个条件中检验这个算法最终会收敛到$A^{-1}\mathbf{b}$。

高斯-赛德尔迭代的好处是，它在执行过程中不用分配任何额外的内存，每一步使用的值都是之前算出来且还没有被覆盖掉的值。这个算法直接存储一个向量$x$，随时间迭代，就可以无限逼近精确解。这个算法在那个一寸内存一寸金的时代发挥了很大的用处，只不过随着技术进步，它也逐渐被更好的算法替代了。

高斯-赛德尔迭代法有一个改进版本，叫**逐次超松弛迭代法（successive over-relaxation, SOR）**。它在原本的迭代算法上加了一个参数$\omega$：

$$\mathbf{x}^{(n)} = (D+\omega L)^{-1}\left(\omega\mathbf{b} - [\omega U + (\omega - 1)D]\mathbf{x}^{(n-1)}\right)$$

$$x^{(n)}_i = (1 - \omega)x^{(n-1)}_i + \frac{\omega}{A_{ii}}\left(b_i - \sum_{j \lt i}A_{ij}x_j^{(n)} - \sum_{j > i}A_{ij}x_j^{(n-1)}\right)$$

通过调整$\omega$的值，可以让$B$矩阵尽可能地小，从而让算法收敛得更快。经过实测，使用SOR算法可以在不卡顿的情况下计算超过2000个节点。

#### 共轭梯度法

先挖个坑，以后再填（
