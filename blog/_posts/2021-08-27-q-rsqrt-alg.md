---
title: 位运算的极致——快速平方根倒数算法
layout: blog
tags: ["C++", "algorithm"]
---

快速平方根倒数算法，最早见于1999年的3D游戏Quake III Arena的源代码中。该算法一经公布，立刻因它的巧妙而被广为流传

在当时，计算机的算力和算法还没有现在这样厉害，浮点数乘除法的计算代价都很高，更不要说平方根了。

另一方面，3D物理引擎几乎要求你每时每刻都要计算各种平方根。比如，计算力矢量在某个方向上的分量，需要计算$\hat v=\dfrac{\vec v}{\mid\vec v\mid}$，就会用到平方根倒数

温馨提示：请先阅读文章的最后一段，接着再从头开始阅读

## 代码

这是一般人写出来的：

```c
float rsqrt(float x) {
    return 1 / sqrt(x);
}
```

看起来人畜无害，不是吗？

但是注意，在当时，sqrt函数使用的算法本身就很慢，导致使用上面的函数计算平方根倒数效率极低

而下面这个，是Quake使用的快速平方根倒数算法：

```c
float q_rsqrt(float x) {
    long i;
    float x2, y;
    const float threehalves = 1.5F;

    x2 = x * 0.5F;
    y = x;
    i = *(long*) &y;
    i = 0x5f3759df - (i >> 1);
    y = *(float*) &i;
    y = y * (threehalves - (x2 * y * y));
    // y = y * (threehalves - (x2 * y * y));

    return y;
}
```

看完是不是一脸问号？没关系，任何人看完都会一脸问号，因为这个算法用到了很多奇怪的知识

前置知识

- 知道C和C++中的指针
- 知道电脑使用二进制存储信息
- 知道什么是导数

（下方高能预警）

## #1 浮点数的计算机表示

假设现在你有一个二进制小数，可是计算机只认识01组成的二进制串，并不认识小数，你该怎么办呢？

```plaintext
_ _ _ _ _ _ _ _   _ _ _ _ _ _ _ _   _ _ _ _ _ _ _ _   _ _ _ _ _ _ _ _
```

容易想到，我只要在这个二进制串的某一个地方点一个小数点，小数点左边的作为整数位，右边的作为小数位，问题就解决了

```plaintext
_ _ _ _ _ _ _ _   _ _ _ _ _ _ _ _  .  _ _ _ _ _ _ _ _   _ _ _ _ _ _ _ _
```

比如，二进制小数$(101101.01101)_2$，用我们刚刚的方法，就可以写成：

```plaintext
0 0 0 0 0 0 0 0   0 0 1 0 1 1 0 1  .  0 1 1 0 1 0 0 0   0 0 0 0 0 0 0 0
```

小数的加减法也很简单，因为小数点永远固定，只需要忽略掉小数点，将他们全都当作二进制整数整数进行加减即可

这就是**定点数**，假想的小数点在某一个固定位置不会移动

与之对应的，则是**浮点数**，这个名词在学习C语言时应该听了无数遍了。 浮点数的字面意思是：**小数点能够移动**

可能这样不太直观，我们先回想一下**科学计数法**：一个数可以被分解成一个$1$到$10$之间的小数和某个$10$的次幂之积。比如：

$$34567.89=3.456789\times 10^{4}$$

我们只需要写下这个$1$到$10$之间的有效数字，以及数的次幂（或者说是小数点的位置），即可唯一确定这个数

注意到，有效数字一定在$1$到$10$之间，也就是说它小数点左边必须有且只有一位数字

对于二进制数，也可以进行类比，只不过底数不再是10，而是2：

$$(101101.01101)_2=(1.0110101101)_2\times 2^{(101)_2}$$

那么，另一个思路来了：我们可以直接存储**有效数字**和**小数点位置**。这就是浮点数的基本思路

当然，不难注意到，有效数字的开头一定不能是$0$，否则一定可以写成另一个数字乘上$2$的负数次方。 例如：

$$(0.01011)_2=(1.011)_2\times 2^{(-10)_2}$$

而二进制中，除了$0$，那么必然是$1$。也就是说，**二进制有效数字的第一位必须是1**。所以说我们可以不用存储有效数字的首位，只存储小数点后的数字，计算的时候在开头补上$1$即可。

最后，为了能够表示负数，需要单独拿出来一位二进制作为**符号位**（0为正，1为负）。我们得到了浮点数的IEEE754规则：

```plaintext
S   E E E E E E E E   M M M M M M M M M M M M M M M M M M M M M
```

第1位是符号位$S$，0表示正数，1表示负数。

第2到9位是指数位$E$，$E$的范围是$0$到$255$，会自动减去$127$，否则无法表示负数指数，也就是说它的实际值应该是$-127$到$128$

第10到32位是有效数字位$M$，共23位，运算时需要在在前面脑补一位$1$和小数点

也就是说，这一串二进制所表示的浮点数实际值等于：

$$(-1)^S\times 2^{E-127}\times (1+\frac{M}{2^{23}})$$

## #2 算法的第一部分

说完了预备知识之后，接下来，进入平方根倒数的求解过程

显然负数不可能有平方根，因此我们可以默认输入的$x$必须是正数，也就是符号位$S$为0

如果平方根不好求的话，我们不妨先算一下$x$的对数

你也许会说，难道对数不应该更难计算吗？没关系，请看下面：

$$
\begin{align*}
x & = 2^{E-127}\times (1+\frac{M}{2^{23}}) \\
\log_2 x & = \log_2(1+\frac{M}{2^{23}}) + \log_2\left(2^{E-127}\right) \\
& = \log_2(1 + \frac{M}{2^{23}}) + E - 127
\end{align*}
$$

现在式子还是有点复杂，不妨对它取一个近似：当$a\in[0,1]$时，$\log(1+a)$可以近似成aa加上某个常数$\sigma$

$$\log(1+a)\approx a+\sigma$$

![q-rsqrt-0](/img/q-rsqrt-0.jpg)

绿色曲线为$\log_2(1+x)$，黄色直线为$x+\sigma$。如果想让误差最小，那么$\sigma$应该取大约$0.043$，通过微积分可以算出准确值，这里就不写了

有了这个知识，原式可以近似成：

$$\log_2 x \approx \frac{M}{2^{23}}+\sigma+E-127$$

$$\log_2 x=\frac 1{2^{23}}(M+E\cdot 2^{23}) - (127 - \sigma)$$

为什么要这样整理呢？我们不妨考虑另一件事：如果我们*强行将这个浮点数的二进制表达解读成整数*，会得到什么呢？

```plaintext
0   E E E E E E E E M M M M M M M M M M M M M M M M M M M M M
```

第一位是符号位，而后面31位是数字位，最终我们得到了一个整数：

$$\bar x=\overline{EM}=E\cdot 2^{23}+M$$

暂且将这个数称为浮点数的整数值。不难看出刚刚推导$\log_2 x$时就推出了一模一样的表达式！接着将$\bar x$代回原式，得到：

$$\log_2x\approx\frac{\bar x}{2^{23}}-(127-\sigma)$$

现在，我们知道了：**浮点数的对数，约等于它的整数值减去某一个常数**

这样我们就能理解之前代码中的这个步骤了：

```c
i = *(long*) &y;
```

这其实就是在*计算浮点数的整数值*！ 注意，直接写`i = (long) y;`是错的，因为这样会算出来浮点数下取整，而不是刚刚提到的*整数值*

那么有了这个结论，求出平方根倒数就很简单了：

$$\log_2 y=\log_2(\frac1{\sqrt{x}})=-\frac12\log_2(x)\approx\frac 12(127-\sigma)-\frac 12\frac{\bar x}{2^{23}}$$

那么$y=1/\sqrt{x}$的整数值为：

$$
\begin{align*}
\bar y &\approx 2^{23}\log_2 y + 2^{23}(127-\sigma) \\
& = (2^{22} + 2^{23})(127 - \sigma) - \frac{\bar x}{2} \\
& \approx \text{0x5F3759DF} - \frac{\bar x}{2}
\end{align*}
$$

其中`0x5F3759DF`就是大名鼎鼎的“魔法值”。最后只需要将$\bar y$再强行转换成浮点数即可

以上就是算法的第一部分

当然，这里还有另一个技巧：`i >> 1`表示将整数$i$整个向右移动1个二进制位，也就是将$i$除以$2$

```plaintext
i    = 00011011 01101100      >>> right shift 1 digit
i>>1 = 00001101 10110110
```

综上所述，代码：

```c
i = *(long*) &y;
i = 0x5F3759DF - (i >> 1);
y = *(float*) &i;
```

> 你能试试求出64位浮点数的“魔法值”吗？

## #3 代码的第二部分

注意到上面的所有推导，使用的几乎全都是**约等于号**，而不是等于号，因此计算出来的这个数字仍然有一定的误差。后续，我们接着使用牛顿迭代法求出精确解。

那**牛顿迭代法**又是什么？

假设现在我们有一个函数$f$，目标是求出它的根（即所有$x_0$使得$f(x_0)=0$），而我们只知道一个函数上的点$A=(x, f(x))$，怎么办？

![q-rsqrt-1](/img/q-rsqrt-1.jpg)

现在，我们作一条$A$点上的切线，切线与横轴的交点作为第一轮迭代的结果

![q-rsqrt-2](/img/q-rsqrt-2.jpg)

可以看到迭代后的点离函数的根已经近了很多

![q-rsqrt-3](/img/q-rsqrt-3.jpg)

我们还可以将一轮迭代的结果作为新的起点，进行第二轮迭代，接着第三轮、第四轮、……，最终就可以无限接近函数的根，并且迭代的收敛速度非常快

那么对于“求解平方根倒数”的这个例子，我们可以构造一个函数：

$$f(y)=\frac 1{y^2}-x$$

令$x$为一个常数，而$y$为变量，不难发现这个函数的根就是$y=1/\sqrt{x}$，那么我们的任务就是求解这个函数的根

那么，从$y_0$开始，采用上面的方法迭代，即

$$y_{n+1}=y_n-\dfrac{f(y_n)}{f'(y_n)}$$

代入$f(y)=\dfrac1{y^2}-x$，得到：

$$y_{n+1}=\dfrac{y_n(3-xy_n^2)}{2}=y_n\left(\dfrac32-\dfrac12xy_n^2\right)$$

这也就是代码最下方那个奇怪的表达式的含义：

```c
y = y * (threehalves - (x2 * y * y));
```

经过一轮迭代，已经差不多能将误差控制在小数点后4位左右了，如果想要更加精确，也可以接着进行2、3、4轮迭代

以上就是算法的全过程，最后再贴一遍完整代码：

```c
float q_rsqrt(float x) {
    long i;
    float x2, y;
    const float threehalves = 1.5F;

    x2 = x * 0.5F;
    y = x;
    i = *(long*) &y;
    i = 0x5f3759df - (i >> 1);
    y = *(float*) &i;
    y = y * (threehalves - (x2 * y * y));
    // y = y * (threehalves - (x2 * y * y));

    return y;
}
```

## 这个算法有什么意义？
如果你认真看完了上面的全过程，我要遗憾的告诉你：**你可能永远也用不上它**

现在早已不是1999年了，硬件的更新和算法的改进让**任何编程语言的内置函数都无法轻易被超越**

如果你用C语言或者C++进行测试的话，你会发现库函数`sqrt(x)`的速度要远远超过上面的算法

但是，把这个算法当作一个精致的艺术品反复观赏，也是一件挺有意思的事情，你也可以从里面学到不少