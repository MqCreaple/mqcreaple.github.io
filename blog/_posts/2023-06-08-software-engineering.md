---
title: 工程代码中的低级错误
layout: blog
tag: ["computer-science", "programming-language", "software-engineering"]
---

（懒得起一个好点的标题了）

最近在写学校计算机社的坦克小游戏，然后被自己写的代码搞崩溃了。趁着现在实在懒得写代码的时候，我就顺便写点文章来总结一下这一年多里学到的和领悟到的有关编程语言和代码工程的知识。

## 软件工程

**软件工程\(software engineering\)**这个学科所做的最重要的一件事情是：将一个具象的问题通过某种方式表示成计算机的代码，并且这个代码需要有如下性质：

- 正确性：代码必须完全正确地解决实际问题
- 可维护性：在遇到错误的时候，代码需要做尽量少的修改来解决问题
- 一定的可扩展性：在遇到新的需求的时候，需要改动尽量少的原有代码来适应新的需求。

当然，在你和其他人合作的时候，代码还有如下需求：

- 分工的明确性：每一项具体的功能只应该被一个人完成

这听起来非常简单，但是在实际的实践过程中可能会出现各种各样的问题。甚至光是如何将真实问题转化成电脑可以理解的形式，这里面都有很多需要注意的点。

## 变量名和地址的对应

首先一点就是：**变量名、变量名表示的值、和变量对应的内存地址并不是一一对应的**。

比如下面这段C语言代码：

```c
char a[] = "Hello, World";
char *b = a;
char c[] = "Hello, World";
char *d = malloc(sizeof(a));
strcpy(d, a);
```

这段代码中，四个变量所表示的逻辑对象都是“值等于`Hello, World`的字符串”，但是在这四个字符串变量中只有`a`和`b`两个变量所对应的内存地址是相同的，`a`, `c`和`d`三个变量的地址都是不同的。

如果两个变量的内存地址相同，这就意味着修改一个变量的某个成员，另一个变量的对应成员也会相应地变化。例如在上面的代码之后如果接着执行如下代码：

```c
a[2] = ' ';
printf("%s\n", b);
```

则会发现变量`b`的对应字符也改变了。

以上现象相信只要你学过一些基础的编程语言就应该能够理解了。但是，在实际工程中，变量名和内存之间相互对应的不清晰总是会导致许多低级错误。

### 赋值语句的歧义

当然，程序的编写者有些时候并不应该承担这种错误的全部责任，很多时候编程语言的歧义性才是最大的问题。

例如在C++中，你能在不查文档的情况下告诉我，以下语句中`b`仅复制了`a`的地址，还是`b`复制了`a`的值？

```cpp
// #1
std::vector<int> a({1, 2, 3, 4, 5});
std::vector<int> b = a;

// #2
std::string a = "Hello, World";
std::string b = a;
```

以及如下的Java语句中，`b`仅复制了`a`的地址，还是`b`复制了`a`的值？

```java
// #3
ArrayList<Integer> a = new ArrayList<>(List.of(1, 2, 3, 4, 5));
ArrayList<Integer> b = a;

// #4
String a = "Hello, World";
String b = a;
```

真实的答案是：
1. 复制值
2. 复制值
3. 复制地址
4. 复制地址，但是每次更改一个变量都会把它变成一个新的对象，所以基本上等价于复制值

再来一个Java的例子：

```java
int[][] a = new int[][] { {1, 2, 3}, {4, 5, 6} };
int[][] b = a.clone();
b[0][0] = 0;
for(int[] row : a) {
    for(int value : row) {
        System.out.print(value + " ");
    }
    System.out.println();
}
```

看起来`b`好像已经通过`clone`方法把`a`的值复制了一遍了，但是实际上这段代码输出的结果是：

```plaintext
0 2 3
4 5 6
```

因为在Java里，二维数组实际上是一个“数组的数组”。在第一层数组里，每个元素都是一个指针，指向着第二个数组的起始位置。这里的`clone`方法只是复制了第一层数组，但是它所指向的第二层数组的地址仍然是相同的。因此，修改`b`的某个具体元素仍然会改变`a`对应位置的元素。

可以看出，即便是同样的赋值语句，在不同的语言里和不同的方法里，它的含义都是不同的。尤其是在一个语言支持重载赋值运算符的时候，这个“等号”本身可能都是一个用户自定义的方法。在这种情况下，明确说明赋值语句到底是复制了值还是地址是非常必要的。

## 可变性

如果你大概了解过计算机的底层原理，那么你应该知道：计算机其实是可以在任何时刻更改任何地址的值的。具体哪些位置是可以改的，哪些位置改了会出问题，这些都是编程语言对用户行为做出的规范。

有时候编程语言会约束用户，不允许用户更改某个变量相关的值。这种性质称为这个变量的**可变性(mutability)**。

### 两种可变性

在处理结构体和对象的时候，“可变性”有两种不同的含义：

- 变量是否能被重新赋值，即如下伪代码
  ```code
  var a <- something
  a <- another value
  ```
  是否合法
- 变量的成员是否可以被更改，即如下伪代码
  ```code
  var a <- something
  a.property <- another value
  ```
  是否合法
  
为了方便起见，我们称第一种可变为*可赋值*，第二种可变为*可写*。

不同的编程语言在“可变性”上也有不同的规则

- 有一些语言并不区分变量的可变性，比如Java语言本身没有约束任何变量的可变性，代码的编写者通过规定哪些函数是`public`、哪些是`private`来约束某个变量是否可写。
- 另一些语言只区分两种可变性的一种，如Kotlin的`var`和`val`只区分可否更改，而Rust的immutable则同时约束“可赋值”和“可写”两条属性。
- 有一些语言则在语法层面上同时规范了两种可变性。例如C语言的指针，`const char*`和`char const*`表示指针指向的内存不可写，而`char* const`表示指针本身的值不可改。

### 可变性导致的错误

没有正确处理变量是否可变也是代码错误的一大根源。比如很多初学Java的人可能会犯下面这样的错误：

```java
ArrayList<Integer> a = new ArrayList<>(List.of(1, 2, 3, 4, 5));

for(Integer x : a) {
    if(x % 2 == 0) {
        a.add(x + 1);
    }
}
```

这段代码想遍历数组`a`，对于每个数组中的偶数，在数组末尾添加这个数加1。但是这段代码会在运行时报错。

错误的原因是：使用for-each循环来遍历一个数组的时候，数组本身在循环的局部作用域里应当是不可变的。否则的话就会引起歧义：这些新加进来的数应不应该也一起被循环遍历一遍？还是说这个循环只应该遍历原来的数，不去遍历新加入的数？

由于Java语言本身没有对变量的可变性做出任何约束，这段代码在编译的时候是可以通过的，但是一旦运行起来就会抛出异常。而对于可变性有更强约束的Rust，同样的代码就连编译也过不了：

```rust
let mut a = vec![1, 2, 3, 4, 5];
for x in &a {
    if *x % 2 == 0 {
        a.push(*x + 1);
    }
}
```

### 分离“可变”和“不可变”

有时候你可能会想让同一个对象在某些语境下是可变的，某些语境下是不可变的，例如之前的for-each循环的例子。这个时候，标记对象的成员变量和成员函数的可变性就显得很重要了。

在许多面向对象语言中，改变特定成员的权限（`public`, `private`, etc.）可以约束用户的行为，让用户无法做出特定的改变。比如如果我们想要在Java里写一个字符串类，这是没有加权限说明的版本：

```java
class MyString {
  char[] chars;

  MyString(char[] chars) {
    this.chars = chars.clone();
  }

  char get(int i) {
    return this.chars[i];
  }

  void set(int i, char c) {
    this.chars[i] = c;
  }

  MyString getSlice(int start, int end) {
    char[] slice = new char[end - start];
    for(int i = start; i < end; i++) {
      slice[i - start] = this.chars[i];
    }
    return new MyString(slice);
  }
}
```

如果你希望这个类型是只读的，即用户不能更改字符串的值，那么你就应该将某些成员函数设置成私有(private)，像这样：

```java
class MyString {
  private char[] chars;

  public MyString(char[] chars) { ... }

  public char get(int i) { ... }

  private void set(int i) { ... }

  public MyString getSlice(int i) { ... }
}
```

注意这里的`getSlice`方法。由于这个方法创建了一个新的数组并复制了对应的子串，所以将它设置成`public`是安全的。

但是如果在另一个场合下，你希望此时用户持有`MyString`时可以更改它的值，那么你就要创建一个新的类：

```java
class MyStringMutable {
  public char[] chars;

  public MyStringMutable(char[] chars) { ... }

  public char get(int i) { ... }

  public void set(int i) { ... }

  public MyString getSlice(int i) { ... }
}
```

然后再定义两个类之间的转换方法：

```java
class MyString {
  ...

  public MyString(MyStringMutable str) { ... }
}

class MyStringMutable {
  ...

  public MyStringMutable(MyString str) {}
}
```

而在其他语言中，例如C++，可能会有更好的解决方案。C++里在函数定义的末尾加上`const`关键字可以将它声明成一个“只读成员函数”。C++的编译器保证了这个函数里只能读取成员变量但是不能更改成员变量。比如上面的字符串的例子：

```cpp
class MyString {
  private:
    char chars[128];
  public:
    MyString(char *chars) { ... }
    char get(int i) const { ... }
    char set(int i, char c) { ... }
    MyString getSlice(int start, int end) const { ... }
}
```

这样的话`MyString`类型的变量就可以访问所有的成员函数，但是`const MyString`类型的变量就只能访问带有`const`标记的成员函数，即`get`和`getSlice`。

通常来说一个函数的参数和返回值越不可变，这个函数就越安全，尤其是在有多线程的时候。因为编译器在语法的层面上就杜绝了用户乱改值的情况。理论上其实就算代码的所有变量都是不可变的，仍然可以通过一些巧妙的设计来实现所有的功能（函数式编程其实就是基于这个理念的），但是在很多场合下给变量更多可变性会大大简化工程难度，以及让代码更易懂。

## 线程

当你的程序需要让多个任务并行执行的时候，**多线程(multithreading)**几乎就是必不可少的。大部分编程语言都有对应的多线程接口，通常它们都包括这些内容：

- 创建线程：传入一段需要执行的代码（通常传入一个无参数的函数或者lambda表达式），操作系统会在当前线程之外创建一个新的线程来并行执行这段代码。
- 结束线程：结束当前线程
- 等待线程：当前的线程一直等待到另一个线程结束执行。

频繁的创建/结束线程会有较大的时间和空间开销，所以在不追求太高性能的情况下，能用尽量少线程完成的任务就不要开太多非必要的线程。通常CPU会有一个硬件并行数，表示CPU在硬件层面上最多支持多少线程同时运行，一般来说一个程序的线程数量如果超过CPU的硬件并行数，再开更多的线程就不会提升程序运行速度了。

如果需要执行的任务数量远超过线程数量，并且这些人物之间没有较强的依赖关系的话，那么可以尝试使用**线程池(thread pool)**。线程池会预先开出来很多线程，并且将所有任务存在一个队列里并依次分配给每个线程，保证每个线程在每个时刻只会执行一个任务。

当然，多线程在带给我们并行处理的便利的同时，也带来了许多问题。

### 共享变量

大多数的应用场景下，各个线程之间并不是完全独立的，之间可能也需要传递或者共享一些信息。这个时候该怎么处理呢？

虽然不同的线程可能会跑在不同的CPU核心上，但是它们都共享同一块内存。如果两个线程都知道某个全局变量的地址，那么它们就可以去尝试读取和写入这个变量。这样就有可能在两个线程之间传递信息了。比如下面的C++代码：

```cpp
int global = 1;

void thread1() {
    // 这个函数会跑在一条新的线程上
    global =  2;
}

int main() {
    // 这里是主线程
    thread t(thread1); // 创建一个新的线程，让它执行`thread1()`函数
    global = 3;
    cout << global << endl;
    cout << global << endl;
    cout << global << endl;
    cout << global << endl;
    t.join();          // 等待新线程直到它结束
}
```

但是相信你也从这段代码里看到了这个方法的问题：由于两个线程在同时运行，你并不知道具体是第一个线程先写入数据还是第二个线程先读取数据。

当然，更不幸的事情会发生在两个线程同时试图尝试写入一个变量的时候。当同一时刻有多个线程尝试写入同一块地址的时候，由于操作系统的不确定性，这块地址最终会被写成哪个值都是不确定的。因此，我们需要找到方法来实现**线程同步**。

#### 互斥锁

一个非常重要而且好用的工具就是**互斥锁(mutual exclusion lock, mutex lock)**。互斥锁有两种状态：上锁，未上锁。互斥锁可以在多个线程之间共享，并且可以执行以下两种操作之一：
- 上锁(lock)：尝试将互斥锁的状态从“未上锁”变成“上锁”。如果互斥锁当前的状态是“上锁”，那么就一直等待到它的状态变成“未上锁”。
- 解锁(release/unlock)：将互斥锁的状态从“上锁”变成“未上锁”。

可以看出，在同一个时刻至多只能有一条线程“锁住”了互斥锁。因此，对于每个需要在多条线程之间共享的变量，必须给它配一个对应的互斥锁，并且每条线程在访问这个变量之前都需要先尝试上锁，否则就会出现多条线程同时尝试读取或者写入这个变量的情况。

比如上面的代码可以这样更改：

```cpp
int global = 1;
mutex global_lock;        // 定义一个互斥锁

void thread1() {
    global_lock.lock();   // 尝试上锁
    global =  2;
    global_lock.unlock(); // 尝试解锁
}

int main() {
    thread t(thread1);

    global_lock.lock();   // 尝试上锁
    global = 3;
    global_lock.unlock(); // 尝试解锁

    cout << global << endl;
    cout << global << endl;
    cout << global << endl;
    cout << global << endl;
    t.join();          // 等待新线程直到它结束
}
```

互斥锁还有一些变体，比如*读写锁(read-write lock)*，它的“上锁”状态有“读”和“写”两种模式，它允许多个线程同时将它锁到“读”模式，但在任何时刻只有至多一个线程能把它锁到“写”模式。这保证了多个线程可以同时读取某个地址，但只能有一个线程在写入这个地址，并且不会有一个线程在读的时候另一个线程在写。这在保证线程同步的时候也略微提升了一些性能。

#### 原子变量

如果你需要共享的变量是整数、浮点数、字符等比较小的数据类型，互斥锁的时间开销就显得有点大了。这时候更好的方法是使用**原子变量(atomic variable)**。

如果在线程之间共享常规变量，在对变量进行更改的时候，比如执行`+=`运算：

```cpp
int global = 1;

void thread() {
    global += 1;
}
```

这一条指令其实包含了多个小部分：
1. 从`global`的地址对应位置读取对应的整数值
2. 将这个值增加1
3. 将这个值写回`global`的地址

想象一下如果有两条线程同时执行`thread`函数。理想情况应该是这样的：

1. 线程1，读取`global`地址
2. 线程1，计算`global + 1`
3. 线程1，写回`global`地址
4. 线程2，读取`global`地址
5. 线程2，计算`global + 1`
6. 线程2，写回`global`地址

这样6条指令之后`global`的值会增加2。但是下面的这种情况虽然概率很小，但也有可能发生：

1. 线程1，读取`global`地址
2. 线程1，计算`global + 1`
4. 线程2，读取`global`地址 （此时线程1还没有写回`global`，所以现在在内存中`global`的值还没变）
3. 线程1，写回`global`地址
5. 线程2，计算`global + 1`
6. 线程2，写回`global`地址

这样的话，执行完这6条指令之后，`global`的值只增加了1。这并不是我们预期的结果。

**原子变量(atomic variable)**的优势就在于，它在执行任何会更改自身的指令的时候都不允许其他线程打断。具体这背后的原理我也不是很清楚，但是原子变量可以在较小的时间开销下避免上述的问题。

我们只需要将之前的代码里面的`int`替换成atmoic标准库里的`atomic<int>`即可：

```cpp
atomic<int> global = 1;

void thread() {
    global += 1;
}
```

#### 不可变变量的优势

如果你需要共享的变量是只读并且不可赋值的，那么你就甚至不需要使用任何互斥锁之类的操作来保证线程安全，因为不管有多少线程同时想去访问这个变量，只要它们不去改动变量的值，它们都不会造成任何错误。

如果你的共享变量是只读的但是允许被重新赋值，那么你只需要使用一个整数类型的原子变量来存储这个变量的地址就可以。每次访问变量的时候就读取这块地址对应的值即可。相比于互斥锁，使用原子变量的时间开销会小很多。

可以看到，在多线程中共享一个不可变的变量会减少很多保护措施带来的空间和时间开销，所以在写代码的过程中关注变量的可变性是非常重要的。

## 编程语言

说了这么多，我到底想要表达什么？

在现代的编程语言里，甚至最基本的“变量”的概念已经很复杂了。一个“变量”并不只是它代表的那个逻辑概念，它还包含“指向哪块地址”，“是否可变”，“是否需要在进程间共享”等额外信息。与这些特性相对应的就是一系列的语法层面的错误。

其实这些问题每一个单拎出来，都是编程语言里非常基础的问题，每一个编程语言的学习者应当对它们都了然于胸了。但是，一旦一个项目变得大起来、复杂起来，想要在一大堆代码中找出一个这样的小错误具体在哪就变得越来越困难，每一个这样看似微不足道的bug可能都需要花费几个小时甚至几天的时间仅仅是将它们定位出来。

但是我想着重强调的是，人是不可能不犯错的，而很多这些问题都可以被编译器通过一些简单的规则查出来。有些人可能觉得在函数的注释里写清楚函数参数和返回值是不是同一块地址、是否可变等就足够了，但实际上不是的。只要编译器没有在编译阶段禁止掉那些有可能出错的代码，那么用户就有可能在这里犯错，并且排查运行时错误所需要的时间通常比排查编译错误要长得多。所以我认为，好的代码写出来应该能够让编译器直接禁止掉用户的不合法操作，而不是通过写文档来要求用户按照你的要求去调用你的代码。

### 任何编程语言都无法解决的问题

上面的论点仍然有一个不可能解决的问题，那就是：**学习成本和语言精确性的矛盾**。

因为现实中的需求永远是复杂的，而代码的描述能力往往也是有限的。例如之前说过的“变量”这一个例子。

- 在Java中，任何变量都要么是原始类型（`int`, `char`, `float`, etc.），要么是一个对象。
  - 在类的外面只能访问一个对象的`public`成员变量和调用`public`成员函数
  - 对象在传参的时候永远使用引用传参
- 在C++中，变量可能是原始类型，对象，任何类型的指针，任何类型的引用，任何类型的右值引用，任何类型的常值类型，任何类型的常值指针（`const T*`），任何类型的常值引用（`const T&`）等等
  - 常值类型、常值指针、常值引用可以在类的外面访问指向的对象的`public const`成员函数；可变类型、可变指针、可变引用可以在类的外面访问所有的`public`成员函数。
  - 传参的时候如果参数不是引用类型，那么就会将参数复制；如果参数是引用类型，那么就会传入参数的引用。

可以看出来，C++为了处理类型的可变性，在它的语法上增加了很多额外的规则。这让程序员可以更加准确地描述变量的具体类型，但是同时也增加了新手的学习难度。

如果你想要在尽可能短的时间内快速学会一门新的编程语言并用它做项目，你不希望它的语法过于复杂或者拥有过多的特例，而是想让它越简单越好。但是如果规则过于简单，这就意味着这门语言没办法单纯通过语法来检查出可能出现的错误，而是需要靠语言的编写者去规范地使用它来避免错误。

这背后也有信息论的原理：当需要实现的逻辑完全相同的时候，一个编程语言描述地越精确，它所需要包含的信息量就越大，那么它写出来的代码就会越长、包含的语法规则就会越多。而写的代码越长、包含的语法规则越多就会让这个编程语言越难学习。

这也在另一方面说明了，我们的世界不可能只拥有一种编程语言，而是需要许多种不同的编程语言根据程序员的需求来填补不同的位置：在某些应用场景下就是需要简单易学的编程语言，在某些应用场景下就是需要尽量精确而不易出错的编程语言。而学习者在初学编程语言的时候通常也有一条确定的路径：先从简单易学的编程语言（如python）开始，一步步向后学习更多更底层、更具体的规则，接触其他的编程语言。
