---
title: 浅谈并行计算
layout: blog
tags: ["computer", "algorithm"]
---

前置知识：多线程

## 一个简单的例子

问题：给定两个大小均为$N$的整数数组`a`和`b`，将两个数组的元素逐个求和并将结果存到数组`c`中。即：`c[i] = a[i] + b[i]`。

很容易想到可以使用一个循环来实现这个操作：

```cpp
// N: 数组长度
void calcSum(int *a, int *b, int *c, int N) {
    for(int i = 0; i < N; i++) {
        c[i] = a[i] + b[i];
    }
}
```

这段代码依次遍历了`0`到`len`之间的所有下标，对每个下标对应元素执行一次求和+赋值操作。也就是说，代码的运行时间等于执行$N$次`c[i] = a[i] + b[i]`所需的时间。

细心的你可能会注意到，对于这个任务，每个下标`i`所对应的操作都是相互独立的，也就是说，我们其实可以让一堆`c[i] = a[i] + b[i]`一起运行而且它们之间不会相互干扰。比如这样：

```cpp
void calcSum2(int *a, int *b, int *c, int N) {
    int N2 = N / 2;
    std::thread t1(calcSum, a, b, c, N2);      // 创建一个新线程来处理区间[0, N2)
    calcSum(a + N2, b + N2, c + N2, N - N2);   // 在原来的线程里面处理区间[N2, N)
    t1.join();                                 // 同步两个线程，本代码中可以省略但不建议
}
```

它将数组从中间分成了两段，然后创建了两个线程来分别计算前半段和后半段。如果你的CPU有至少两个核，那么`calcSum2`计算同样长的一段数组所需的时间将是`calcSum`的一半。

当然，你也可以创建更多的线程来进一步加速这段代码，只要不超过硬件的物理限制即可。

## 并行计算的复杂度

如果你拥有一定的算法知识，那么应该对计算机如何执行一段程序不陌生了。而并行计算则相当于有**不止一台计算机在同时计算一个任务**。这几台计算机在执行各自的任务时不能产生冲突，比如同时访问同一块内存。也就是说，你需要**合理地将任务分配**给每一台计算机。

### 一个简陋的模型

我们可以先引入一个*简化版模型*。每个任务的代码可以被看作是由两部分组成：**串行部分**和**并行部分**。任务的并行部分能够被分割成数个相互独立的子任务，而串行部分则必须在单一计算机上执行。

![parallel](/img/parallel-0.png)

假设代码中并行部分占比为$c$，串行部分占比为$(1-c)$，那么如果可以最多并行执行$k$个任务，所花费的时间相比于全部串行的时间就是：

$$1-c+\frac{c}{k}=1-\frac{k-1}{k}c$$

而在最理想的情况下，有多到近乎无穷的并行容量时，执行该算法所花费的时间就等于串行部分需要花费的时间，即$(1-c)$。

并行计算不仅减少了计算时间，还有可能降低算法的时间复杂度。完全串行的情况下，时间复杂度等于*并行部分的时间复杂度*+*串行部分的时间复杂度*；而在理想并行的情况下，时间复杂度仅为*并行部分的时间复杂度*。如果随着数据规模$N$的提升，并行部分的时间复杂度提升的没有串行部分快，那么这样做就可以降低时间复杂度了。

在上面`calcSum`的例子中，所有代码都是串行的，没有并行部分。因此，只要有足够多的线程，那么算法的时间复杂度就可以从之前的$O(N)$降低为$O(1)$常数级别。

当然，这个模型实在是有些过于粗糙了，很多算法都不能被简单拆分成“并行”和“串行”两部分。但是相信你应该大致从中了解并行计算和以前熟知的计算方式的区别了。

### 分治树模型

我们考虑一个算法中十分常见的问题：**分治**。分治问题里可以使用一棵树来描述。

举个典型的例子：**归并排序**。以下为归并排序的伪代码：

```cpp
void mergeSort(int *a, int left, int right) {
    if(right - left == 1) {
        return;
    }
    mergeSort(left half of array a);
    mergeSort(right half of array a);
    merge the sorted two halves of array a
}
```

以下为`mergeSort`一个长度为7的数组是，函数调用的树形结构：

<div class="mermaid">
graph TD
A[1..7] --> B[1..4]
A --> C[5..7]
B --> D[1..2]
B --> E[3..4]
C --> F[5..6]
C --> G[7..7]
D --> H[1..1]
D --> I[2..2]
E --> J[3..3]
E --> K[4..4]
F --> L[5..5]
F --> M[6..6]
</div>

更一般地，区间分治问题的代码几乎都是下面这个形式的：

```cpp
void solve(..., int left, int right) {
    if(right - left == 1) {
        // do something here
        return;
    }
    solve(..., left, mid);
    solve(..., mid, right);
    // main code
}
```

根据分治的性质，函数调用树上面，如果两个结点不是祖先关系，那么它们之间一定是相互独立的，可以并行计算；而祖先关系的两个结点之间有数据依赖，必须先执行完子结点代表的函数之后才能执行父节点的函数。

因此，我们获得了并行计算这个分治问题的解法：对这棵树按层从下向上遍历，每一次并行执行一层中的所有结点函数。也就是这样：

![parallel](/img/parallel-1.png)

~~如果您有强迫症，请务必原谅我糟糕的绘画水平~~

按照图中数字标记的顺序，每次将当前层的所有函数并行执行即可。

接下来做复杂度分析。已知合并两个区间的时间复杂度为$O(N)$，其中$N$为待处理区间的长度，那么*完全串行*时，时间复杂度$T(N)$满足：

$$T(N)=T(\frac N2)+T(\frac N2)+O(N)$$

$$T(1)=0$$

解得：

$$T(N)=O(N\log N)$$

而在使用了上述的并行优化之后，由于左右两个区间的处理是并行的，在计算时间时只用加一遍，因此时间复杂度$T'(N)$满足：

$$T'(N)=T'(\frac N2)+O(N)$$

解得：

$$T'(N)=O(N)$$

可以看出使用并行计算之后，归并排序的时间复杂度减少了一个$\log N$。类似地，其他区间分治类问题都可以使用相同的方法来降低复杂度。

未完待续~~先挖上坑以后再填~~

## 参考资料

Cormen, Thomas, et al. *Introduction to Algorithms*. MIT press, 2022.
