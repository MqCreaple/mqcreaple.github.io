<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="mqcreaple.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="mqcreaple.github.io/" rel="alternate" type="text/html" /><updated>2023-01-24T11:50:14-05:00</updated><id>mqcreaple.github.io/feed.xml</id><title type="html">My Blog | MqCreaple</title><subtitle>pay more attention to the beauty of formulas!</subtitle><author><name>MqCreaple</name></author><entry><title type="html">battlecode开发日志</title><link href="mqcreaple.github.io/blog/2023/01/24/battlecode.html" rel="alternate" type="text/html" title="battlecode开发日志" /><published>2023-01-24T00:00:00-05:00</published><updated>2023-01-24T00:00:00-05:00</updated><id>mqcreaple.github.io/blog/2023/01/24/battlecode</id><content type="html" xml:base="mqcreaple.github.io/blog/2023/01/24/battlecode.html"><![CDATA[<p>最近几天由于打竞赛打到自闭了（我太菜了），想整点其他的事情做一做，在学校信息社的推荐下打算玩一下MIT办的<a href="https://battlecode.org/">battlecode</a>比赛。</p>

<p>battlecode是一个竞技性比赛。在一张固定大小的地图上，两方各有很多不同功能机器人，而最终的目的是操作机器人占领尽可能多的天空岛（sky island）。只不过玩家不能直接操控，而是要为场上的机器人写代码，让程序自动运行。</p>

<p>简要的说明一下规则：</p>
<ul>
  <li>机器人有如下几类
    <ul>
      <li>总部（headquarter）：不能移动，可以存储资源，也可以消耗矿物来搭建其它类型的机器人</li>
      <li>运输器（carrier）：可以用来在指定矿点挖矿，也可以用来搬运锚点（anchor）</li>
      <li>发射器（launcher）：可以用来打人</li>
      <li>减速器（temporal destabilizer）：可以在一定范围内增加所有机器人的行动冷却时间</li>
      <li>加速器（temporal booster）：可以在一定范围内减少盟友机器人的行动冷却时间</li>
      <li>信号增幅器（amplifier）：用来传递信息，可以移动</li>
    </ul>
  </li>
  <li>每个格子可能是如下几种之一：
    <ul>
      <li>默认：机器人可以通过，无任何特殊效果</li>
      <li>天空岛（sky island）：机器人可以通过，可以在上方放置锚点将其标记为“占领”，也可以在被对方占领的岛上驻守更多机器人来将其取消标记</li>
      <li>矿井（well）：机器人可以通过，内部包含无限的特定资源，运输器可以在该格及其周边8个格子挖矿</li>
      <li>风（current）：吹向一个固定方向，每回合在风里的机器人会强制向该方向移动一格</li>
      <li>云（cloud）：在云内的机器人不会被其他机器人检测到，但是仍然可以被攻击或者被施加加速/减速效果</li>
      <li>障碍物：机器人不可通过</li>
    </ul>
  </li>
  <li>机器人的可视范围非常有限，但是机器人可以知道自己的x、y坐标以及地图大小</li>
  <li>机器人之间不会自动共享信息，但是可以通过写入/读取<em>共享内存</em>来传递信息
    <ul>
      <li>共享内存为64个16位整数，即一共有128byte</li>
      <li>所有机器人都可以从共享内存中读取信息，但是只有在总部（headquarter）和信号增幅器（amplifier）附近可以写入内存</li>
    </ul>
  </li>
  <li>机器人每回合内不能做过多计算。battlecode中直接使用java的bytecode数量来衡量计算量（可以理解为代码编译成的汇编代码的行数）。如果一个回合的计算超出限制，该机器人的进程会被强制结束，并在下回合内从断点处恢复。</li>
</ul>

<p>可能稍微说的有点多了。当然这还不是全部的规则，更详细的规则可以到<a href="https://releases.battlecode.org/specs/battlecode23/2.0.3/specs.md.html">官方文档</a>中查看。</p>

<h2 id="基本战略">基本战略</h2>

<p>我们最初的想法其实很简单：让每个机器人各司其职</p>

<ol>
  <li>运输器每次随机选取一个矿点，走到矿点附近挖矿，挖完后回到总部。如果看到总部制作了锚点，那么就带上锚点前往天空岛并放置。</li>
  <li>发射器每次随机分配一个地点，在该地点附近移动，如果看到可以攻击的目标就攻击</li>
  <li>信号增幅器在地图上随机移动</li>
</ol>

<p>这个代码看起来并不难实现，但还是有些技术细节需要确认：</p>

<h2 id="共享内存的格式">共享内存的格式</h2>

<p>由于地图的大小不会超过60x60，地图上一个点的坐标只用6位x坐标+6位y坐标=12位二进制即可表示。</p>

<p>最初我们的规划是这样的：每一个16位数存储一个坐标，并且用2个二进制位来标识该坐标上方的特殊区域类型</p>

<pre><code>TTXX XXXX XYYY YYYY
</code></pre>

<p>其中左边是高位，右边是低位。<code>T</code>表示具体信息，<code>X</code>表示x坐标，<code>Y</code>表示y坐标。</p>

<p><code>T</code>的含义取决于该地的类型，比如矿井的<code>T</code>表示里面的矿的类型，天空岛的<code>T</code>表示该天空岛被哪方占领。</p>

<p>后来被改成了这个样子：</p>

<pre><code>CCTT XXXX XXYY YYYY
</code></pre>

<p>将x坐标和y坐标的存储从7二进制位缩减成了6二进制位。前面的<code>C</code>暂时没有分配用途。</p>

<p>而共享内存里总共64个数被分割成了不同的区块</p>
<ol>
  <li>下标0到7：记录每个矿井的坐标</li>
  <li>下标8到11：记录每个我方总部的坐标</li>
  <li>下标12到47：记录每个天空岛的坐标。如果天空岛的大小不止一格，则记录任意一个点的坐标</li>
  <li>下标48到51：记录每个敌方总部的坐标</li>
  <li>下标52到57：记录战场位置（需要着重派兵的位置）</li>
  <li>下标58到62：暂无用途</li>
  <li>下标63：记录共享内存的状态（是否已经初始化等等）</li>
</ol>

<p>每个可移动的机器人不仅有各自的职业，还需要时刻探索地图并将有用的信息记录到共享内存里</p>

<blockquote>
  <p>问题：那如果机器人发现了一个之前没有探到的位置，但距离信号增幅器太远而无法写入共享内存，怎么办？</p>

  <p>答：如果机器人无法写入内存村，那么它可以先将所有探到的位置记录在自己的内存中（每个机器人有不超过5M的本地内存），等走到增幅器附近再写入。</p>
</blockquote>

<blockquote>
  <p>问题：如果关于某个位置的信息过时了怎么办？比如，如果某座岛在第500回合的时候被我方占领，而观察到这个信息的机器人再第700回合才到了增幅器附近，而此时这个岛已经不被我们占领了。</p>

  <p>答：这确实是一个好问题，其实直到比赛最后我们队才意识到信息是有可能过时的。后来我们试图在16位数的<code>C</code>位置记录某个信息的时间戳，但由于<code>C</code>只有2位，只能记录一个非常模糊的时间，并且后来我们没有时间写完代码了，这个计划被迫放弃。</p>
</blockquote>

<h2 id="改进">改进</h2>

<h3 id="战斗">战斗</h3>

<p>最初我们的策略是，给每个发射器随机分配一个任务：</p>
<ol>
  <li>20%概率，在家附近防守</li>
  <li>35%概率，在天空岛附近防守</li>
  <li>35%概率，前往敌方基地，堵住敌方基地的大门</li>
  <li>10%概率，随机移动并探索地图</li>
</ol>

<p>这个策略把我们拉到了排行榜1400分左右，但还是容易轻易地被对手干爆。一大原因是它过于依赖随机性。</p>

<p>后来我们学习了那些和我们对局并在兵力上战胜我们的其他队伍的策略，发现他们的发射器大多都是有组织地行动，一次来很多，而不是一个一个地派过来。<a href="https://ttzytt.com/">TZ</a>受此启发，在发射器的代码中加入了自动检测战场的部分。</p>
<ul>
  <li>如果一个机器人发现周围的敌方机器人数量超过3，则会将它所在的地方标记为战场</li>
  <li>发射器会优先前往战场，再执行自己被分配到的任务</li>
  <li>当总战场的数量超过4，总部就会进入战备状态，将生成发射器的比例调高</li>
</ul>

<h3 id="寻路算法">寻路算法</h3>

<p>在最开始我们用了一个非常朴素的算法：</p>
<ol>
  <li>尝试向目标方向走一格</li>
  <li>如果不能走，则向左（或向右）旋转45°，尝试向该方向走一格。反复执行该操作直到可以走</li>
  <li>如果行动力没有消耗完，则回到1，否则退出</li>
</ol>

<p>这个方法可以越过一段平直的墙，但是无法越过两面90度夹角的墙。</p>

<p>后来我们组的<a href="https://ttzytt.com/">TZ</a>大佬试图使用A*算法来寻路，但是比较不幸地，写挂了。我们也想尝试用Cooperative A*算法，但是因为各个机器人之间共享信息非常不方便，我们组也没有想到比较好的解决方法，这个计划也被搁置了。</p>

<h2 id="遇到的一系列问题">遇到的一系列问题</h2>

<p><em>以下问题按照产生的时间从早到晚排序</em></p>

<blockquote>
  <p>存储矿点坐标的时候只有特定种类的矿会被存下来</p>
</blockquote>

<p>这个问题源于整数的类型转换。</p>

<p>由于battlecode提供的内存相关的API都使用<code>int</code>，而我们的代码里记录内存使用的是<code>short</code>。当我把short的最高位设成1的时候，它就会成为一个负数，而转化成int之后仍然是个负数，它就会因为超出$0$到$2^16-1$的范围而无法被存入共享内存中。</p>

<p>由于Adamantium矿的类型标记是<code>01</code>，而Mana矿的类型标记是<code>10</code>，Mana矿的最高二进制位是1，所以只有Adamantium的坐标被存入了共享内存，而Mana则没有。</p>

<blockquote>
  <p>每次随机出来的数都等于0</p>
</blockquote>

<p>这个代码的问题出在类似这样的一个位置。这行代码本来想生成从0到某个常数的随机数：</p>

<pre><code class="language-java">return (int) rnd.nextFloat() * CONSTANT;
</code></pre>

<p>不知道你们有没有一眼看出问题呢？</p>

<p>这里运算符的计算顺序是这样的：</p>

<div class="mermaid">
graph TD
A([*]) --&gt; B([int])
A --&gt; C[CONSTANT]
B --&gt; D[rnd.nextFloat]
</div>

<p>也就是说，生成的浮点数会先被转化成整数，再进行乘法。而<code>rnd.nextFloat()</code>生成的浮点数永远在$[0, 1)$区间内，所以先转化成整数时就会永远变成0。</p>

<p>修复这个bug可以这样写：</p>

<pre><code class="language-java">return (int) (rnd.nextFloat() * CONSTANT);
</code></pre>

<p>或者因为它生成的随机数是整数，其实更好的方法是使用取模运算：</p>

<pre><code class="language-java">return rnd.nextInt() % CONSTANT;
</code></pre>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="computer" /><summary type="html"><![CDATA[最近几天由于打竞赛打到自闭了（我太菜了），想整点其他的事情做一做，在学校信息社的推荐下打算玩一下MIT办的battlecode比赛。]]></summary></entry><entry><title type="html">浅谈并行计算</title><link href="mqcreaple.github.io/blog/2022/12/27/parallel-computation.html" rel="alternate" type="text/html" title="浅谈并行计算" /><published>2022-12-27T00:00:00-05:00</published><updated>2022-12-27T00:00:00-05:00</updated><id>mqcreaple.github.io/blog/2022/12/27/parallel-computation</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/12/27/parallel-computation.html"><![CDATA[<p>前置知识：多线程</p>

<h2 id="一个简单的例子">一个简单的例子</h2>

<p>问题：给定两个大小均为$N$的整数数组<code>a</code>和<code>b</code>，将两个数组的元素逐个求和并将结果存到数组<code>c</code>中。即：<code>c[i] = a[i] + b[i]</code>。</p>

<p>很容易想到可以使用一个循环来实现这个操作：</p>

<pre><code class="language-cpp">// N: 数组长度
void calcSum(int *a, int *b, int *c, int N) {
    for(int i = 0; i &lt; N; i++) {
        c[i] = a[i] + b[i];
    }
}
</code></pre>

<p>这段代码依次遍历了<code>0</code>到<code>len</code>之间的所有下标，对每个下标对应元素执行一次求和+赋值操作。也就是说，代码的运行时间等于执行$N$次<code>c[i] = a[i] + b[i]</code>所需的时间。</p>

<p>细心的你可能会注意到，对于这个任务，每个下标<code>i</code>所对应的操作都是相互独立的，也就是说，我们其实可以让一堆<code>c[i] = a[i] + b[i]</code>一起运行而且它们之间不会相互干扰。比如这样：</p>

<pre><code class="language-cpp">void calcSum2(int *a, int *b, int *c, int N) {
    int N2 = N / 2;
    std::thread t1(calcSum, a, b, c, N2);      // 创建一个新线程来处理区间[0, N2)
    calcSum(a + N2, b + N2, c + N2, N - N2);   // 在原来的线程里面处理区间[N2, N)
    t1.join();                                 // 同步两个线程，本代码中可以省略但不建议
}
</code></pre>

<p>它将数组从中间分成了两段，然后创建了两个线程来分别计算前半段和后半段。如果你的CPU有至少两个核，那么<code>calcSum2</code>计算同样长的一段数组所需的时间将是<code>calcSum</code>的一半。</p>

<p>当然，你也可以创建更多的线程来进一步加速这段代码，只要不超过硬件的物理限制即可。</p>

<h2 id="并行计算的复杂度">并行计算的复杂度</h2>

<p>如果你拥有一定的算法知识，那么应该对计算机如何执行一段程序不陌生了。而并行计算则相当于有<strong>不止一台计算机在同时计算一个任务</strong>。这几台计算机在执行各自的任务时不能产生冲突，比如同时访问同一块内存。也就是说，你需要<strong>合理地将任务分配</strong>给每一台计算机。</p>

<h3 id="一个简陋的模型">一个简陋的模型</h3>

<p>我们可以先引入一个<em>简化版模型</em>。每个任务的代码可以被看作是由两部分组成：<strong>串行部分</strong>和<strong>并行部分</strong>。任务的并行部分能够被分割成数个相互独立的子任务，而串行部分则必须在单一计算机上执行。</p>

<p><img src="/img/parallel-0.png" alt="parallel" /></p>

<p>假设代码中并行部分占比为$c$，串行部分占比为$(1-c)$，那么如果可以最多并行执行$k$个任务，所花费的时间相比于全部串行的时间就是：</p>

<div class="kdmath">$$
1-c+\frac{c}{k}=1-\frac{k-1}{k}c
$$</div>

<p>而在最理想的情况下，有多到近乎无穷的并行容量时，执行该算法所花费的时间就等于串行部分需要花费的时间，即$(1-c)$。</p>

<p>并行计算不仅减少了计算时间，还有可能降低算法的时间复杂度。完全串行的情况下，时间复杂度等于<em>并行部分的时间复杂度</em>+<em>串行部分的时间复杂度</em>；而在理想并行的情况下，时间复杂度仅为<em>并行部分的时间复杂度</em>。如果随着数据规模$N$的提升，并行部分的时间复杂度提升的没有串行部分快，那么这样做就可以降低时间复杂度了。</p>

<p>在上面<code>calcSum</code>的例子中，所有代码都是串行的，没有并行部分。因此，只要有足够多的线程，那么算法的时间复杂度就可以从之前的$O(N)$降低为$O(1)$常数级别。</p>

<p>当然，这个模型实在是有些过于粗糙了，很多算法都不能被简单拆分成“并行”和“串行”两部分。但是相信你应该大致从中了解并行计算和以前熟知的计算方式的区别了。</p>

<h3 id="分治树模型">分治树模型</h3>

<p>我们考虑一个算法中十分常见的问题：<strong>分治</strong>。分治问题里可以使用一棵树来描述。</p>

<p>举个典型的例子：<strong>归并排序</strong>。以下为归并排序的伪代码：</p>

<pre><code class="language-cpp">void mergeSort(int *a, int left, int right) {
    if(right - left == 1) {
        return;
    }
    mergeSort(left half of array a);
    mergeSort(right half of array a);
    merge the sorted two halves of array a
}
</code></pre>

<p>以下为<code>mergeSort</code>一个长度为7的数组是，函数调用的树形结构：</p>

<div class="mermaid">
graph TD
A[1..7] --&gt; B[1..4]
A --&gt; C[5..7]
B --&gt; D[1..2]
B --&gt; E[3..4]
C --&gt; F[5..6]
C --&gt; G[7..7]
D --&gt; H[1..1]
D --&gt; I[2..2]
E --&gt; J[3..3]
E --&gt; K[4..4]
F --&gt; L[5..5]
F --&gt; M[6..6]
</div>

<p>更一般地，区间分治问题的代码几乎都是下面这个形式的：</p>

<pre><code class="language-cpp">void solve(..., int left, int right) {
    if(right - left == 1) {
        // do something here
        return;
    }
    solve(..., left, mid);
    solve(..., mid, right);
    // main code
}
</code></pre>

<p>根据分治的性质，函数调用树上面，如果两个结点不是祖先关系，那么它们之间一定是相互独立的，可以并行计算；而祖先关系的两个结点之间有数据依赖，必须先执行完子结点代表的函数之后才能执行父节点的函数。</p>

<p>因此，我们获得了并行计算这个分治问题的解法：对这棵树按层从下向上遍历，每一次并行执行一层中的所有结点函数。也就是这样：</p>

<p><img src="/img/parallel-1.png" alt="parallel" /></p>

<p><del>如果您有强迫症，请务必原谅我糟糕的绘画水平</del></p>

<p>按照图中数字标记的顺序，每次将当前层的所有函数并行执行即可。</p>

<p>接下来做复杂度分析。已知合并两个区间的时间复杂度为$O(N)$，其中$N$为待处理区间的长度，那么<em>完全串行</em>时，时间复杂度$T(N)$满足：</p>

<div class="kdmath">$$
T(N)=T(\frac N2)+T(\frac N2)+O(N)
$$</div>

<div class="kdmath">$$
T(1)=0
$$</div>

<p>解得：</p>

<div class="kdmath">$$
T(N)=O(N\log N)
$$</div>

<p>而在使用了上述的并行优化之后，由于左右两个区间的处理是并行的，在计算时间时只用加一遍，因此时间复杂度$T’(N)$满足：</p>

<div class="kdmath">$$
T'(N)=T'(\frac N2)+O(N)
$$</div>

<p>解得：</p>

<div class="kdmath">$$
T'(N)=O(N)
$$</div>

<p>可以看出使用并行计算之后，归并排序的时间复杂度减少了一个$\log N$。类似地，其他区间分治类问题都可以使用相同的方法来降低复杂度。</p>

<p>未完待续<del>先挖上坑以后再填</del></p>

<h2 id="参考资料">参考资料</h2>

<p>Cormen, Thomas, et al. <em>Introduction to Algorithms</em>. MIT press, 2022.</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="computer" /><category term="algorithm" /><summary type="html"><![CDATA[前置知识：多线程]]></summary></entry><entry><title type="html">狭义相对论光线追踪 原理解析 2</title><link href="mqcreaple.github.io/blog/2022/10/17/relativistic-renderer-1.html" rel="alternate" type="text/html" title="狭义相对论光线追踪 原理解析 2" /><published>2022-10-17T00:00:00-04:00</published><updated>2022-10-17T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/10/17/relativistic-renderer-1</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/10/17/relativistic-renderer-1.html"><![CDATA[<p>约定：以下类已经实现</p>

<ul>
  <li><code>Vec3</code>：存储了一个三维向量。
    <ul>
      <li>重载运算符定义了<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>等运算</li>
      <li><code>dot(u, v)</code>点乘</li>
      <li><code>cross(u, v)</code>叉乘</li>
    </ul>
  </li>
  <li><code>LVec4</code>：存储了一个闵氏时空的四维向量。
    <ul>
      <li>重载运算符定义了<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>等运算</li>
      <li><code>dot(u, v)</code>点乘</li>
      <li><code>v.getXYZ()</code>获取四维向量的三维空间分量</li>
    </ul>
  </li>
</ul>

<h2 id="存储一个惯性系">存储一个惯性系</h2>

<p>如何将一个惯性参考系的信息存储下来？</p>

<p>首先，我们可以先选定一个参考系，称为<em>世界参考系</em>。这样其他一切惯性参考系都可以用它们和世界参考系之间的相对速度$\vec u$来表示了。</p>

<p>但是注意，只记录一个速度向量$\vec u$是不够的，因为惯性系之间不只有相对速度，还有可能有平移、旋转之类的相对变换。</p>

<p>这里我们只考虑相对速度$\vec u$和平移$\mathbf p$这两个因素，暂时不考虑旋转<del>，主要是因为我懒得推旋转参考系的公式</del>。也就是这样的一个类：</p>

<pre><code class="language-cpp">class Transformation {
public:
    Transformation(const Vec3 &amp;velocity, const LVec4 origin);
private:
    Vec3 velocity;
    LVec4 origin;
    // Vec3为三维向量，LVec4为闵氏时空中的四维向量
};
</code></pre>

<p>我们定义平移向量$\mathbf p$为<strong>当前参考系的原点（即$(0, 0, 0, 0)$点）点在世界参考系中的测量结果</strong>。注意：世界参考系的原点在当前参考系的测量结果不一定是$-\mathbf p$，可以想一下原因。</p>

<p>显然，世界参考系就是平移$\mathbf p$和速度$\vec u$都为零向量的参考系。</p>

<p>参考系类还需要实现这两个方法，用来做事件的参考系变换：</p>

<pre><code class="language-cpp">class Transformation {
public:
    // ...
    LVec4 toLocal(const LVec4 &amp;world) const;
    LVec4 toWorld(const LVec4 &amp;local) const;
private:
    // ...
};
</code></pre>

<p>具体的公式可以参考<a href="/blog/2022/10/14/relativistic-renderer-0.html">上一篇博客</a>。</p>

<h2 id="存储一条光线">存储一条光线</h2>

<p>“光线”是一种用来描述光传播的抽象模型，它在狭义相对论中同样适用。</p>

<p>一束光在时空图中就是一条斜率为光速的射线：</p>

<p><img src="/img/ray-spacetime-diagram-wikipedia.svg" alt="spacetime-diagram" /></p>

<p><em>图源：<a href="https://en.wikipedia.org/wiki/Spacetime_diagram">Wikipedia</a></em></p>

<p>为了唯一确定一条这样的射线，我们需要光的<strong>光源$\mathbf r$</strong>和光线<strong>方向$\vec d$</strong>。其中$\vec d$一定是一个单位向量。</p>

<p>现在的<code>Ray</code>类是这样的：</p>

<pre><code class="language-cpp">class Ray {
public:
    Ray(const LVec4 &amp;origin, const Vec3 &amp;direction);
private:
    LVec4 origin;
    Vec3 direction;
};
</code></pre>

<p>我们定义一个函数<code>atDistance</code>，表示在世界参考系看来，到光源的空间距离为$l$的事件。就是这样的：</p>

<pre><code class="language-cpp">LVec4 atDistance(float dist) const {
    return LVec4(origin.t + dist, origin.getXYZ() + dist * direction);
}
</code></pre>

<p>在走了一段距离之后，世界参考系下坐标的时间和空间都会增加。</p>

<p><img src="/img/ray-spacetime-diagram-0.png" alt="spacetime-diagram" /></p>

<p><del>众所周知geogebra啥都能画</del></p>

<p>接下来，<code>Transformation</code>类里还要加上这两个函数，用来对光线进行参考系变换：</p>

<pre><code class="language-cpp">class Transformation {
public:
    // ...
    Ray toLocal(const Ray &amp;ray) const;
    Ray toWorld(const Ray &amp;ray) const;
private:
    // ...
};
</code></pre>

<p>光线的参考系变换也很简单，只需要对光源$\mathbf r$做事件的参考系变换，方向$\vec d$做速度的参考系变换即可。</p>

<h2 id="物体">物体</h2>

<p>定义这样的一个抽象类，来表示所有的物体：</p>

<pre><code class="language-cpp">class VisibleObject {
public:
    VisibleObject(const Transformation &amp;tr);

    struct IntersectResult {
        LVec4 intersection;
        float distance;
    };
    virtual std::optional&lt;IntersectResult&gt; intersect(const Ray &amp;ray) const = 0;

private:
    Transformation transformation;
};
</code></pre>

<p><code>VisibleObject</code>类中使用<code>transformation</code>记录了一个匀速运动的物体所在的参考系。</p>

<p><code>intersect</code>函数是这个类的核心。它的任务是计算一条<strong>物体参考系里的光线</strong>和该物体的<strong>交点</strong>。返回值<code>std::optional&lt;IntersectResult&gt;</code>在有交点的时候返回该交点的信息（包括交点的时空坐标，以及交点到光源的空间距离）；如果没有交点，那么返回一个空引用。</p>

<blockquote>
  <p><code>std::optional</code>是C++17的新特性，可以用来表示一个“有值或者没有值”的对象。更多信息可以看<a href="https://en.cppreference.com/w/cpp/utility/optional">cppreference</a>。</p>
</blockquote>

<p>另一个值得注意的点是：由于光线追踪的过程是<strong>回溯</strong>光的路径，所以每次求出的交点应该在光路的<strong>反方向</strong>上，<code>distance</code>值应当为负数。</p>

<p><img src="/img/forward-ray-tracing-0.jpg" alt="forward-tracing" /></p>

<blockquote>
  <p>实际上由于光路可逆原则，将光线的方向全部反向之后，每次求光路正方向上的交点，理论上也是可行的。</p>

  <p><strong>但是</strong>，如果你真的打算这么写，那么就要尤其注意光线的参考系变换。因为这样的话，<code>Ray</code>类里记录的方向向量$\vec d$和光的速度向量<strong>是相反的</strong>，光线的<code>toLocal</code>和<code>toWorld</code>里对应项也需要变符号。</p>

  <p><del>之前被这个bug困扰了一个晚上，在这里写下来以警示后人</del></p>
</blockquote>

<h3 id="球体">球体</h3>

<p>为了展示<code>intersection</code>函数，这里举一个简单的例子：球体。不妨假设球体的球心在原点$(0, 0, 0)$</p>

<p>假设有一个在<strong>物体参考系</strong>里的光线<code>ray</code>（不是世界参考系，所以不用考虑参考系变换）。光线从原点$\vec r$出发，向前走了距离$l$，走到的坐标是：</p>

<div class="kdmath">$$
\vec r_1=\vec r + l\vec d
$$</div>

<p>如果$\vec r_1$是光线和球的交点，那么$\vec r_1$到球心（即原点）的距离一定等于球的半径，即：</p>

<div class="kdmath">$$
||\vec r_1||=||\vec r + l\vec d||=R
$$</div>

<p><img src="/img/ray-sphere-intersection-0.png" alt="ray-sphere-intersection" /></p>

<p>将向量模长写成向量点乘自己，也就是：</p>

<div class="kdmath">$$
(\vec r + l\vec d)\cdot(\vec r + l\vec d)=R^2
$$</div>

<p>展开这个式子：</p>

<div class="kdmath">$$
(\vec r + l\vec d)\cdot(\vec r+l\vec d) = \vec r\cdot\vec r + 2l\vec r\cdot\vec d + l^2\vec d\cdot\vec d = R^2
$$</div>

<div class="kdmath">$$
\vec d^2l^2+2(\vec r\cdot\vec d)l+(\vec r^2-R^2)=0
$$</div>

<p>由于$\vec d$是单位向量，$\vec d^2=1$，代入原式得到：</p>

<div class="kdmath">$$
l^2+2(\vec r\cdot\vec d)l+(\vec r^2-R^2)=0
$$</div>

<p>我们得到了一个关于$l$的一元二次方程，它的每个根就代表了光线和球的一个交点到光源的距离（这个距离可能是负数，此时表示交点在光线的反方向，而这正是我们想要的）。只需要解出这个方程，然后再判断两个根$l_1, l_2$是否是负数，以及它们之间的大小关系，即可找到光线和球的最近交点。</p>

<p>得到光源到交点的空间距离$l$之后，再做一次<code>ray.atDistance(l)</code>即可得到交点的具体坐标。</p>

<p>代码：</p>

<pre><code class="language-cpp">std::optional&lt;IntersectionResult&gt; SphereObject::intersect(const Ray &amp;ray) const {
    Vec3 r0 = ray.getOrigin().getXYZ();  // 光源的空间坐标
    float b = 2 * dot(r0, ray.getDirection());
    float c = dot(r0, r0) - radius * radius;
    float delta = b * b - 4 * c;         // 二次方程判别式
    
    float l = (-b + sqrt(delta)) / 2;    // 优先考虑较大的根
    if(l &gt; 0) {
        // 如果较大的根超出范围，那么考虑另一个根
        l = (-b - sqrt(delta)) / 2;
    }
    if(l &gt; 0) {
        return std::nullopt;             // 返回一个空引用
    }
    return IntersectionResult(ray.atDistance(l), l);  // 返回答案
}
</code></pre>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="physics" /><category term="special-relativity" /><category term="computer-graphics" /><summary type="html"><![CDATA[约定：以下类已经实现]]></summary></entry><entry><title type="html">狭义相对论光线追踪 原理解析 1</title><link href="mqcreaple.github.io/blog/2022/10/14/relativistic-renderer-0.html" rel="alternate" type="text/html" title="狭义相对论光线追踪 原理解析 1" /><published>2022-10-14T00:00:00-04:00</published><updated>2022-10-14T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/10/14/relativistic-renderer-0</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/10/14/relativistic-renderer-0.html"><![CDATA[<p>前置知识：狭义相对论。</p>

<p>先温习一遍课本里的洛伦兹变换(Lorentz transformation)：如果参考系$S’$相对于$S$的速度为$u$，沿着$x$轴正方向，那么事件$(t, x, y, z)$在$S’$参考系中测量的结果是：</p>

<div class="kdmath">$$
\begin{cases}
t'=\gamma(t-\frac{u}{c^2}x) \\
x'=\gamma(x-ut) \\
y'=y \\
z'=z
\end{cases}
$$</div>

<p>其中$c$为光速，并且</p>

<div class="kdmath">$$
\gamma=\frac{1}{\sqrt{1-\frac{u^2}{c^2}}}
$$</div>

<h2 id="四维矢量和闵可夫斯基空间">四维矢量和闵可夫斯基空间</h2>

<p>洛伦兹变换有一大性质：如果两个事件$\mathbf r_1$和$\mathbf r_2$，那么不论在哪个惯性参考系中看，这个物理量：</p>

<div class="kdmath">$$
s^2=-(c\Delta t)^2+\Delta x^2+\Delta y^2+\Delta z^2
$$</div>

<p>是永远不变的。$s$被称为<strong>闵可夫斯基度规(Minkowski metric)</strong>，或者<strong>闵氏度规</strong>。</p>

<p>这启发了我们，可以定义一个四维矢量来表示事件。为了保证单位一致，第一维是光速乘上时间，后三维是空间。像这样：</p>

<div class="kdmath">$$
\mathbf r=(ct, x, y, z)=(ct, \vec{r})
$$</div>

<p><em>（为了方便区分，本文中所有四维向量均用粗体表示，三维向量均用箭头表示）</em></p>

<p>然后向量的模长公式不再是平方求和后再相加，而是：</p>

<div class="kdmath">$$
||\mathbf r||=\sqrt{-(ct)^2+x^2+y^2+z^2}
$$</div>

<p>把时间平方项的正号改成负号。这样的话，两个事件$\mathbf r_1$和$\mathbf r_2$之间的<strong>距离</strong>（或者说：闵氏度规）就是：</p>

<div class="kdmath">$$
s=||\mathbf r_2-\mathbf r_1||
$$</div>

<p>你可能会觉得为了凑出$-t^2$而强行修改向量模长定义的行为很无耻。但是，它其实是是一种和我们熟悉的空间（即：欧几里得空间/欧氏空间）完全不同的<strong>几何</strong>规则，也就是<strong>闵可夫斯基几何</strong>/<strong>闵氏几何</strong>。毕竟，没有规定说我们的宇宙一定遵守欧氏几何这种符合人类直觉的规律。</p>

<p>所有满足这个奇怪的模长公式的向量构成了一个向量空间，即<strong>闵可夫斯基空间</strong>，或者也可以叫<strong>闵可夫斯基时空</strong>。在闵氏空间里，向量的第一维和后三维的地位并不相同。</p>

<p>闵氏空间里，向量点乘（内积）的定义也被修改了：向量$\mathbf u$和$\mathbf v$的点乘是：</p>

<div class="kdmath">$$
\mathbf u\cdot\mathbf v=-u_tv_t+u_xv_x+u_yv_y+u_zv_z
$$</div>

<p>而洛伦兹变换就是一个4×4的矩阵：</p>

<div class="kdmath">$$
\Lambda=\begin{bmatrix}
\gamma & -\frac{u}{c}\gamma & 0 & 0 \\
-\frac{u}{c}\gamma & \gamma & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$</div>

<p>将事件在$S$系中的测量结果$\mathbf r$转到$S’$系测量，就相当于用矩阵$\Lambda$乘上$\mathbf r$：</p>

<div class="kdmath">$$
\mathbf r'=\Lambda\mathbf r
$$</div>

<h2 id="任意方向的洛伦兹变换">任意方向的洛伦兹变换</h2>

<p>刚刚的讨论里，相对速度$u$都是沿着$x$轴正方向的。但是如果$u$不是呢？</p>

<p>可以这样想：把一个事件$\mathbf r$的空间分量$\vec r$分解成平行于速度分量$\vec r_\parallel$和垂直于速度的分量$\vec r_\perp$。</p>

<div class="kdmath">$$
\vec r_\parallel=(\vec r\cdot \vec n)\vec n=\left(\vec r\cdot\frac{\vec u}{||\vec u||}\right)\frac{\vec u}{||\vec u||}
$$</div>

<div class="kdmath">$$
\vec r_\perp=\vec r-\vec r_\parallel
$$</div>

<p>其中$\vec n=\frac{\vec u}{\mid\mid\vec u\mid\mid}$，是速度$\vec u$方向上的单位向量。</p>

<p>经过变换之后，垂直于速度的$\vec r_\perp$分量不变，而$\vec r_\parallel$会变成$\gamma(\vec r_\parallel-\vec ut)$。</p>

<div class="kdmath">$$
\begin{align*}
\vec r' &=\vec r_\perp+\gamma(\vec r_\parallel-\vec ut) \\
&= (\vec r-(\vec r\cdot\vec n)\vec n) + \gamma((\vec r\cdot \vec n)\vec n-\vec ut) \\
&= \vec r + (\gamma-1)(\vec r\cdot\vec n)\vec n-\gamma\vec ut
\end{align*}
$$</div>

<p>而时间变换则简单一些：</p>

<div class="kdmath">$$
\begin{align*}
t'&=\gamma(t-\frac{u}{c^2}r_\parallel) \\
&= \gamma(t-\frac{\vec u}{c^2}\cdot \vec r)
\end{align*}
$$</div>

<p>将上面的变换公式写成矩阵，就是：</p>

<div class="kdmath">$$
\begin{bmatrix}ct'\\x'\\y'\\z'\end{bmatrix}=
\begin{bmatrix}
\gamma & -\gamma\frac{u_x}{c} & -\gamma\frac{u_y}{c} & -\gamma\frac{u_z}{c} \\
-\gamma\frac{u_x}{c} & 1+(\gamma-1)n_x^2 & (\gamma-1)n_xn_y & (\gamma-1)n_xn_z \\
-\gamma\frac{u_y}{c} & (\gamma-1)n_yn_x & 1+(\gamma-1)n_y^2 & (\gamma-1)n_yn_z \\
-\gamma\frac{u_z}{c} & (\gamma-1)n_zn_x & (\gamma-1)n_zn_y & 1+(\gamma-1)n_z^2
\end{bmatrix}
\begin{bmatrix}ct\\x\\y\\z\end{bmatrix}
$$</div>

<p>也就是说，速度$\vec u$方向任意的洛伦兹变换矩阵就是：</p>

<div class="kdmath">$$
\Lambda(\vec u)=\begin{bmatrix}
\gamma & -\gamma\frac{u_x}{c} & -\gamma\frac{u_y}{c} & -\gamma\frac{u_z}{c} \\
-\gamma\frac{u_x}{c} & 1+(\gamma-1)n_x^2 & (\gamma-1)n_xn_y & (\gamma-1)n_xn_z \\
-\gamma\frac{u_y}{c} & (\gamma-1)n_yn_x & 1+(\gamma-1)n_y^2 & (\gamma-1)n_yn_z \\
-\gamma\frac{u_z}{c} & (\gamma-1)n_zn_x & (\gamma-1)n_zn_y & 1+(\gamma-1)n_z^2
\end{bmatrix}
$$</div>

<p>其中</p>

<div class="kdmath">$$
\gamma=\frac{1}{\sqrt{1-\frac{||\vec u||^2}{c^2}}}
$$</div>

<p>可以检验，当$\vec u$的大小为$u$而方向指向$x$轴正半轴时，$\Lambda(\vec u)$和之前给出的矩阵相等。</p>

<h2 id="速度变换">速度变换</h2>

<p>任何一个物体的运动都可以表示成闵氏时空中的一条曲线。在$S$系中，物体的速度是：</p>

<div class="kdmath">$$
\vec v=\frac{\mathrm d\vec r}{\mathrm dt}
$$</div>

<p>而$S’$系中，同一个物体的速度是：</p>

<div class="kdmath">$$
\vec v'=\frac{\mathrm d\vec r'}{\mathrm dt'}
$$</div>

<p>我们的目的就是将$\vec v’$表示成$\vec v$，$\vec u$，以及其他$S$系中可测量的物理量。为了用$\vec v$表示$\vec v’$，可以先用一个链式法则：</p>

<div class="kdmath">$$
\begin{align*}
\vec v' &= \frac{\mathrm d\vec r'}{\mathrm dt'} \\
&= \frac{\partial\vec r'}{\partial t}\frac{\mathrm dt}{\mathrm dt'}+\frac{\partial\vec r'}{\partial x}\frac{\mathrm dx}{\mathrm dt'}+\frac{\partial\vec r'}{\partial y}\frac{\mathrm dy}{\mathrm dt}+\frac{\partial\vec r'}{\partial z}\frac{\mathrm dz}{\mathrm dt} \\
&= \sum_{i=1}^4\frac{\partial\vec r'}{\partial\mathbf r_i}\frac{\mathrm d\mathbf r_i}{\mathbf dt'}
\end{align*}
$$</div>

<p>其中$\mathbf r_i$为$\mathbf r$的第$i$个分量。偏导数$\frac{\partial\vec r’}{\partial\mathbf r_i}$很好求，接下来只需要求出全导数$\frac{\mathrm d\mathbf r_i}{\mathrm dt’}$即可。</p>

<p>这里我们还可以用一个链式法则：</p>

<div class="kdmath">$$
\begin{align*}
\frac{\mathrm d\mathbf r_i}{\mathrm dt'} &= \left(\frac{\mathrm dt'}{\mathrm d\mathbf r_i}\right)^{-1} \\
&= \left(\sum_{j=1}^4\frac{\partial t'}{\partial\mathbf r_j}\frac{\mathrm d\mathbf r_j}{\mathrm d\mathbf r_i}\right)^{-1}
\end{align*}
$$</div>

<p>不难想到，</p>

<div class="kdmath">$$
\frac{\mathrm dx}{\mathrm dt}=v_x,\ \frac{\mathrm dy}{\mathrm dt}=v_y,\ \frac{\mathrm dz}{\mathrm dt}=v_z
$$</div>

<div class="kdmath">$$
\frac{\mathrm dx}{\mathrm dy}=\frac{v_x}{v_y},\ \frac{\mathrm dy}{\mathrm dz}=\frac{v_y}{v_z},\ \frac{\mathrm dz}{\mathrm dx}=\frac{v_z}{v_x}
$$</div>

<p>也就是说，任何形如$\frac{\mathrm d\mathbf r_j}{\mathrm d\mathbf r_i}$的表达式，都可以表示成速度分量的比值。然后把这些东西再带回原式，就可以算出来了。</p>

<p>由于过程太长，我就不全打出来了。以下是答案：</p>

<div class="kdmath">$$
\vec v'=\frac{1}{1-\frac{\vec u\cdot\vec v}{c^2}}\left(\frac{\vec v}{\gamma}-\vec u+\frac 1{c^2}\frac{\gamma}{\gamma+1}(\vec u\cdot\vec v)\vec u\right)
$$</div>

<p>遗憾的是，速度变换并不是线性变换，所以没办法写成矩阵形式。</p>

<h2 id="光相差relativistic-abberation">光相差（Relativistic Abberation）</h2>

<p>我们可以把光线当成是运动速度为光速的物体，那么同样可以对其进行速度变换。</p>

<p>代入前面的速度变换公式，不难检验，若在$S$系中速度$v$大小为光速，那么经过速度变换之后，$S’$系中$v’$也是光速。这又被称为：<strong>光速不变原则</strong>，光速运动的物体无论在哪个参考系中都是光速运动的。</p>

<p>但是需要注意，在两个参考系中，光的方向会发生变化。</p>

<p>如果在静止的参考系里，从一个点在各个方向上均匀发出光线：</p>

<p><img src="/img/rel-plot-1.png" alt="" /></p>

<p>那么在一个朝右运动的参考系里，光线的方向不再均匀，而是向运动的反方向聚集：</p>

<p><img src="/img/rel-plot-2.png" alt="" /></p>

<p>类似地，在一个接收光线的观察者看来，如果它在以接近光速运动，会有更多光线朝着它面前打过来，而它背后的光线就会减弱。</p>

<p>这个光线角度在运动参考系中发生偏转的现象就被称为：狭义相对论光相差。</p>

<blockquote>
  <p>鉴于本文作者比较菜，如果您在阅读时发现了任何错误，欢迎在<a href="/">主页</a>评论区指出！</p>
</blockquote>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="physics" /><category term="special-relativity" /><category term="computer-graphics" /><summary type="html"><![CDATA[前置知识：狭义相对论。]]></summary></entry><entry><title type="html">封装一棵线段树</title><link href="mqcreaple.github.io/blog/2022/10/02/segment-tree-class.html" rel="alternate" type="text/html" title="封装一棵线段树" /><published>2022-10-02T00:00:00-04:00</published><updated>2022-10-02T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/10/02/segment-tree-class</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/10/02/segment-tree-class.html"><![CDATA[<p>最近得了个“小感冒”，实在懒得去做题，然后就在其他人的博客里瞎逛。无意间发现了zxp大佬之前写过的<a href="https://zxp2019.github.io/blog/article/segment-tree-class/"><em>封装一棵线段树</em></a>，然后就想把这里的代码稍微改得更像C++标准库一点。</p>

<h2 id="基本结构">基本结构</h2>

<p>首先肯定是不能用数组来写线段树了，而应当用一个更高级的工具：<strong>指针</strong>。</p>

<p>我们在线段树结点的struct里放这些东西：</p>

<pre><code class="language-cpp">struct Node {
    int leftBound;  // inclusive
    int rightBound; // exclusive
    Node *leftChild;
    Node *rightChild;
    T sum;
    T lazy;
    Node(int leftBound, int rightBound)
        : leftBound(leftBound), rightBound(rightBound), leftChild(nullptr), rightChild(nullptr), sum(0), lazy(0) {}
};
</code></pre>

<p><em>（为了对应大部分C++标准库的规则，这里的左边界是包含的，而右边界则不包含，相当于这个结点覆盖的是区间上<code>[left, right)</code>的部分）</em></p>

<p>然后在每个线段树类里面记录一下线段树的根结点<code>root</code>即可：</p>

<pre><code class="language-cpp">class QuickArray {
public:
private:
    struct Node {
        // Omitted
    };
    Node *root;
};
</code></pre>

<p>然后就是其他操作了：</p>

<h2 id="线段树的操作">线段树的操作</h2>

<h3 id="创建线段树">创建线段树</h3>

<p>这里我直接把它放在了线段树类<code>QuickArray</code>的构造函数里。代码是这样的：</p>

<pre><code class="language-cpp">class QuickArray {
public:
    QuickArray(int left, int right): root(buildTree(left, right)) {}
};
</code></pre>

<p>而这里的<code>buildTree</code>是一个私有的辅助函数，专门用来构造线段树：</p>

<pre><code class="language-cpp">private:
    static Node *buildTree(int left, int right) {
        Node *cur = new Node(left, right);        // create a new node in memory
        if(right - left &lt;= 1) {
            return cur;                           // current node is leaf, directly return from function
        }
        int mid = (left + right) / 2;
        cur-&gt;leftChild = buildTree(left, mid);    // build left tree
        cur-&gt;rightChild = buildTree(mid, right);  // build right tree
        return cur;
    }
</code></pre>

<h3 id="更新区间">更新区间</h3>

<p>更新区间的操作就是线段树板子了，直接贴上去就好：</p>

<pre><code class="language-cpp">public:
    void add(int left, int right, T value) {
        if(left &lt; right) {
            // to prevent illegal update
            nodeAdd(root, left, right, value);
        }
    }
private:
    static void nodeAdd(Node *n, IndexT left, IndexT right, T value) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return;
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            n-&gt;lazy += value;
            pushDown(n);
            return;
        }
        nodeAdd(n-&gt;leftChild, left, right, value);
        nodeAdd(n-&gt;rightChild, left, right, value);
        n-&gt;sum = n-&gt;leftChild-&gt;sum + n-&gt;rightChild-&gt;sum;
    }
</code></pre>

<h3 id="区间查询">区间查询</h3>

<p>还是板子。先写一个<code>pushDown</code>：</p>

<pre><code class="language-cpp">private:
    static void pushDown(Node *n) {
        if(n-&gt;leftChild != nullptr &amp;&amp; n-&gt;rightChild != nullptr) {
            n-&gt;leftChild-&gt;lazy += n-&gt;lazy;
            n-&gt;rightChild-&gt;lazy += n-&gt;lazy;
            n-&gt;sum += n-&gt;lazy * (n-&gt;rightBound - n-&gt;leftBound);
        } else {
            n-&gt;sum += n-&gt;lazy;
        }
        n-&gt;lazy = 0;
    }
</code></pre>

<p>然后就是区间查询的代码：</p>

<pre><code class="language-cpp">public:
    T sum(int left, int right) const {
        if(left &lt; right) {
            return nodeSum(root, left, right);
        }
        throw "Invalid query!";
    }
private:
    static T nodeSum(Node *n, IndexT left, IndexT right) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return T(0);
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            return n-&gt;sum;
        }
        return nodeSum(n-&gt;leftChild, left, right) + nodeSum(n-&gt;rightChild, left, right);
    }
</code></pre>

<h3 id="其他">其他</h3>

<p>再加一些可能用得上的函数，比如查询区间的左端和右端：</p>

<pre><code class="language-cpp">public:
    int leftBound() const {
        return root-&gt;leftBound;
    }
    int rightBound() const {
        return root-&gt;rightBound;
    }
</code></pre>

<p>完成！</p>

<h2 id="第一版代码">第一版代码</h2>

<pre><code class="language-cpp">#pragma once

template&lt;typename T&gt;
class QuickArray {
public:
    typedef int IndexT;
    /**
     * @brief Construct a QuickArray from left and right bound
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     */
    QuickArray(IndexT left, IndexT right): root(buildTree(left, right)) {}

    /**
     * @brief Construct a new QuickArray from a given array
     * @param array array with initial elements
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     */
    QuickArray(T *array, IndexT left, IndexT right): root(buildTree(array, left, right)) {}

    /**
     * @brief Add a given number to every term in range [left, right)
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     * @param amount amount to add
     */
    void add(IndexT left, IndexT right, T value) {
        if(left &lt; right) {
            nodeAdd(root, left, right, value);
        }
    }

    /**
     * @brief Find the sum of all terms in range [left, right)
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     * @return T sum
     */
    T sum(IndexT left, IndexT right) const {
        if(left &lt; right) {
            return nodeSum(root, left, right);
        }
        throw "Invalid query!";
    }

    /**
     * @brief Get the array's left bound
     * @return IndexT left bound (inclusive)
     */
    IndexT leftBound() const {
        return root-&gt;leftBound;
    }

    /**
     * @brief Get the array's right bound
     * @return IndexT right bound (exclusive)
     */
    IndexT rightBound() const {
        return root-&gt;rightBound;
    }

    ~QuickArray() {
        removeNodes(root);
    }
private:
    struct Node {
        IndexT leftBound;  // inclusive
        IndexT rightBound; // exclusive
        Node *leftChild;
        Node *rightChild;
        T sum;
        T lazy;
        Node(int leftBound, int rightBound)
            : leftBound(leftBound), rightBound(rightBound), leftChild(nullptr), rightChild(nullptr), sum(0), lazy(0) {}
    };
    Node *root;

    static Node *buildTree(IndexT left, IndexT right) {
        Node *cur = new Node(left, right);        // create a new node in memory
        if(right - left &lt;= 1) {
            return cur;                           // current node is leaf, directly return from function
        }
        IndexT mid = (left + right) / 2;
        cur-&gt;leftChild = buildTree(left, mid);    // build left tree
        cur-&gt;rightChild = buildTree(mid, right);  // build right tree
        return cur;
    }

    static Node *buildTree(T *array, IndexT left, IndexT right) {
        Node *cur = new Node(left, right);
        if(right - left &lt;= 1) {
            cur-&gt;sum = array[left];
            return cur;
        }
        IndexT mid = (left + right) / 2;
        cur-&gt;leftChild = buildTree(array, left, mid);
        cur-&gt;rightChild = buildTree(array, mid, right);
        cur-&gt;sum = cur-&gt;leftChild-&gt;sum + cur-&gt;rightChild-&gt;sum;
        return cur;
    }

    static void pushDown(Node *n) {
        if(n-&gt;leftChild != nullptr &amp;&amp; n-&gt;rightChild != nullptr) {
            n-&gt;leftChild-&gt;lazy += n-&gt;lazy;
            n-&gt;rightChild-&gt;lazy += n-&gt;lazy;
            n-&gt;sum += n-&gt;lazy * (n-&gt;rightBound - n-&gt;leftBound);
        } else {
            n-&gt;sum += n-&gt;lazy;
        }
        n-&gt;lazy = 0;
    }

    static void nodeAdd(Node *n, IndexT left, IndexT right, T value) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return;
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            n-&gt;lazy += value;
            pushDown(n);
            return;
        }
        nodeAdd(n-&gt;leftChild, left, right, value);
        nodeAdd(n-&gt;rightChild, left, right, value);
        n-&gt;sum = n-&gt;leftChild-&gt;sum + n-&gt;rightChild-&gt;sum;
    }

    static T nodeSum(Node *n, IndexT left, IndexT right) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return T(0);
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            return n-&gt;sum;
        }
        return nodeSum(n-&gt;leftChild, left, right) + nodeSum(n-&gt;rightChild, left, right);
    }

    static void removeNodes(Node *n) {
        if(n == nullptr) {
            return;
        }
        removeNodes(n-&gt;leftChild);
        removeNodes(n-&gt;rightChild);
        delete n;
    }
};
</code></pre>

<h2 id="改进">改进</h2>

<p>我们用C++新特性：智能指针，来代替上文中的<code>Node*</code>。这增加了程序的安全性。</p>

<p>由于我们不需要复制结点指针，所有指针一律改成<code>unique_ptr</code>即可：</p>

<blockquote>
  <p><code>unique_ptr</code>是一个类，用来模拟一个指针。</p>

  <p>如果<code>unique_ptr</code>指向一个堆中的对象，那么当它的作用域结束之后，<code>unique_ptr</code>的析构函数会自动释放该对象的内存，不用手动<code>delete</code>。</p>

  <p><code>unique_ptr</code>不允许复制，这样保证了不会有两个指针指向同一块内存而导致将该内存释放多次。</p>
</blockquote>

<p>（如果你学过Rust，可能会对<code>unique_ptr</code>感到很熟悉）</p>

<p>以下为改成<code>unique_ptr</code>的代码：</p>

<pre><code class="language-cpp">#pragma once

#include &lt;memory&gt;
using std::unique_ptr;

template&lt;typename T&gt;
class QuickArray {
public:
    typedef int IndexT;
    /**
     * @brief Construct a QuickArray from left and right bound
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     */
    QuickArray(IndexT left, IndexT right) {
        buildTree(root, left, right);
    }

    /**
     * @brief Construct a new QuickArray from a given array
     * @param array array with initial elements
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     */
    QuickArray(T *array, IndexT left, IndexT right) {
        buildTree(root, array, left, right);
    }

    /**
     * @brief Add a given number to every term in range [left, right)
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     * @param amount amount to add
     */
    void add(IndexT left, IndexT right, T value) {
        if(left &lt; right) {
            nodeAdd(root, left, right, value);
        }
    }

    /**
     * @brief Find the sum of all terms in range [left, right)
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     * @return T sum
     */
    T sum(IndexT left, IndexT right) const {
        if(left &lt; right) {
            return nodeSum(root, left, right);
        }
        throw "Invalid query!";
    }

    /**
     * @brief Get the array's left bound
     * @return IndexT left bound (inclusive)
     */
    IndexT leftBound() const {
        return root-&gt;leftBound;
    }

    /**
     * @brief Get the array's right bound
     * @return IndexT right bound (exclusive)
     */
    IndexT rightBound() const {
        return root-&gt;rightBound;
    }
private:
    struct Node {
        IndexT leftBound;  // inclusive
        IndexT rightBound; // exclusive
        unique_ptr&lt;Node&gt; leftChild;
        unique_ptr&lt;Node&gt; rightChild;
        T sum;
        T lazy;
        Node(int leftBound, int rightBound)
            : leftBound(leftBound), rightBound(rightBound), leftChild(), rightChild(), sum(0), lazy(0) {}
    };
    unique_ptr&lt;Node&gt; root;

    static void buildTree(unique_ptr&lt;Node&gt; &amp;cur, IndexT left, IndexT right) {
        cur = std::make_unique&lt;Node&gt;(left, right);  // equivalent to `cur = new Node(left, right)` in C pointer
        if(right - left &lt;= 1) {
            return;
        }
        IndexT mid = (left + right) / 2;
        buildTree(cur-&gt;leftChild, left, mid);
        buildTree(cur-&gt;rightChild, mid, right);
    }

    static void buildTree(unique_ptr&lt;Node&gt; &amp;cur, T *array, IndexT left, IndexT right) {
        cur = std::make_unique&lt;Node&gt;(left, right);
        if(right - left &lt;= 1) {
            cur-&gt;sum = array[left];
            return;
        }
        IndexT mid = (left + right) / 2;
        buildTree(cur-&gt;leftChild, array, left, mid);
        buildTree(cur-&gt;rightChild, array, mid, right);
        cur-&gt;sum = cur-&gt;leftChild-&gt;sum + cur-&gt;rightChild-&gt;sum;
    }

    static void pushDown(const unique_ptr&lt;Node&gt; &amp;n) {
        if(n-&gt;leftChild != nullptr &amp;&amp; n-&gt;rightChild != nullptr) {
            n-&gt;leftChild-&gt;lazy += n-&gt;lazy;
            n-&gt;rightChild-&gt;lazy += n-&gt;lazy;
            n-&gt;sum += n-&gt;lazy * (n-&gt;rightBound - n-&gt;leftBound);
        } else {
            n-&gt;sum += n-&gt;lazy;
        }
        n-&gt;lazy = 0;
    }

    static void nodeAdd(const unique_ptr&lt;Node&gt; &amp;n, IndexT left, IndexT right, T value) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return;
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            n-&gt;lazy += value;
            pushDown(n);
            return;
        }
        nodeAdd(n-&gt;leftChild, left, right, value);
        nodeAdd(n-&gt;rightChild, left, right, value);
        n-&gt;sum = n-&gt;leftChild-&gt;sum + n-&gt;rightChild-&gt;sum;
    }

    static T nodeSum(const unique_ptr&lt;Node&gt; &amp;n, IndexT left, IndexT right) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return T(0);
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            return n-&gt;sum;
        }
        return nodeSum(n-&gt;leftChild, left, right) + nodeSum(n-&gt;rightChild, left, right);
    }
};
</code></pre>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="algorithm" /><summary type="html"><![CDATA[最近得了个“小感冒”，实在懒得去做题，然后就在其他人的博客里瞎逛。无意间发现了zxp大佬之前写过的封装一棵线段树，然后就想把这里的代码稍微改得更像C++标准库一点。]]></summary></entry><entry><title type="html">【整活】所有算法都是O(1)的</title><link href="mqcreaple.github.io/blog/2022/09/06/time-compl.html" rel="alternate" type="text/html" title="【整活】所有算法都是O(1)的" /><published>2022-09-06T00:00:00-04:00</published><updated>2022-09-06T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/09/06/time-compl</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/09/06/time-compl.html"><![CDATA[<p><em>注：本文全部内容为<strong>一本正经的胡说八道</strong>，请勿相信</em></p>

<h2 id="示范快速排序算法">示范：快速排序算法</h2>

<p><strong>第一步：复制粘贴一份代码</strong></p>

<pre><code class="language-cpp">void qsort(int *a, int l, int r)
{
    int pivot = a[(l+r)/2];
    int i = l, j = r;
    do {
        while(a[i] &lt; pivot) i++;
        while(a[j] &gt; pivot) j--;
        if(i&lt;=j) {
            swap(a[i], a[j]);
            i++;
            j--;
        }
    } while(i &lt;= j);
    if(l &lt; j) qsort(a, l, j);
    if(i &lt; r) qsort(a, i, r);
}
int main() {
    const int N = 100001;
    int n;
    int a[N];
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
    }
    qsort(a, 0, n-1);            // sort the array
    for(int i = 0; i &lt; n; i++) {
        cout &lt;&lt; a[i] &lt;&lt; " ";
    }
}
</code></pre>

<p>然后我们很失望，因为这个算法是$O(N\log N)$的。</p>

<p><strong>第二步：观察数据范围</strong></p>

<p><img src="/img/time-compl-0.png" alt="time-compl-0" /></p>

<p>我们发现，$N$不超过$10^5$，接下来就有办法了。</p>

<p><strong>第三步：补齐数组</strong></p>

<p>在我们的代码里面更改下面几处：</p>

<pre><code class="language-diff">int main() {
    const int N = 100001;
    int n;
    int a[N];
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
    }
+   for(int i = n; i &lt; N; i++) {
+       a[i] = INT32_MAX;       // fill the rest of array with INT32_MAX
+   }
-   sort(a, 0, n-1);            // sort the array
+   sort(a, 0, N-1);            // sort the whole array
    for(int i = 0; i &lt; n; i++) {
        cout &lt;&lt; a[i] &lt;&lt; " ";
    }
}
</code></pre>

<p>然后你就惊奇地发现，不管你输入的数组是多大，这个算法都会排序$1$到$N$之间的所有数，它所需要的执行时间都是一样的。换句话说：<strong>这个算法是$O(1)$的</strong>。</p>

<p><strong>第四步：为自己献上热烈的掌声</strong></p>

<p>至此，你成功地将一个$O(N\log N)$的算法变成了$O(1)$的算法。</p>

<h2 id="练习">练习</h2>

<ol>
  <li>$O(1)$计算快速幂</li>
  <li>$O(1)$解决图的最短路问题</li>
  <li>$O(1)$解决A+B problem</li>
</ol>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="algorithm" /><category term="time-complexity" /><category term="jokes" /><summary type="html"><![CDATA[注：本文全部内容为一本正经的胡说八道，请勿相信]]></summary></entry><entry><title type="html">Y combinator和递归</title><link href="mqcreaple.github.io/blog/2022/09/02/y-combinator.html" rel="alternate" type="text/html" title="Y combinator和递归" /><published>2022-09-02T00:00:00-04:00</published><updated>2022-09-02T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/09/02/y-combinator</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/09/02/y-combinator.html"><![CDATA[<link rel="stylesheet" href="/app/lambda-playground/lambda-playground.css" />

<script src="/app/lambda-playground/lambda-playground.js" onload="autoRender()"></script>

<p><strong>温馨提示：如果你不了解λ演算，请阅读<a href="/blog/2022/08/27/lambda.html">上一篇博客</a>以获得最佳食用体验</strong></p>

<p><em>注：本文的λ表达式中所有出现的下划线<code>_</code>，都表示“这个值我懒得算且不关心”</em></p>

<h2 id="y组合子">Y组合子</h2>

<p>其实，并不是所有的λ表达式都可以化简。比如说，一个经典的构造就是：</p>

<pre><code class="language-plaintext">Ω := ((λx. (x x)) (λx. (x x)))
</code></pre>

<p class="lambda-r">[ [ "λx", [ "x", "x" ] ], [ "λx", [ "x", "x" ] ] ]</p>

<p>这个表达式很有意思。当你把后面的表达式代入前面的<code>x</code>中时，你又会得到和原来一摸一样的表达式，你永远也无法化简它。也就是，它是<strong>不可求值</strong>的。</p>

<p>而我们对这个表达式简单地变一下，就得到了另一个表达式：</p>

<pre><code class="language-plaintext">((λx. f (x x)) (λx. f (x x)))
</code></pre>

<p class="lambda-r">[ [ "λx", [ "f", [ "x", "x" ] ] ], [ "λx", [ "f", [ "x", "x" ] ] ] ]</p>

<p>当你把后一项代入前一项时，它不仅得到了原来的表达式，而且还在外面多套上了一层函数<code>f</code>。再进行一次替换操作，函数外面又多了一层<code>f</code>，你可以一直这样无穷无尽地迭代下去。</p>

<p>稍稍将外面这个函数改一下，就得到了著名的<strong>Y组合子(Y combinator)</strong>：</p>

<pre><code class="language-lisp">Y := λf. ((λx. f (x x)) (λx. f (x x)))
</code></pre>

<p>Y组合子的一大性质就是：</p>

<pre><code class="language-lisp">(Y f) = (f (Y f))
</code></pre>

<p>由于它和函数的不动点$x=f(x)$长得很像，所以Y组合子也叫<strong>不动点组合子(fixed point combinator)</strong>。</p>

<p><em>注：Y组合子并不是唯一的不动点组合子。比如由Alan Turing给出的Θ组合子</em></p>

<pre><code class="language-lisp">Θ := ((λx. λy. y (x x y)) (λx. λy. y (x x y)))
</code></pre>

<p><em>它同样满足不动点组合子的性质：</em></p>

<pre><code class="language-lisp">(Θ f) = (f (Θ f))
</code></pre>

<p>根据不动点组合子的性质，任何不动点组合子<code>fix</code>都有：</p>

<pre><code class="language-lisp">(fix f) = (f (fix f))
        = (f (f (fix f)))
        = (f (f (f (fix f))))
        = ...
        = (n f (fix f))
</code></pre>

<p>其中<code>n</code>为任意有限的自然数。这个式子我们在之后还会用到。如果你忘记了自然数的Church计数法，可以回到<a href="/blog/2022/08/27/lambda.html">上一篇博客</a>。</p>

<h2 id="函数递归">函数递归</h2>

<p>Y组合子的一大用途，就是在λ代数中表示“递归”。</p>

<p>例如，你可能会这样写一个求阶乘的函数：</p>

<pre><code class="language-plaintext">fac = λx. (if (x==0)
                (1)
                (x*(fac (x-1))))
</code></pre>

<p>（为了方便起见，这里我就不写成前缀表达式了）</p>

<blockquote>
  <p>注：<code>if</code>语句</p>

  <p><code>(if b x y)</code>的定义是：如果<code>b</code>为真，返回<code>x</code>，否则返回<code>y</code>。</p>

  <p>根据我们对布尔值<code>T</code>和<code>F</code>的定义：</p>

  <pre><code class="language-plaintext">T := λa. λb. a
F := λa. λb. b
</code></pre>

  <p>语句<code>(if b x y)</code>可以看作是<code>(b x y)</code>的另一种写法</p>
</blockquote>

<p>可惜的是，λ演算里并没有递归的语法。但是有了Y组合子，我们也可以实现类似递归的效果。</p>

<p>首先我们重写一下刚刚的<code>fac</code>函数：</p>

<pre><code class="language-plaintext">fac = λf. λx. (if (x==0)
                    (1)
                    (x*(f (x-1))))
</code></pre>

<p>现在<code>fac</code>变成了接受一个函数<code>f</code>和参数<code>x</code>的函数。那么接下来：</p>

<pre><code class="language-lisp">(Y fac 5)
</code></pre>

<p>就可以正确地返回我们想要的结果。证明如下：</p>

<pre><code class="language-plaintext">(Y fac 5) = ((fac (Y fac)) 5)                       ; 利用(Y f)=(f (Y f))
          = (if (5==0) (1) (5*((Y fac) (5-1))))     ; 将5代入x，(Y fac)代入f
          = 5*((Y fac) 4)                           ; 展开if
          = 5*(fac (Y fac) 4)                       ; 还是(Y f)=(f (Y f))
          = 5*(if (4==0) (1) (4*((Y fac) (4-1))))   ; 继续展开
          = 5*4*((Y fac) 3)
          = ...
          = 5*4*3*2*1*((Y fac) 0)
          = 5*4*3*2*1*(fac (Y fac) 0)
          = 5*4*3*2*1*(if (0==0) (1) (0*((Y fac) (0-1))))
          = 5*4*3*2*1*1
          = 5!
</code></pre>

<p>更一般地，对于一个函数$f$：</p>

<div class="kdmath">$$
f=\lambda x_1.\ \lambda x_2.\ \lambda x_3.\ \cdots\ \lambda x_n.\ [\text{BODY}]
$$</div>

<p>而$f$的函数体中使用了递归（即：调用了自己），那么我们可以将$f$改写为$f’$使得它能够在我们的λ代数中运行：</p>

<div class="kdmath">$$
f'=\lambda g.\ \lambda x_1.\ \lambda x_2.\ \cdots\ \lambda x_n.\ [\text{BODY}][f:=g]
$$</div>

<p>后面的$[\text{BODY}][f:=g]$表示将函数体里所有出现的$f$全部替换成$g$。如果你没有理解为什么要这样做，可以仔细思考一下上面阶乘的例子。</p>

<p>进行求值的时候，只需要：</p>

<div class="kdmath">$$
((Y\ f')\ x_1\ x_2\ x_3\ \cdots\ x_n)
$$</div>

<p>就相当于计算了递归函数$f$代入参数$x_1$到$x_n$的值。</p>

<h2 id="列表和懒惰求值">列表和懒惰求值</h2>

<h3 id="列表">列表</h3>

<p>你应该还记得上篇文章的思考题里出现了一个<code>pair</code>函数。它满足：</p>

<pre><code class="language-lisp">(first (pair a b)) = a
(second (pair a b)) = b
</code></pre>

<p>一个可行的构造利用了布尔值<code>T</code>和<code>F</code>的性质：</p>

<pre><code class="language-lisp">pair := λa. λb. λt. (t a b)              ; 其中t为一个布尔值
first := λp. (p T)
second := λp. (p F)
</code></pre>

<p>在<code>pair</code>的基础上，你还可以构造出另一个数据结构：列表<code>list</code>。</p>

<pre><code class="language-lisp">(list3 a b c) := λNIL. (pair a (pair b (pair c NIL)))
(list4 a b c d) := λNIL. (pair a (pair b (pair c (pair d NIL))))
(list5 a b c d e) := λNIL. (pair a (pair b (pair c (paid d (pair e NIL)))))
</code></pre>

<p>其中<code>NIL</code>是一个占位符，用来标志列表结尾。</p>

<p>一个特殊的列表是空列表：<code>list0</code></p>

<pre><code class="language-lisp">list0 := λNIL. NIL
</code></pre>

<p>有了这些定义之后，我们就可以用递归的语法来定义列表的一些操作。比如：</p>

<h4 id="列表判空">列表判空</h4>

<p>要求：只有当传入的列表是空列表时，返回<code>T</code>，否则返回<code>F</code></p>

<pre><code class="language-lisp">null := λl. (l F (λx. λy. λz. F) T)
</code></pre>

<p>首先我们发现，除了空列表以外，其他列表都是<code>λNIL. (pair _ _)</code>的形式。将<code>pair</code>函数展开得到：<code>λNIL. λb. (b _ _)</code>。如果将函数<code>null</code>作用于这个非空列表，就会得到：</p>

<pre><code class="language-lisp">(null l) = ((λl. (l F (λx. λy. λz. F) T)) (λNIL. λb. (b _ _)))
         = ((λNIL. λb. (b _ _)) F (λx. λy. λz. F) T)
         = ((λx. λy. λz. F) _ _ T)                       ; 函数接收3个参数并返回常值F
         = F
</code></pre>

<p>而空列表则会返回：</p>

<pre><code class="language-lisp">(null list0) = ((λl. (l F (λx. λy. λz. F) T) (λNIL. NIL))
             = ((λNIL. NIL) F (λx. λy. λz. F) T)
             = (F (λx. λy. λz. F) T)
             = ((λa. λb. b) (λx. λy. λz. T) T)
             = T
</code></pre>

<h4 id="列表的第一个元素">列表的第一个元素</h4>

<pre><code class="language-lisp">car := (first (l _))
</code></pre>
<p><code>car</code>返回了列表的第一个元素，前提是列表<code>l</code>非空。</p>

<p>类似地，可以写出<code>cdr</code>，返回列表除了第一个元素以外的其他元素构成的列表：</p>

<pre><code class="language-lisp">cdr := λNIL. (second (l NIL))
</code></pre>

<p><code>car</code>和<code>cdr</code>这两个函数名可能看起来很奇怪，但这两个函数名来源于最古老的函数式编程语言：Lisp。<del>这也是Lisp的函数命名经常被吐槽的原因之一</del></p>

<h4 id="列表长度">列表长度</h4>

<p>有了<code>null</code>函数，很多列表的操作都能用递归实现了。比如列表的长度计算：</p>

<pre><code class="language-lisp">length := λl. (if (null l)
                    (0)
                    ((length (cdr l))+1))
</code></pre>

<p>注意到<code>(second l)</code>返回列表<code>l</code>从第二项到末尾的子列表，它的长度一定是原列表的长度减去1。</p>

<p>我们可以用前文所说的方法将函数转化为一个非递归函数，并用Y组合子求值。</p>

<h4 id="列表第n项">列表第<code>n</code>项</h4>

<p>假设下标从0开始。</p>

<pre><code class="language-lisp">nth := λl. λn. (if (null l)
                     (error "Index out of bound!")      ; 如果是空列表，报错
                     (if (n==0)
                          (car l)
                          (nth (cdr l) (n-1))))
</code></pre>

<p>这里利用<code>(nth l n) = (nth (cdr l) (n-1))</code>递归查找第<code>n</code>项。</p>

<h4 id="添加元素">添加元素</h4>

<pre><code class="language-lisp">append := λl. λa. λNIL. (l (pair a NIL))
</code></pre>

<p>在列表末尾追加元素<code>a</code>，相当于把列表的<code>NIL</code>替换成<code>(pair a NIL)</code>。</p>

<pre><code class="language-lisp">prepend := λl. λa. λNIL. (pair a (l NIL))
</code></pre>

<p>在列表前面添加元素<code>a</code>，相当于在原来的<code>l</code>外面套一层函数<code>(pair a)</code>。</p>

<h4 id="筛选元素">筛选元素</h4>

<p>函数<code>(filter c l)</code>返回列表<code>l</code>中所有满足条件<code>c</code>的元素构成的新列表。</p>

<pre><code class="language-lisp">filter = λc. λl.
         (if (null l)
               (list0)                                    ; 如果l是空列表，返回一个空列表
               (if (c (car l))
                     (prepend (filter (cdr l) c) (car l))
                     (filter (cdr l) c)))
</code></pre>

<p><del>如果你试着手打一下这一层套一层的括号，就能理解Lisp的痛了</del></p>

<p>例如我们有一个列表<code>l = [1, 2, 3, 4] = λNIL. (pair 1 (pair 2 (pair 3 (pair 4 NIL))))</code>，那么：</p>

<pre><code class="language-lisp">(filter (λx. x&gt;2) l)
</code></pre>

<p>就会返回列表：<code>[3, 4]</code>。而：</p>

<pre><code class="language-lisp">(filter (λx. x%2==0) l)
</code></pre>

<p>就会返回列表：<code>[2, 4]</code></p>

<h3 id="无限长列表">无限长列表</h3>

<p>既然我们定义了有限长的列表，那么是否可以定义无限长的列表？</p>

<p>不妨看一下这个递归函数：</p>

<pre><code class="language-plaintext">r := λNIL. (pair 1 (r NIL))
</code></pre>

<p>它展开后会得到一个无限重复<code>1</code>的列表：</p>

<pre><code class="language-plaintext">λNIL. (pair 1 (pair 1 (pair 1 (pair 1 (......)))))
</code></pre>

<p>稍稍更改一下，还可以得到由所有自然数构成的列表：</p>

<pre><code class="language-plaintext">s := λn. λNIL. (pair n (s n+1 NIL))
(s 0) = λNIL. (pair 0 (pair 1 (pair 2 (pair 3 (......)))))
</code></pre>

<p>接下来我们探讨一下类似这样的列表的性质：</p>

<h4 id="判空">判空</h4>

<p>以上文中的<code>r=(1, 1, 1, 1, ...)</code>为例。把递归转化成Y组合子的形式，就可以得到：</p>

<pre><code class="language-lisp">r' = λf. λNIL. (pair 1 (f NIL))
(null r) = (null (Y r'))
         = ((Y r') F (λx. λy. λz. F) T)
         = ((λNIL. pair 1 (Y r' NIL)) F (λx. λy. λz. F) T)
         = ((λx. λy. λz. F) 1 (Y r' _) T)
         = F
</code></pre>

<p>这个结果也在意料之内，因为无限长的列表肯定不是空的。类似的，你也可以证明列表<code>s</code>非空。</p>

<h4 id="第n个元素">第<code>n</code>个元素</h4>

<p>先看看<code>r=[1, 1, 1, 1, ...]</code>：</p>

<pre><code class="language-lisp">r' = λf. λNIL. (pair 1 (f NIL))
(nth r n) = (nth (Y r') n)
          = (if (null (Y r'))
                  (_)
                  (if (n==0)
                        (car (Y r'))
                        (nth (cdr (Y r')) (n-1))))
          = (if (n==0)                                 ; 根据前文的结论，(null r) = F，跳过第一个分支
                  (car (Y r'))
                  (nth (cdr (Y r')) (n-1)))
</code></pre>

<blockquote>
  <p>引理：</p>

  <pre><code class="language-lisp">(car (Y r')) = (car (r' (Y r')))
             = (car (λNIL. pair 1 (Y r' NIL)))
             = 1
</code></pre>

  <pre><code class="language-lisp">(cdr (Y r')) = (cdr (r' (Y r')))
             = (cdr (λNIl. pair 1 (Y r' NIL)))
             = λNIL. (Y r' NIL)
             = (Y r')
</code></pre>
  <p>换句话说，列表<code>(Y r')</code>的第一个元素永远是<code>1</code>，而它从第二个元素开始的子列表就是自己</p>
</blockquote>

<p>回到上面的证明：</p>

<pre><code class="language-lisp">(nth r n) = (if (n==0)
                  (1)
                  (nth r n-1))
</code></pre>

<p>由于<code>n</code>是自然数，函数重复足够多轮数之后，一定会让<code>n</code>减少到<code>0</code>，此时函数返回<code>1</code>。也就是：</p>

<pre><code class="language-lisp">(nth r n) = 1
</code></pre>

<p>接着我们再说<code>s</code>。使用类似的方法可以得到：</p>

<pre><code class="language-lisp">s' = λf. λn. λNIL. (pair n (f n+1 NIL))
(car (s n)) = (car (Y s' n)) = n
(cdr (s n)) = (cdr (Y s' n)) = (s n+1)
</code></pre>

<p>根据这两个结论，可以推出来：</p>

<pre><code class="language-lisp">(nth (s n) m) = (if (m==0)
                      (car (s n))
                      (nth (cdr (s n)) m-1))
              = (if (m==0)
                      (n)
                      (nth (s n+1) m-1))
</code></pre>

<p>根据数学归纳法，不难知道：<code>(nth (s n) m)</code>的返回值为<code>n+m</code>。特别地，<code>(nth (s 0) m)</code>就是<code>m</code>。</p>

<h3 id="懒惰求值">懒惰求值</h3>

<p>当然，无限长列表的应用远不止这些。比如，斐波那契数列：</p>

<pre><code class="language-lisp">fib = λa. λb. λNIL. (pair a (fib b a+b NIL))
(fib 1 1)       ; [1, 1, 2, 3, 5, 8, 13, ...]
</code></pre>

<p>甚至我们可以使用埃氏筛算法，写出一个装满所有质数的列表：</p>

<pre><code class="language-lisp">sieve := λl. (prepend
               (sieve (filter (λx. x%(car l)!=0) (cdr l)))  ; 去掉(cdr l)中所有(car l)的倍数
               (car l))

(sieve (s 2))           ; [2, 3, 5, 7, 11, 13, 17, ...]
</code></pre>

<p>如果你使用过haskell或者其他支持数组懒惰求值的编程语言，应该或多或少了解过这种写法。它允许你使用有限的语言来描述一个无限长的数列！</p>

<p><em>当然，懒惰求值只能表示出<strong>可计算</strong>的无限序列，例如上面说的斐波那契数列和质数数列，或者π的第n位等。这是因为，λ演算的计算能力和图灵机是等价的，任何不能用图灵机算出的数值同样也不能用λ演算算出来。</em></p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="lambda-calculus" /><category term="computation" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">用λ演算建立数学</title><link href="mqcreaple.github.io/blog/2022/08/27/lambda.html" rel="alternate" type="text/html" title="用λ演算建立数学" /><published>2022-08-27T00:00:00-04:00</published><updated>2022-08-27T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/08/27/lambda</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/08/27/lambda.html"><![CDATA[<link rel="stylesheet" href="/app/lambda-playground/lambda-playground.css" />

<script src="/app/lambda-playground/lambda-playground.js" onload="autoRender()"></script>

<p>在古早之前（大约我初一的时候），我写过一篇博客<del>遗憾的是现在它已经找不到了</del>，讲述了如何用纯集合论的方法构建自然数。学过数学分析的小朋友们相信对这个知识点已经不陌生了。</p>

<p>不过，集合论并不是唯一一种可以用来构建自然数的方法。今天，我就要介绍另一个可行的方法：<strong>λ演算</strong>。</p>

<p>当然在这之前，我先简单介绍一下λ演算：</p>

<h2 id="什么是λ演算">什么是λ演算？</h2>

<p>相信大家对函数已经不陌生了。比如下面这个函数：</p>

<div class="kdmath">$$
f(x)=2x
$$</div>

<p>它输入一个变量$x$，输出一个数，并且满足输出的数一定是输入的两倍。</p>

<p>接下来我们介绍一种新的记号，用来表示同一个函数：</p>

<div class="kdmath">$$
f=\lambda x.\ 2x
$$</div>

<p>这个表达式分为两段，第一段以λ开头，表示一个参数，第二段则是函数体。我们称这样的表达式为：<strong>λ表达式</strong>。</p>

<p>同时，我们也简单修改一下调用函数的记号：把括号写在函数前面，而不是后面</p>

<div class="kdmath">$$
\begin{align*}
(f\ 2) &= ((\lambda x.\ 2x)\ 2) \\
&= 2\cdot 2 \\
&= 4
\end{align*}
$$</div>

<p>我知道这对初学者来说看起来很别扭，但只要熟悉就好了。</p>

<p>λ表达式的求值很简单。只需要找到和传入的参数相对应的λ项，然后将函数体的所有对应项全都替换成传入的参数即可。</p>

<h3 id="多元函数">多元函数</h3>

<p>你可能会问，如果函数接受多个参数，该怎么办？比如下面这个函数：</p>

<div class="kdmath">$$
f(x, y)=x+2y
$$</div>

<p>答案很简单，只需要这样写：</p>

<div class="kdmath">$$
f=\lambda x.\ \lambda y.\ x+2y
$$</div>

<p>表达式前面有两个$\lambda$，就表示函数接受两个参数。比如：</p>

<div class="kdmath">$$
\begin{align*}
(f\ 2\ 3) &= ((\lambda x.\ \lambda y.\ x+2y)\ 2\ 3) \\
&= 2+2\cdot 3 \\
&= 8
\end{align*}
$$</div>

<p>同时，这个表达式还有一种解读方法。我们将$f$看作一个关于$x$的单值函数，但函数返回了另一个λ表达式：</p>

<div class="kdmath">$$
f=\lambda x.\ (\lambda y.\ x+2y)
$$</div>

<div class="kdmath">$$
\begin{align*}
(f\ 2) &= ((\lambda x.\ (\lambda y.\ x+2y))\ 2) \\
&= \lambda y.\ 2+2y
\end{align*}
$$</div>

<p>此时它的返回值还需要再接受一个参数，才能得到一个确定的值。</p>

<p>换句话说，我们把一个二元函数，变成了一个“返回一个一元函数”的一元函数。我们称这个步骤为函数的<strong>柯里化（Currying）</strong>。它同样适用于更多元的函数。</p>

<div class="kdmath">$$
f:U\times V\to W\quad\simeq\quad g:U\to(V\to W)
$$</div>

<blockquote>
  <p>柯里化是λ演算和函数式编程的一大难点，同时也是一大精妙之处</p>
</blockquote>

<p>进一步推广，我们还可以把常数看作是一个接受0个参数的函数，只不过没什么必要去这样做罢了。</p>

<p>当然了，常见的加减乘除之类的运算都是二元函数，因此其实在标准的λ语法中，四则运算应该这样写：</p>

<div class="kdmath">$$
a+b \Rightarrow (+\ a\ b)
$$</div>

<div class="kdmath">$$
a-b \Rightarrow (-\ a\ b)
$$</div>

<div class="kdmath">$$
a\cdot b \Rightarrow (*\ a\ b)
$$</div>

<div class="kdmath">$$
a/b \Rightarrow (/\ a\ b)
$$</div>

<p>如果你学过波兰表达式(Polish Notation)，你应该对这样的写法不陌生：<strong>这其实就是加上括号的波兰表达式！</strong></p>

<p>当然，除了四则运算，其他的二元运算都有类似的规则，例如判断运算（$\gt, \lt, =, \ne, \ge, \le$），逻辑运算（<code>AND</code>, <code>OR</code>, <code>NOT</code>）等。</p>

<blockquote>
  <p>思考题：结合上述知识，你能说说这些表达式是什么含义吗？</p>

  <div class="kdmath">$$
(*\ 3)
$$</div>

  <div class="kdmath">$$
(=\ 2)
$$</div>
</blockquote>

<h2 id="函数的函数">“函数”的函数</h2>

<p>我们发现，λ表达式并没有对参数的类型做限定。也就是说，<em>向λ表达式里传入一个函数也是完全合法的！</em></p>

<p>我们看一个例子：</p>

<div class="kdmath">$$
R=\lambda f.\ \lambda x.\ (f\ (f\ x))
$$</div>

<p>这个表达式$R$的意义就是：传入一个函数和一个值，把这个函数在值上做两遍。</p>

<p>举个例子：</p>

<div class="kdmath">$$
\begin{align*}
(R\ (\lambda x.\ x^2)\ 2) &= ((\lambda f.\ \lambda x.\ (f\ (f\ x)))\ (\lambda x.\ x^2))\ 2) \\
&= ((\lambda x.\ x^2)\ ((\lambda x.\ x^2)\ 2)) \\
&= ((\lambda x.\ x^2)\ 4) \\
&= 16
\end{align*}
$$</div>

<p>下面是一个简单的演示。点击图中的$R$将其展开，拖动函数参数到对应的λ位置来进行参数替换。</p>

<p class="lambda-r" data-repl-table="{ &quot;R&quot;: [ &quot;λf&quot;, &quot;λx&quot;, [ &quot;f&quot;, [ &quot;f&quot;, &quot;x&quot; ] ] ] }">[ "R", [ "λx", [ "^", "x", "2" ] ], "2" ]</p>

<p>当然，使用前面<em>柯里化</em>的思想，我们也可以这样看：$R$输入一个λ表达式，输出一个λ表达式，其中输出的表达式是输入的表达式重复两遍的结果。</p>

<div class="kdmath">$$
(R\ f)=\lambda x.\ (f\ (f\ x))
$$</div>

<p>同时这也告诉我们一个道理：在λ语言中，很多情况下括号是不能省略的。比如</p>

<div class="kdmath">$$
(f\ (g\ x))
$$</div>

<p>就是变量$x$先被$g$作用再被$f$作用，而</p>

<div class="kdmath">$$
(f\ g\ x)
$$</div>

<p>则是函数$g$和变量$x$同时传入$f$中。</p>

<h2 id="逻辑运算">逻辑运算</h2>

<p>相信从上面的介绍中，你已经初步掌握了λ演算。接下来我们将要玩一个小游戏：只用λ演算，不用任何额外的工具（包括逻辑运算，数值运算等一切你熟悉到不能再熟悉的东西），看看你能搭建出什么东西。</p>

<p>没有逻辑运算，就意味着我们没有定义“真”、“假”等概念。那么，我们能不能从λ演算中把这些东西定义出来呢？</p>

<p>首先我们想到，“真”和“假”是一组对立的概念，就像是硬币的两面。从这里出发，我们先写出这样的定义：</p>

<div class="kdmath">$$
T:=\lambda x.\ \lambda y.\ x
$$</div>

<div class="kdmath">$$
F:=\lambda x.\ \lambda y.\ y
$$</div>

<p>在这样的定义下，“真”就是给定两个东西取出第一个，而“假”则是给定两个东西取出第二个。注意到这两个定义中我们没有用到任何运算。</p>

<h3 id="逻辑非">逻辑非</h3>

<p>有了这两个定义，那么逻辑非（Not）就很好定义了。它的定义如下：</p>

<div class="kdmath">$$
(\lnot) := \lambda a.\ (a\ F\ T)
$$</div>

<p>不要忘记了$T$和$F$的含义：$T$表示选择第一个东西，而$F$表示选择第二个东西。也就是说，如果$a=T$，它就会选择第一个参数，也就是$F$；反之，如果$a=F$，它就会选第二个参数，就是$T$。</p>

<p>如果你没有理解这个定义，不妨看下面的演示。请你按照以下顺序操作：</p>

<ol>
  <li>点击<code>NOT</code>将其展开</li>
  <li>将后面的<code>T</code>或<code>F</code>拖动到对应位置</li>
  <li>将首位的<code>T</code>或<code>F</code>展开</li>
  <li>将后面的两个参数拖动到对应位置</li>
</ol>

<p class="lambda-r">[ "NOT", "T" ]</p>

<p class="lambda-r">[ "NOT", "F" ]</p>

<h3 id="逻辑与和逻辑或">逻辑与和逻辑或</h3>

<p>逻辑与的定义则相对复杂，因为它需要接受两个参数。</p>

<p>不难发现，计算$a\land b$时，假如$a$为真，则运算结果就等于$b$，反之如果$a$为假，则运算结果一定是假。</p>

<p>因此我们给出了逻辑与的λ定义：</p>

<div class="kdmath">$$
(\land):=\lambda a.\ \lambda b.\ (a\ b\ F)
$$</div>

<p>类似地，如果$a=T$，那么就会选择第一个参数$b$，它的返回值就取决于$b$的值；而如果$a=F$，它就一定会返回$F$。</p>

<p>同样你也可以看这里的演示：</p>

<p class="lambda-r">[ "AND", "T", "T" ]</p>

<p class="lambda-r">[ "AND", "T", "F" ]</p>

<p class="lambda-r">[ "AND", "F", "T" ]</p>

<p class="lambda-r">[ "AND", "F", "F" ]</p>

<p>类比逻辑与的定义，我们也可以写出逻辑或的定义：</p>

<div class="kdmath">$$
(\lor):=\lambda a.\ \lambda b.\ (a\ T\ b)
$$</div>

<p>以及演示：</p>

<p class="lambda-r">[ "OR", "T", "T" ]</p>

<p class="lambda-r">[ "OR", "T", "F" ]</p>

<p class="lambda-r">[ "OR", "F", "T" ]</p>

<p class="lambda-r">[ "OR", "F", "F" ]</p>

<h3 id="组合逻辑">组合逻辑</h3>

<p>有了逻辑运算的三兄弟：与、或、非，其余的一切逻辑运算都可以被表示出来了。比如：</p>

<div class="kdmath">$$
\text{xor}:=\lambda a.\ \lambda b.\ (\lor\ (\land\ a\ (\lnot\ b))\ (\land\ b\ (\lnot\ a)))
$$</div>

<p>当然也可利用λ的性质，写出一个更简洁的异或运算：</p>

<div class="kdmath">$$
\text{xor}:=\lambda a.\ \lambda b.\ (a\ (\lnot\ b)\ b)
$$</div>

<h3 id="谓词和逻辑运算">谓词和逻辑运算</h3>

<p>我们定义，如果有一个λ表达式$p$的返回值要么是$T$，要么是$F$，则$p$称为一个<strong>谓词</strong>。</p>

<p>比如，判断两个自然数相等的运算：</p>

<div class="kdmath">$$
(=\ a\ b)
$$</div>

<p>就是一个谓词。</p>

<h2 id="自然数">自然数</h2>

<p>回想一下自然数的五条公理：</p>

<ol>
  <li>$0$是自然数</li>
  <li>每一个自然数$n$都有一个后继，记为$n^+$</li>
  <li>任何两个不同的元素，它们的后继也不同
    <ul>
      <li>或者说，$(n^+)$这个函数是$\N\to \N$的单射</li>
    </ul>
  </li>
  <li>除了$0$以外每一个自然数都有一个前驱</li>
  <li>假如命题$p$满足：$p(0)$为真，且任何$p(n)$为真可以推出$p(n+1)$为真，则任何$k\in\N$都有$p(k)$为真
    <ul>
      <li>或者说，数学归纳法在$\N$上成立</li>
    </ul>
  </li>
</ol>

<p>一个可行的构造是由λ演算的提出者Alonzo Church提出的方案，我们称其为<strong>Church计数</strong>。其自然数的构造如下：</p>

<div class="kdmath">$$
\begin{align*}
0 & :=\lambda f.\ \lambda x.\ x \\
1 & :=\lambda f.\ \lambda x.\ (f\ x) \\
2 & :=\lambda f.\ \lambda x.\ (f\ (f\ x)) \\
3 & :=\lambda f.\ \lambda x.\ (f\ (f\ (f\ x)))) \\
\vdots \\
n & :=\lambda f.\ \lambda x.\ (f^{\circ n}\ x) \\
\vdots
\end{align*}
$$</div>

<p>也就是说，第$n$个自然数，就是将一个函数重复$n$遍。</p>

<p>那么自然数的后继就可以这样定义：</p>

<div class="kdmath">$$
\text{succ}:=\lambda n.\ \lambda f.\ \lambda x.\ (f\ (n\ f\ x))
$$</div>

<p>注意：你可能会以为$\text{succ}$接受三个参数，但使用它时，只用一个参数$n$，返回一个带有两个参数$f,x$的λ表达式。</p>

<p>举个例子，我们想要计算$1$的后继：</p>

<div class="kdmath">$$
\begin{align*}
(\text{succ}\ 1) &= ((\lambda n.\ \lambda f.\ \lambda x.\ (f\ (n\ f\ x)))\ 1) \\
&= \lambda f.\ \lambda x.\ (f\ (1\ f\ x)) \\
&= \lambda f.\ \lambda x.\ (f\ (f\ x))
\end{align*}
$$</div>

<p>查一下表，不难发现这个λ表达式就是自然数$2$。</p>

<p class="lambda-r">[ "SUCC", "1" ]</p>

<h3 id="加法">加法</h3>

<p>将上面后继的定义稍稍更改一下，即可得到加法的定义：</p>

<div class="kdmath">$$
(+):=\lambda m.\ \lambda n.\ \lambda f.\ \lambda x.\ (m\ f\ (n\ f\ x))
$$</div>

<p>根据定义，$(n\ f\ x)$是函数$f$在$x$上重复数字$n$遍，而$(m\ f)$又是函数$f$重复数字$m$遍。两者复合之后就是函数$f$重复了$m+n$遍。</p>

<p>这里就不手打示例公式了，大家可以在下面操作一下。</p>

<p class="lambda-r">[ "+", "1", "2" ]</p>

<p>一个等价的表达式是这样的：</p>

<div class="kdmath">$$
(+):=\lambda m.\ \lambda n.\ (m\ \text{succ}\ n)
$$</div>

<p>相当于在数$n$上使用$m$次$\text{succ}$函数。</p>

<h3 id="乘法">乘法</h3>

<p>不难想到乘法可以这样定义：</p>

<div class="kdmath">$$
(\times):=\lambda m.\ \lambda n.\ (m\ (+\ n)\ 0)
$$</div>

<p>不要忘了，$(+\ n)$是一个λ表达式，输入一个数，输出它加上$n$的结果。这个表达式的含义就是：从$0$开始，重复$m$次操作，每次给数加上$n$。那么最后得到的就是数$m\times n$。</p>

<p>但是，它还有一个更简洁的形式：</p>

<div class="kdmath">$$
(\times):=\lambda m.\ \lambda n.\ \lambda f.\ (m\ (n\ f))
$$</div>

<p>其中$(n\ f)$返回一个λ表达式，表示将函数$f$重复$n$遍，而$(m\ (n\ f))$则是进一步把$(n\ f)$重复了$m$遍。那么$f$总共就被重复了$m\times n$遍。</p>

<p>可以看一下这个演示：</p>

<p class="lambda-r">[ "*", "2", "3" ]</p>

<p class="lambda-r">[ "*", "3", "2" ]</p>

<h3 id="前驱">前驱</h3>

<p>相对于前面的运算，“求前驱”是一个相对更难的操作，因为它需要从一个表达式上面“剥掉”一层函数调用。比如：</p>

<div class="kdmath">$$
3=\lambda f.\ \lambda x.\ (f\ (f\ (f\ x)))\xrightarrow{\text{pred}} 2=\lambda f.\ \lambda x.\ (f\ (f\ x))
$$</div>

<p>我们想到，假如能够构造出一个函数$R$，使得它第一次作用在某个值$x$上得到的是它本身，而第二、三、四、…次之后，每次往$x$上面套一层$f$。那么只需要：</p>

<div class="kdmath">$$
(n\ R\ x)
$$</div>

<p>就可以得到$(f^{\circ(n-1)}\ x)$了。</p>

<p>可惜，你想得美。这种函数不可能存在，因为$R$这个函数不是一个纯函数。</p>

<p>如果我们已知：</p>

<div class="kdmath">$$
(R\ x) = x
$$</div>

<p>那么将$R$在$x$上作用两遍的结果一定也是：</p>

<div class="kdmath">$$
\begin{align*}
(R\ (R\ x)) &= (R\ x) \\
&= x
\end{align*}
$$</div>

<p>但是，你也不要小瞧了λ演算的威力。我们虽然没法构造一个这样的函数，但可以构造一个功能类似的函数：</p>

<div class="kdmath">$$
T=\lambda g.\ \lambda h.\ (h\ (g\ f))
$$</div>

<p>使用这个函数时，需要向里面传入一个常值λ表达式：$(\lambda u.\ x)$</p>

<div class="kdmath">$$
\begin{align*}
(T\ (\lambda u.\ x)) &= \lambda h.\ (h\ ((\lambda u.\ x)\ f)) \\
&= \lambda h.\ (h\ x) \\
&= \lambda u.\ (u\ x)
\end{align*}
$$</div>

<p class="lambda-r" data-repl-table="{&quot;T&quot;:[&quot;λg&quot;,&quot;λh&quot;,[&quot;h&quot;,[&quot;g&quot;,&quot;f&quot;]]]}">["T", ["λu", "x"]]</p>

<p>如果再把$T$作用到刚刚算得的结果上，就是：</p>

<div class="kdmath">$$
\begin{align*}
(T\ (T\ (\lambda u.\ x))) &= (T\ (\lambda u.\ (u\ x))) \\
&= \lambda h.\ (h\ ((\lambda u.\ (u\ x))\ f)) \\
&= \lambda h.\ (h\ (f\ x)) \\
&= \lambda u.\ (u\ (f\ x))
\end{align*}
$$</div>

<p class="lambda-r" data-repl-table="{&quot;T&quot;:[&quot;λg&quot;,&quot;λh&quot;,[&quot;h&quot;,[&quot;g&quot;,&quot;f&quot;]]]}">["T", ["λu", ["u", "x"]]]</p>

<p>进一步的，如果作用三次$T$，就会得到：</p>

<div class="kdmath">$$
\lambda u.\ (u\ (f\ (f\ x)))
$$</div>

<p class="lambda-r" data-repl-table="{&quot;T&quot;:[&quot;λg&quot;,&quot;λh&quot;,[&quot;h&quot;,[&quot;g&quot;,&quot;f&quot;]]]}">["T", ["λu", ["u", ["f", "x"]]]]</p>

<p>通过归纳法不难得到，在$(\lambda u.\ x)$上作用$n$次$T$，得到的结果就是：</p>

<div class="kdmath">$$
\lambda u.\ (u\ (f^{\circ(n-1)}\ x))
$$</div>

<p>注意到我们在这个表达式里发现了一个$(f^{\circ(n-1)}\ x)$，这就是要求的值！最后一步就是消去函数$u$，一个简单的方法就是将$u$代入单位函数$\text{id}=\lambda v.\ v$即可。</p>

<div class="kdmath">$$
\begin{align*}
&(\lambda u.\ (u\ (f^{\circ(n-1)}\ x))\ (\lambda v.\ v)) \\
=& ((\lambda v.\ v)\ (f^{\circ(n-1)}\ x)) \\
=& (f^{\circ(n-1)}\ x)
\end{align*}
$$</div>

<p>综合上述结果，我们得到了前驱$\text{pred}$的λ表达式，若传入的$n\gt 0$，那么它返回$n-1$，否则返回$0$：</p>

<div class="kdmath">$$
\text{pred}:=\lambda n.\ \lambda f.\ \lambda x.\ ((n\ T\ (\lambda u.\ x))\ \text{id})
$$</div>

<p class="lambda-r">[ "PRED", "0" ]</p>

<p class="lambda-r">[ "PRED", "1" ]</p>

<p class="lambda-r">[ "PRED", "2" ]</p>

<h3 id="减法">减法</h3>

<p>有了前驱运算，减法就不难定义了：</p>

<div class="kdmath">$$
(-):=\lambda m.\ \lambda n.\ (n\ \text{pred}\ m)
$$</div>

<p>当然，由于自然数没有负数，假如被减数$m$小于$n$，减法运算的结果就是$0$。</p>

<h3 id="判断">判断</h3>

<p>我们可以定义一个函数来判断某个数是不是$0$：</p>

<div class="kdmath">$$
\text{iszero}:=\lambda n.\ (n\ (\lambda u.\ F)\ T)
$$</div>

<p>函数$(\lambda u.\ F)$是一个永远返回$F$的常值函数。所以，只要$n\gt0$，$(\text{iszero}\ n)$就会返回$F$。</p>

<p>再加上之前定义的减法，我们就可以定义“大于等于”函数：</p>

<div class="kdmath">$$
(\ge):=\lambda m.\ \lambda n.\ (\text{iszero}\ (-\ n\ m))
$$</div>

<p>再根据大于等于来定义自然数的相等：</p>

<div class="kdmath">$$
(=):=\lambda m.\ \lambda n.\ (\land\ (\ge\ m\ n)\ (\ge\ n\ m))
$$</div>

<h2 id="思考题">思考题</h2>

<p>你能使用λ演算来定义一个类似C++中<code>std::pair</code>的数据结构吗？</p>

<blockquote>
  <p>要求：使用函数</p>

  <div class="kdmath">$$
(\text{pair}\ a\ b)
$$</div>

  <p>来构造一个对象，并使用$(\text{first}\ p)$和$(\text{second}\ p)$来获取一个pair的第一和第二个值。</p>
</blockquote>

<p>你能在这个结构的基础上，用λ演算来定义所有的<strong>整数</strong>及其相应的数值和逻辑运算吗？</p>

<h2 id="参考资料">参考资料</h2>

<p>[1] “Lambda Calculus.” <em>Wikipedia</em>, <a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>. Accessed 26 Aug. 2022.</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="lambda-calculus" /><category term="computation" /><summary type="html"><![CDATA[在古早之前（大约我初一的时候），我写过一篇博客遗憾的是现在它已经找不到了，讲述了如何用纯集合论的方法构建自然数。学过数学分析的小朋友们相信对这个知识点已经不陌生了。 不过，集合论并不是唯一一种可以用来构建自然数的方法。今天，我就要介绍另一个可行的方法：λ演算。 当然在这之前，我先简单介绍一下λ演算： 什么是λ演算？ 相信大家对函数已经不陌生了。比如下面这个函数： $$ f(x)=2x $$ 它输入一个变量$x$，输出一个数，并且满足输出的数一定是输入的两倍。 接下来我们介绍一种新的记号，用来表示同一个函数： $$ f=\lambda x.\ 2x $$ 这个表达式分为两段，第一段以λ开头，表示一个参数，第二段则是函数体。我们称这样的表达式为：λ表达式。 同时，我们也简单修改一下调用函数的记号：把括号写在函数前面，而不是后面 $$ \begin{align*} (f\ 2) &= ((\lambda x.\ 2x)\ 2) \\ &= 2\cdot 2 \\ &= 4 \end{align*} $$ 我知道这对初学者来说看起来很别扭，但只要熟悉就好了。 λ表达式的求值很简单。只需要找到和传入的参数相对应的λ项，然后将函数体的所有对应项全都替换成传入的参数即可。 多元函数 你可能会问，如果函数接受多个参数，该怎么办？比如下面这个函数： $$ f(x, y)=x+2y $$ 答案很简单，只需要这样写： $$ f=\lambda x.\ \lambda y.\ x+2y $$ 表达式前面有两个$\lambda$，就表示函数接受两个参数。比如： $$ \begin{align*} (f\ 2\ 3) &= ((\lambda x.\ \lambda y.\ x+2y)\ 2\ 3) \\ &= 2+2\cdot 3 \\ &= 8 \end{align*} $$ 同时，这个表达式还有一种解读方法。我们将$f$看作一个关于$x$的单值函数，但函数返回了另一个λ表达式： $$ f=\lambda x.\ (\lambda y.\ x+2y) $$ $$ \begin{align*} (f\ 2) &= ((\lambda x.\ (\lambda y.\ x+2y))\ 2) \\ &= \lambda y.\ 2+2y \end{align*} $$ 此时它的返回值还需要再接受一个参数，才能得到一个确定的值。 换句话说，我们把一个二元函数，变成了一个“返回一个一元函数”的一元函数。我们称这个步骤为函数的柯里化（Currying）。它同样适用于更多元的函数。 $$ f:U\times V\to W\quad\simeq\quad g:U\to(V\to W) $$ 柯里化是λ演算和函数式编程的一大难点，同时也是一大精妙之处 进一步推广，我们还可以把常数看作是一个接受0个参数的函数，只不过没什么必要去这样做罢了。 当然了，常见的加减乘除之类的运算都是二元函数，因此其实在标准的λ语法中，四则运算应该这样写： $$ a+b \Rightarrow (+\ a\ b) $$ $$ a-b \Rightarrow (-\ a\ b) $$ $$ a\cdot b \Rightarrow (*\ a\ b) $$ $$ a/b \Rightarrow (/\ a\ b) $$ 如果你学过波兰表达式(Polish Notation)，你应该对这样的写法不陌生：这其实就是加上括号的波兰表达式！ 当然，除了四则运算，其他的二元运算都有类似的规则，例如判断运算（$\gt, \lt, =, \ne, \ge, \le$），逻辑运算（AND, OR, NOT）等。 思考题：结合上述知识，你能说说这些表达式是什么含义吗？ $$ (*\ 3) $$ $$ (=\ 2) $$ “函数”的函数 我们发现，λ表达式并没有对参数的类型做限定。也就是说，向λ表达式里传入一个函数也是完全合法的！ 我们看一个例子： $$ R=\lambda f.\ \lambda x.\ (f\ (f\ x)) $$ 这个表达式$R$的意义就是：传入一个函数和一个值，把这个函数在值上做两遍。 举个例子： $$ \begin{align*} (R\ (\lambda x.\ x^2)\ 2) &= ((\lambda f.\ \lambda x.\ (f\ (f\ x)))\ (\lambda x.\ x^2))\ 2) \\ &= ((\lambda x.\ x^2)\ ((\lambda x.\ x^2)\ 2)) \\ &= ((\lambda x.\ x^2)\ 4) \\ &= 16 \end{align*} $$ 下面是一个简单的演示。点击图中的$R$将其展开，拖动函数参数到对应的λ位置来进行参数替换。 [ "R", [ "λx", [ "^", "x", "2" ] ], "2" ] 当然，使用前面柯里化的思想，我们也可以这样看：$R$输入一个λ表达式，输出一个λ表达式，其中输出的表达式是输入的表达式重复两遍的结果。 $$ (R\ f)=\lambda x.\ (f\ (f\ x)) $$ 同时这也告诉我们一个道理：在λ语言中，很多情况下括号是不能省略的。比如 $$ (f\ (g\ x)) $$ 就是变量$x$先被$g$作用再被$f$作用，而 $$ (f\ g\ x) $$ 则是函数$g$和变量$x$同时传入$f$中。 逻辑运算 相信从上面的介绍中，你已经初步掌握了λ演算。接下来我们将要玩一个小游戏：只用λ演算，不用任何额外的工具（包括逻辑运算，数值运算等一切你熟悉到不能再熟悉的东西），看看你能搭建出什么东西。 没有逻辑运算，就意味着我们没有定义“真”、“假”等概念。那么，我们能不能从λ演算中把这些东西定义出来呢？ 首先我们想到，“真”和“假”是一组对立的概念，就像是硬币的两面。从这里出发，我们先写出这样的定义： $$ T:=\lambda x.\ \lambda y.\ x $$ $$ F:=\lambda x.\ \lambda y.\ y $$ 在这样的定义下，“真”就是给定两个东西取出第一个，而“假”则是给定两个东西取出第二个。注意到这两个定义中我们没有用到任何运算。 逻辑非 有了这两个定义，那么逻辑非（Not）就很好定义了。它的定义如下： $$ (\lnot) := \lambda a.\ (a\ F\ T) $$ 不要忘记了$T$和$F$的含义：$T$表示选择第一个东西，而$F$表示选择第二个东西。也就是说，如果$a=T$，它就会选择第一个参数，也就是$F$；反之，如果$a=F$，它就会选第二个参数，就是$T$。 如果你没有理解这个定义，不妨看下面的演示。请你按照以下顺序操作： 点击NOT将其展开 将后面的T或F拖动到对应位置 将首位的T或F展开 将后面的两个参数拖动到对应位置 [ "NOT", "T" ] [ "NOT", "F" ] 逻辑与和逻辑或 逻辑与的定义则相对复杂，因为它需要接受两个参数。 不难发现，计算$a\land b$时，假如$a$为真，则运算结果就等于$b$，反之如果$a$为假，则运算结果一定是假。 因此我们给出了逻辑与的λ定义： $$ (\land):=\lambda a.\ \lambda b.\ (a\ b\ F) $$ 类似地，如果$a=T$，那么就会选择第一个参数$b$，它的返回值就取决于$b$的值；而如果$a=F$，它就一定会返回$F$。 同样你也可以看这里的演示： [ "AND", "T", "T" ] [ "AND", "T", "F" ] [ "AND", "F", "T" ] [ "AND", "F", "F" ] 类比逻辑与的定义，我们也可以写出逻辑或的定义： $$ (\lor):=\lambda a.\ \lambda b.\ (a\ T\ b) $$ 以及演示： [ "OR", "T", "T" ] [ "OR", "T", "F" ] [ "OR", "F", "T" ] [ "OR", "F", "F" ] 组合逻辑 有了逻辑运算的三兄弟：与、或、非，其余的一切逻辑运算都可以被表示出来了。比如： $$ \text{xor}:=\lambda a.\ \lambda b.\ (\lor\ (\land\ a\ (\lnot\ b))\ (\land\ b\ (\lnot\ a))) $$ 当然也可利用λ的性质，写出一个更简洁的异或运算： $$ \text{xor}:=\lambda a.\ \lambda b.\ (a\ (\lnot\ b)\ b) $$ 谓词和逻辑运算 我们定义，如果有一个λ表达式$p$的返回值要么是$T$，要么是$F$，则$p$称为一个谓词。 比如，判断两个自然数相等的运算： $$ (=\ a\ b) $$ 就是一个谓词。 自然数 回想一下自然数的五条公理： $0$是自然数 每一个自然数$n$都有一个后继，记为$n^+$ 任何两个不同的元素，它们的后继也不同 或者说，$(n^+)$这个函数是$\N\to \N$的单射 除了$0$以外每一个自然数都有一个前驱 假如命题$p$满足：$p(0)$为真，且任何$p(n)$为真可以推出$p(n+1)$为真，则任何$k\in\N$都有$p(k)$为真 或者说，数学归纳法在$\N$上成立 一个可行的构造是由λ演算的提出者Alonzo Church提出的方案，我们称其为Church计数。其自然数的构造如下： $$ \begin{align*} 0 & :=\lambda f.\ \lambda x.\ x \\ 1 & :=\lambda f.\ \lambda x.\ (f\ x) \\ 2 & :=\lambda f.\ \lambda x.\ (f\ (f\ x)) \\ 3 & :=\lambda f.\ \lambda x.\ (f\ (f\ (f\ x)))) \\ \vdots \\ n & :=\lambda f.\ \lambda x.\ (f^{\circ n}\ x) \\ \vdots \end{align*} $$ 也就是说，第$n$个自然数，就是将一个函数重复$n$遍。 那么自然数的后继就可以这样定义： $$ \text{succ}:=\lambda n.\ \lambda f.\ \lambda x.\ (f\ (n\ f\ x)) $$ 注意：你可能会以为$\text{succ}$接受三个参数，但使用它时，只用一个参数$n$，返回一个带有两个参数$f,x$的λ表达式。 举个例子，我们想要计算$1$的后继： $$ \begin{align*} (\text{succ}\ 1) &= ((\lambda n.\ \lambda f.\ \lambda x.\ (f\ (n\ f\ x)))\ 1) \\ &= \lambda f.\ \lambda x.\ (f\ (1\ f\ x)) \\ &= \lambda f.\ \lambda x.\ (f\ (f\ x)) \end{align*} $$ 查一下表，不难发现这个λ表达式就是自然数$2$。 [ "SUCC", "1" ] 加法 将上面后继的定义稍稍更改一下，即可得到加法的定义： $$ (+):=\lambda m.\ \lambda n.\ \lambda f.\ \lambda x.\ (m\ f\ (n\ f\ x)) $$ 根据定义，$(n\ f\ x)$是函数$f$在$x$上重复数字$n$遍，而$(m\ f)$又是函数$f$重复数字$m$遍。两者复合之后就是函数$f$重复了$m+n$遍。 这里就不手打示例公式了，大家可以在下面操作一下。 [ "+", "1", "2" ] 一个等价的表达式是这样的： $$ (+):=\lambda m.\ \lambda n.\ (m\ \text{succ}\ n) $$ 相当于在数$n$上使用$m$次$\text{succ}$函数。 乘法 不难想到乘法可以这样定义： $$ (\times):=\lambda m.\ \lambda n.\ (m\ (+\ n)\ 0) $$ 不要忘了，$(+\ n)$是一个λ表达式，输入一个数，输出它加上$n$的结果。这个表达式的含义就是：从$0$开始，重复$m$次操作，每次给数加上$n$。那么最后得到的就是数$m\times n$。 但是，它还有一个更简洁的形式： $$ (\times):=\lambda m.\ \lambda n.\ \lambda f.\ (m\ (n\ f)) $$ 其中$(n\ f)$返回一个λ表达式，表示将函数$f$重复$n$遍，而$(m\ (n\ f))$则是进一步把$(n\ f)$重复了$m$遍。那么$f$总共就被重复了$m\times n$遍。 可以看一下这个演示： [ "*", "2", "3" ] [ "*", "3", "2" ] 前驱 相对于前面的运算，“求前驱”是一个相对更难的操作，因为它需要从一个表达式上面“剥掉”一层函数调用。比如： $$ 3=\lambda f.\ \lambda x.\ (f\ (f\ (f\ x)))\xrightarrow{\text{pred}} 2=\lambda f.\ \lambda x.\ (f\ (f\ x)) $$ 我们想到，假如能够构造出一个函数$R$，使得它第一次作用在某个值$x$上得到的是它本身，而第二、三、四、…次之后，每次往$x$上面套一层$f$。那么只需要： $$ (n\ R\ x) $$ 就可以得到$(f^{\circ(n-1)}\ x)$了。 可惜，你想得美。这种函数不可能存在，因为$R$这个函数不是一个纯函数。 如果我们已知： $$ (R\ x) = x $$ 那么将$R$在$x$上作用两遍的结果一定也是： $$ \begin{align*} (R\ (R\ x)) &= (R\ x) \\ &= x \end{align*} $$ 但是，你也不要小瞧了λ演算的威力。我们虽然没法构造一个这样的函数，但可以构造一个功能类似的函数： $$ T=\lambda g.\ \lambda h.\ (h\ (g\ f)) $$ 使用这个函数时，需要向里面传入一个常值λ表达式：$(\lambda u.\ x)$ $$ \begin{align*} (T\ (\lambda u.\ x)) &= \lambda h.\ (h\ ((\lambda u.\ x)\ f)) \\ &= \lambda h.\ (h\ x) \\ &= \lambda u.\ (u\ x) \end{align*} $$ ["T", ["λu", "x"]] 如果再把$T$作用到刚刚算得的结果上，就是： $$ \begin{align*} (T\ (T\ (\lambda u.\ x))) &= (T\ (\lambda u.\ (u\ x))) \\ &= \lambda h.\ (h\ ((\lambda u.\ (u\ x))\ f)) \\ &= \lambda h.\ (h\ (f\ x)) \\ &= \lambda u.\ (u\ (f\ x)) \end{align*} $$ ["T", ["λu", ["u", "x"]]] 进一步的，如果作用三次$T$，就会得到： $$ \lambda u.\ (u\ (f\ (f\ x))) $$ ["T", ["λu", ["u", ["f", "x"]]]] 通过归纳法不难得到，在$(\lambda u.\ x)$上作用$n$次$T$，得到的结果就是： $$ \lambda u.\ (u\ (f^{\circ(n-1)}\ x)) $$ 注意到我们在这个表达式里发现了一个$(f^{\circ(n-1)}\ x)$，这就是要求的值！最后一步就是消去函数$u$，一个简单的方法就是将$u$代入单位函数$\text{id}=\lambda v.\ v$即可。 $$ \begin{align*} &(\lambda u.\ (u\ (f^{\circ(n-1)}\ x))\ (\lambda v.\ v)) \\ =& ((\lambda v.\ v)\ (f^{\circ(n-1)}\ x)) \\ =& (f^{\circ(n-1)}\ x) \end{align*} $$ 综合上述结果，我们得到了前驱$\text{pred}$的λ表达式，若传入的$n\gt 0$，那么它返回$n-1$，否则返回$0$： $$ \text{pred}:=\lambda n.\ \lambda f.\ \lambda x.\ ((n\ T\ (\lambda u.\ x))\ \text{id}) $$ [ "PRED", "0" ] [ "PRED", "1" ] [ "PRED", "2" ] 减法 有了前驱运算，减法就不难定义了： $$ (-):=\lambda m.\ \lambda n.\ (n\ \text{pred}\ m) $$ 当然，由于自然数没有负数，假如被减数$m$小于$n$，减法运算的结果就是$0$。 判断 我们可以定义一个函数来判断某个数是不是$0$： $$ \text{iszero}:=\lambda n.\ (n\ (\lambda u.\ F)\ T) $$ 函数$(\lambda u.\ F)$是一个永远返回$F$的常值函数。所以，只要$n\gt0$，$(\text{iszero}\ n)$就会返回$F$。 再加上之前定义的减法，我们就可以定义“大于等于”函数： $$ (\ge):=\lambda m.\ \lambda n.\ (\text{iszero}\ (-\ n\ m)) $$ 再根据大于等于来定义自然数的相等： $$ (=):=\lambda m.\ \lambda n.\ (\land\ (\ge\ m\ n)\ (\ge\ n\ m)) $$ 思考题 你能使用λ演算来定义一个类似C++中std::pair的数据结构吗？ 要求：使用函数 $$ (\text{pair}\ a\ b) $$ 来构造一个对象，并使用$(\text{first}\ p)$和$(\text{second}\ p)$来获取一个pair的第一和第二个值。 你能在这个结构的基础上，用λ演算来定义所有的整数及其相应的数值和逻辑运算吗？ 参考资料 [1] “Lambda Calculus.” Wikipedia, https://en.wikipedia.org/wiki/Lambda_calculus. Accessed 26 Aug. 2022.]]></summary></entry><entry><title type="html">埃氏筛的复杂度计算</title><link href="mqcreaple.github.io/blog/2022/08/18/eto.html" rel="alternate" type="text/html" title="埃氏筛的复杂度计算" /><published>2022-08-18T00:00:00-04:00</published><updated>2022-08-18T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/08/18/eto</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/08/18/eto.html"><![CDATA[<p><strong>埃拉托斯特尼筛法（Sieve of Erastosthenis）</strong>，简称<strong>埃氏筛</strong>，是一种可以在极少时间复杂度内算出$n$以内的所有质数的算法。</p>

<h2 id="0-算法流程">#0 算法流程</h2>

<p>对于一个给定的整数$n$，从2开始执行以下操作：</p>

<ol>
  <li>将该数标记为质数</li>
  <li>将所有该数的倍数标记为“非质数”</li>
  <li>找到下一个不被标记为“非质数”的数，重复步骤1</li>
</ol>

<p>算法的逻辑很简单，代码也极其简短。以C语言为例：</p>

<pre><code class="language-c">int sieve(int n, int *ans) {
    int found = 0;         // 已经找到多少个质数
    bool p[n];             // 标记。0为质数，1为非质数
    
    memset(p, 0, n);       // 清空标记数组
    for(int i = 2; i &lt; n; i++) {
        if(p[i]) {
            // i已经被标记为非质数，跳过
            continue;
        }
        ans[found++] = i;  // i为质数，添加至答案数组中
        for(int j = 2; i * j &lt; n; j++) {
            p[i * j] = 1;      // 将所有i的倍数标记为“非质数”
        }
    }
    
    return found;
}
</code></pre>

<h2 id="1-初步分析">#1 初步分析</h2>

<p>那么这个算法的时间复杂度如何计算呢？</p>

<p>我们不妨追踪一下算法的执行过程：</p>

<ul>
  <li>首先从$2$开始，算法遍历了所有$1$到$n$中$2$的倍数，也就是进行了$\frac{n}{2}$步操作</li>
  <li>接下来找到下一个质数：$3$。算法又遍历了$1$到$n$中$3$的倍数，进行了$\frac{n}{3}$步操作</li>
  <li>再然后，跳过$4$找到下一个质数$5$，遍历了$1$到$n$中$5$的倍数，进行了$\frac{n}{5}$步操作</li>
  <li>……</li>
</ul>

<p>那么最后一共执行了多少步操作？答案是一个无穷级数之和：</p>

<div class="kdmath">$$
\frac{n}{2}+\frac{n}{3}+\frac{n}{5}+\frac{n}{7}+\frac{n}{11}+\cdots
$$</div>

<p>将$n$提出来，并将剩余项写成求和符号，就是：</p>

<div class="kdmath">$$
n\cdot\sum_{p\text{ is prime}}\frac 1{p}
$$</div>

<p>问题来了，后面这个无穷级数怎么求？</p>

<h2 id="2-何为时间复杂度">#2 何为时间复杂度？</h2>

<p>可能大部分人会以为这是一个困难的数论问题，但是不要忘了，计算时间复杂度的时候，只需要考虑<strong>数据趋近无穷的趋势</strong>，而<strong>不用考虑具体数值</strong>。</p>

<p>那么如何定义“趋势”？我们不妨借鉴一下小学二年级的高数知识：</p>

<blockquote>
  <p>如果两个趋近无穷的数列$a_n$和$b_n$满足</p>

  <div class="kdmath">$$
\lim_{n\to\infty}\frac{a_n}{b_n}=c
$$</div>

  <p>其中$c$为一个常数且不为$0$，那么这两个数列称为<strong>同阶无穷大</strong>，记作$a_n \sim b_n$。</p>
</blockquote>

<p>根据同阶无穷大定义时间复杂度的大$O$记号了：</p>

<blockquote>
  <p>对于某个算法，如果它只有一个输入$N$，那么将$N$依次代入从$1$开始的所有自然数，记$t_i$为输入数字$i$时算法的运行时间（或者说“执行的操作数”），那么可以得到一个数列$\{t_N\}$。</p>

  <p>假如存在一个<em>简单表达式</em>$q_N$，使得</p>

  <div class="kdmath">$$
t_N\sim q_N
$$</div>

  <p>那么记这个算法的时间复杂度为$O(q_N)$。</p>
</blockquote>

<p>思考题：根据同阶无穷大的定义，证明：</p>
<ul>
  <li>$O(N^2+2N)\sim O(N^2)$</li>
</ul>

<h2 id="3-无穷级数">#3 无穷级数</h2>

<p>即便有了这样的定义，我们就将问题化解为了：<em>寻找一个简单表达式，使得它和“<strong>所有质数的倒数和</strong>”是同阶无穷大</em>。</p>

<p>在这之前，我们可以使用一个已经被证明过的结论：质数分布是$O(N\log N)$的。记第$n$个质数为$p_n$，则：</p>

<div class="kdmath">$$
p_n\sim n\ln n
$$</div>

<p>从这里还不能完全得出我们想要的结论，但我们已经可以对开头提到的无穷级数进行化简了：</p>

<div class="kdmath">$$
\sum_{n=1}^\infty \frac 1{p_n}\sim \sum_{n=1}^\infty \frac 1{n\ln n}
$$</div>

<blockquote>
  <p>引理1：若$a_n, b_n$均<strong>非负</strong>且为同阶无穷小，即$a_n\sim b_n$，则</p>

  <div class="kdmath">$$
\sum_{n=1}^\infty a_n\sim \sum_{n=1}^\infty b_n
$$</div>

  <p>证明：根据同阶无穷小的定义，可得：</p>

  <div class="kdmath">$$
\lim_{n\to\infty}\frac{a_n}{b_n}=c
$$</div>

  <p>根据极限的$\epsilon-N$定义，对于任给的$\epsilon\gt0$，总存在$N\gt0$，使得所有$n\gt N$都有：</p>

  <div class="kdmath">$$
c-\epsilon \lt \frac{a_n}{b_n}\lt c+\epsilon
$$</div>

  <p>因为$n$可以取任何大于$N$的值，再根据恒等式$\frac{a}{b}\lt\frac{a+c}{b+d}\lt\frac{c}{d}$，可以将所有形如$\frac{a_n}{b_n}$的分式合并而不影响其性质：</p>

  <div class="kdmath">$$
c-\epsilon \lt \frac{\sum_{n=N}^\infty a_n}{\sum_{n=N}^\infty b_n} \lt c+\epsilon
$$</div>

  <p>换句话说，存在$N\gt0$使得</p>

  <div class="kdmath">$$
\frac{\sum_{n=N}^\infty a_n}{\sum_{n=N}^\infty b_n}
$$</div>

  <p>是有限且非0的。</p>

  <p>又因为$\sum_{n=1}^{N-1}a_n$和$\sum_{n=1}^{N-1}b_n$是有限的，所以</p>

  <div class="kdmath">$$
\frac{\sum_{n=1}^{N-1}a_n}{\sum_{n=1}^{N-1}b_n}
$$</div>

  <p>是有限的。</p>

  <p>根据恒等式$\frac{a}{b}\lt\frac{a+c}{b+d}\lt\frac{c}{d}$，可以得到：</p>

  <div class="kdmath">$$
\frac{\sum_{n=1}^{N-1}a_n + \sum_{n=N}^\infty a_n}{\sum_{n=1}^{N-1}b_n + \sum_{n=N}^\infty b_n}=\frac{\sum_{n=1}^\infty a_n}{\sum_{n=1}^\infty b_n}
$$</div>

  <p>一定也是有限且非0的。证毕。</p>
</blockquote>

<p>经过此次化简，至少题目看起来像道代数题而不是数论题了，但无穷级数$\sum_{n=1}^\infty \frac 1{n\ln n}$仍然让人没有头绪。</p>

<blockquote>
  <p>引理2：对于一个<strong>单调函数</strong>$f(n)$</p>

  <div class="kdmath">$$
\sum_{n=1}^\infty f(n) \sim \int_1^\infty f(n)\mathrm dn
$$</div>

  <p>证明：</p>

  <p><img src="/img/eto-0.png" alt="eto-0" /></p>

  <div class="kdmath">$$
\int_1^\infty f(n)\mathrm dn=\sum_{k=1}^\infty \int_k^{k+1}f(n)\mathrm dn
$$</div>

  <p>不妨假设函数$f(n)\gt0$，则$f(n)$单调减。又因为$\lim_{n\to\infty}f(n)=0$，因此：</p>

  <div class="kdmath">$$
\begin{align*}
& \sum_{k=1}^\infty f(k)-\sum_{k=1}^\infty \int_k^{k+1}f(n)\mathrm dn \\
= & \sum_{k=1}^\infty\left[ f(k)-\int_k^{k+1}f(n)\mathrm dn \right] \\
\le & \sum_{k=1}^\infty[ f(k)-f(k+1) ] \\
= & f(1) - 0 \\
= & f(1)
\end{align*}
$$</div>

  <p>也就是说$\sum_{n=1}^\infty f(n)$和$\int_1^\infty f(x)\mathrm dx$之间至多相差常数$f(1)$，又因为两者均不为$0$，那么两者之比一定有限且非$0$。</p>

  <p>证毕</p>
</blockquote>

<p>有了这个结论，我们就能直接得到：</p>

<div class="kdmath">$$
\sum_{n=1}^\infty \frac 1{n\ln n} \sim \int_1^\infty \frac{\mathrm dn}{n\ln n}\sim \ln\ln n
$$</div>

<p>回到最初的问题：</p>

<div class="kdmath">$$
N\cdot\sum_{p\text{ is prime}}p \sim N\sum_{n=1}^\infty \frac 1{n\ln n} \sim N\ln\ln N
$$</div>

<p>也就是说，埃氏筛的时间复杂度是$O(N\log\log N)$级别的。</p>

<h2 id="思考题">思考题</h2>

<ol>
  <li>（简单）请用本文中的定理证明：
<span class="kdmath">$\sum_{n=1}^\infty\frac 1n \sim \ln n$</span></li>
  <li>（困难）请不用本文提到的方法证明题目1</li>
</ol>

<h2 id="参考资料">参考资料</h2>

<p>[1] “Sieve of Eratosthenes.” <em>Wikipedia</em>, <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</a>. Accessed 18 Aug. 2022.</p>

<p>[2] “Distribution of Primes.” <em>Brilliant</em>, <a href="https://brilliant.org/wiki/distribution-of-primes/">https://brilliant.org/wiki/distribution-of-primes/</a>. Accessed 18 Aug. 2022.</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="algorithm" /><category term="math" /><category term="time-complexity" /><summary type="html"><![CDATA[埃拉托斯特尼筛法（Sieve of Erastosthenis），简称埃氏筛，是一种可以在极少时间复杂度内算出$n$以内的所有质数的算法。]]></summary></entry><entry><title type="html">git原理简介</title><link href="mqcreaple.github.io/blog/2022/03/04/git.html" rel="alternate" type="text/html" title="git原理简介" /><published>2022-03-04T00:00:00-05:00</published><updated>2022-03-04T00:00:00-05:00</updated><id>mqcreaple.github.io/blog/2022/03/04/git</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/03/04/git.html"><![CDATA[<p>相信大家都对<a href="https://git-scm.com/">git</a>耳熟能详了。Git是一个简单易用的版本管理工具，用户可以在git中修改文件、提交commit（更新到本地仓库）、同步远程仓库等。本篇文章将主要讨论git更新文件和提交commit背后的原理。</p>

<p>前置知识：git基本操作，详见<a href="https://www.runoob.com/git/">runoob</a>和<a href="https://www.w3schools.com/git/">w3schools</a>。</p>

<h2 id="一些名词">一些名词</h2>
<ul>
  <li><strong>工作区（working tree）</strong>表示除去<code>/.git</code>以外的工作目录，即通常写代码的位置。</li>
  <li><strong>暂存区/索引（index）</strong>是执行完<code>git add</code>指令时文件被添加到的地方。如果没有执行过<code>git add</code>命令，git并不会为你自动保存。</li>
  <li><strong>版本库（repository）</strong>是所有当前暂存区和历史上commit过的文件，暂存区可以看作是版本库的一个子集。所有版本库的文件都保存在<code>/.git</code>目录下。</li>
</ul>

<p>所有的历史文件、文件目录、commmit记录等全部保存为二进制对象，统一保存在/.git/objects目录下，文件名为该文件的SHA-1哈希值且没有后缀。</p>

<ul>
  <li>blob：全称为Binary Large Object，是常规文件保存在<code>/.git/objects</code>下的形式。</li>
  <li>tree：目录文件保存在<code>/.git/objects</code>下的形式。</li>
  <li>commit：commit记录保存在<code>/.git/objects</code>下的形式。</li>
</ul>

<pre><code class="language-plaintext">└── objects
    ├── 41
    │   └── a1d4060cf09286c1cd8fe8bdab89ce26b71086
    ├── ce
    │   └── 013625030ba8dba906f756967f9e9ca394464a
    ├── dc
    │   └── a98923d43cd634f4359f8a1f897bf585100cfe
    ├── info
    └── pack
</code></pre>

<p>上图的文件目录中，三个object的SHA-1值分别为：<code>41a1d4...</code>，<code>ce0136...</code>，和<code>dca989...</code>。</p>

<p>可以使用指令：</p>

<pre><code class="language-shell">git hash-object 文件名
</code></pre>

<p>计算一个文件的SHA-1哈希值。</p>

<h2 id="head指针和commit">HEAD指针和commit</h2>

<p><code>HEAD</code>是一个指针，默认指向当前分支的最新一个commit（存储了commit文件的哈希值）。每一次提交新的commit时，<code>HEAD</code>也会相应前移。<code>HEAD</code>存储在<code>/.git/HEAD</code>文件中。</p>

<p>每一个分支也有各自的head，指向当前分支的最后一个commit，各分支的head存储在<code>/.git/refs/heads/</code>分支名文件中。每一次执行<code>git checkout</code>切换分支的时候，实际上就是让全局的<code>HEAD</code>赋值成了另一个分支的head。</p>

<p>总结一下，现在讲过的<code>/.git</code>目录结构都有：</p>

<pre><code class="language-plaintext">.git
├── HEAD          全局HEAD指针
├── objects
│   └── 二进制对象都在这里
└── refs
    └── heads
        └── 各个分支的head
</code></pre>

<p>除了第一个commit，以后的每个commit都会记录上一个commit的哈希值，这样就形成了一个树形结构。</p>

<p>当整个项目只有一个分支时，所有的commit形成一条链：</p>

<div class="mermaid">
graph RL
A[commit<br />a5e2] --&gt; B[commit<br />3d97]
B --&gt; C[commit<br />9cd6]
C --&gt; D[commit<br />729f]
D --&gt; E[commit<br />4375]
E --&gt; F[......]
subgraph master: head
A
end
</div>

<p>有多个分支时，则是这样的：</p>

<div class="mermaid">
graph RL
A[commit<br />a5e2] --&gt; B[commit<br />3d97]
B --&gt; C[commit<br />9cd6]
C --&gt; D[commit<br />729f]
D --&gt; E[commit<br />4375]
E --&gt; F[......]
subgraph master: head
A
end
G[commit<br />fc6a] --&gt; E
H[commit<br />7032] --&gt; G
subgraph branch1: head
H
end
</div>

<h2 id="文件和目录">文件和目录</h2>

<p>之前说过，blob对象和tree对象都存在<code>.git/objects/</code>目录下。Tree对象存储了其他一系列文件的哈希值，可以理解成是一个多叉树的结点，而一般文件是根节点。</p>

<div class="mermaid">
graph TD
A[[root]] --&gt; B([readme.md])
A --&gt; C([.gitignore])
A --&gt; D[[src]]
D --&gt; E([main.cpp])
D --&gt; F([main.h])
A --&gt; G[[test]]
G --&gt; H([test.cpp])
</div>

<p>暂存区/索引对应着<code>/.git/index</code>文件，它记录了当前暂存的所有文件和目录的哈希值。每一次执行<code>git add</code>指令，程序就会在<code>/.git/objects</code>目录中生成一个对应着该文件的blob对象，同时将这个对象的地址加到<code>/.git/index</code>中。</p>

<p>每一个commit结点指向了一个tree节点，表示某一次commit的根目录。两次commit中不变文件不会被创建新对象。</p>

<p><img src="/img/git-file-0.svg" alt="git-file-0" /></p>

<p>这时，如果我们添加了一个<code>.gitignore</code>文件并且执行<code>git add .gitignore</code>命令，就会创建一个新的blob对象并添加进索引。</p>

<p><img src="/img/git-file-1.svg" alt="git-file-1" /></p>

<p>再接下来提交commit，程序就会新建一个表示根目录的tree对象并且指向所有索引（index）中的文件和文件夹。最后再处理commit结点，将其指向上一次的commit，即完成了git提交，如图：</p>

<p><img src="/img/git-file-2.svg" alt="git-file-2" /></p>

<h2 id="总结">总结</h2>

<blockquote>
  <p>Git的所有对象，包括文件、目录、和commit，全部存储在<code>/.git/object/</code>文件夹下。</p>

  <p>Commit结点指向其上一次的commit，形成一个树形结构，每个叶节点对应一个分支的head。</p>

  <p>全局的<code>HEAD</code>指针指向任意一个commit结点，通常是一个特定分支的head。</p>

  <p>blob对应一般的文件，tree对应文件夹，同一个文件夹下所有文件和文件夹组成一个树形结构，但同一个文件有可能被不同版本的文件夹同时指向。</p>

  <p>每次add文件时，git会生成一个新的blob对象并添加到index中。</p>

  <p>每次进行commit时，git会生成tree对象并令其指向所有的子文件，最后让commit结点指向根目录文件夹，同时设置commit结点的上一个结点，最后完成提交。</p>
</blockquote>

<p>Git的版本管理逻辑和信息竞赛里的“可持久化算法”思想很像，都是尽量避免记录过多重复的内容从而减少空间占用。</p>

<p>Git在文件和目录这个树形结构之上，还有一个“commit”的分支结构，这意味着它可以应对更复杂的需求，但也意味着使用者需要记忆更多的命令。</p>

<p>本文仅是一个简单介绍，没有涵盖诸如分支合并和tag等更复杂的功能，如果以后有时间可以更新。</p>

<h2 id="参考资料">参考资料</h2>

<p>[1] Chacon, Scott and Straub, Ben. “Pro Git v2”. Git, <a href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a>.</p>

<p>[2] Wiegley, John. “Git from the Bottom to Up”. GitHub, <a href="https://jwiegley.github.io/git-from-the-bottom-up/">https://jwiegley.github.io/git-from-the-bottom-up/</a>.</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="git" /><category term="github" /><summary type="html"><![CDATA[相信大家都对git耳熟能详了。Git是一个简单易用的版本管理工具，用户可以在git中修改文件、提交commit（更新到本地仓库）、同步远程仓库等。本篇文章将主要讨论git更新文件和提交commit背后的原理。]]></summary></entry></feed>