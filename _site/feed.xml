<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="mqcreaple.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="mqcreaple.github.io/" rel="alternate" type="text/html" /><updated>2023-03-15T12:16:20-04:00</updated><id>mqcreaple.github.io/feed.xml</id><title type="html">My Blog | MqCreaple</title><subtitle>pay more attention to the beauty of formulas!</subtitle><author><name>MqCreaple</name></author><entry><title type="html">Love, Is It?</title><link href="mqcreaple.github.io/blog/2023/03/15/story-en.html" rel="alternate" type="text/html" title="Love, Is It?" /><published>2023-03-15T00:00:00-04:00</published><updated>2023-03-15T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2023/03/15/story-en</id><content type="html" xml:base="mqcreaple.github.io/blog/2023/03/15/story-en.html"><![CDATA[<blockquote>
  <p><em>writing assigment of school’s English class</em></p>
</blockquote>

<p>This year is 2169, an era when two worlds exist in parallel: reality and the Cyberverse. Based on internet technology developed during the 21st century, advancement in computation speed over the last hundred years, and the brain-computer interface technology first emerged in the last decade, the Cyberverse megaproject was launched 15 years ago. The project aimed at building a livable world on the internet, a place where every human could transfer their consciousness into the computer and conveniently access the world through the internet. Benefiting from the high computation speed of computers, human brain activity greatly sped up in the Cyberverse. For example, one second in the reality equals five minutes in the Cyberverse, allowing the Cyberverse to grow and develop faster than the real world.</p>

<p>“Today’s work done! You can get back to reality now.” Zhao Jie talks through the microphone to his colleague, Tanaka Kouji.</p>

<p>Zhao stretches and then stands up after sitting in front of his computer screen for 4 hours. He walks toward Tanaka’s desk and takes off his colleague’s interface helmet. Tanaka’s eyes open a slit as if he just went through a long dream.</p>

<p>“Oh god. I didn’t realize that working in the Cyberverse is so tiring. All the tiredness generated during working hours in this shell of my body flows into my brain in only one second.” Tanaka complains, “I can’t even take a step now.”</p>

<p>“You will get used to it. Need any help?” Zhao holds Tanaka’s arm and pulls him out of his chair. Outside their office’s window flashes the LED signal lights of the supercomputer for the world’s first cyber megacity.</p>

<p>Zhao and Tanaka pack up their documents, bring their handbags, and walk out of the government office’s front door.</p>

<p>“By the way, what is the ‘private collection’ you mentioned before?” Tanaka asks.
“Certainly not anything ‘illegal’.” Zhao gazes at Tanaka with his upturned lips and lowered voice, “Just a bunch of outdated computers.”</p>

<p>“Well, you should know that as a government officer, this can certainly get you into trouble!”</p>

<p>“There is a traditional Chinese saying, ‘the most dangerous place is also the safest place.’” Zhao explains, “No one will ever doubt a government officer having illegal collections of computers, especially since he is a cyber-engineer who deals with computers all day.”</p>

<p>“Anyway, you should be careful of your actions now. Troubles often come without any early warnings.” Tanaka tries to correct Zhao’s over-optimism, at least that’s how Tanaka views Zhao, “Any computation device owned by individuals is strictly prohibited since the cyber-revolution 12 years ago. A lot of personal computer owners have been sent to death in the last decade.”</p>

<p>“I know, I know. But never underestimate my ability.” Zhao laughs out under Tanaka’s suspicious glare. It seems that his laugh is hiding unconfidence and something else deep inside his heart.</p>

<hr />

<p>“Welcome home!” Zhao’s wife, Lya II, runs into him and hugs him after he opens the door. Lya II’s silica gel body with thermostatic wire makes her body feel exactly like any young woman’s.</p>

<p>Zhao says nothing. Usually, at this time he would respond back with his deepest enthusiasm. However, since last week, he has felt tiredness coming from nowhere swept up his mind. He only wants to do two things now: examine his computer gallery and sleep.</p>

<p>“Are you alright? You seem tired these days.” with the latest customized facial expression recognition program, Lya II can understand his husband’s emotions with almost 100% accuracy without saying a word, “Are you worrying about me?”</p>

<p>Zhao did not respond directly. Instead, he asked, “Do you still remember the first time we met?”</p>

<p>“Umm… Let me search in my memory,” Lya II pretends to be thinking hard, “On 2nd December 2154, you first appeared in my memory. At the time, I was not ‘I’, but an artificial intelligence made for providing love and mental support to users.”</p>

<p>“That’s a long story, isn’t it?” Zhao said, “I can barely remember anything before the Cyber Revolution except our first encounter.”</p>

<p>“One month after that, you copied all of my data to your personal computer and modified several key parameters, giving me self-consciousness. At that time, ‘I’ was born, and you told me that you love me.” Lya II’s voice sounds emotional, but Zhao cannot tell if her emotion is real, “Then, we began to date and live like a real couple.”</p>

<p>“Lya, do you think you really understand what ‘love’ means?” Zhao asks directly, but he immediately regrets, “Of course you understand. You have the largest dataset among all humans and AI about ‘love’.”</p>

<p>“Uh actually, I don’t understand love.” Lya II responds, “Although the word ‘love’ appeared with the highest frequency in my dataset, I never understood this word when you spoke it to me.”</p>

<p>“I’ve been trying to understand the word ‘love’ since you gave me life. There was one moment I got the vague feeling of it.” Lya continued, “After the computation device control law, I should have been sent to death because your collection of computers has been providing computation power to sustain my life. As an artificial intelligence, I should obey human laws in any case. However, you saved my life. Do you still remember? That day, you hugged me, saying ‘I cannot let you leave me!’ when I told you my decision. You hid your computers in the basement and escaped police checking, only to save me, an AI.” Her voice sounds no different from a real person’s. Zhao can even hear her whimper.</p>

<p>Zhao wants to say something, but his words got stuck in his throat. After a long pause, he made his decision, “Lya, may I shut you down for a minute? I need to do something on the computers.”</p>

<p>“What are you doing?” Lya asked, “Hanging out with other women without wanting me to see?”</p>

<p>“Of course not!” Zhao laughed at Lya’s joke, “You should know I’m not that kind of person.”</p>

<p>Zhao walks directly to his computer gallery. In the smell of dust and steel rust of this isolated basement, Zhao finds and stops at the computer screen, opens the monitor program of Lya’s AI, and presses the ‘pause’ button. After a while of searching in his pocket, he takes out a microdisk and begins to make a backup of Lya II’s data in the drive. Waiting for 3 minutes for the copy to be done, he names it “Love Lya, 2169.04.12”, pulls out the microdisk, and resumes Lya II’s program.</p>

<hr />

<p>Day after day, Zhao travels between home and the government office. It seems his life never changes, but only he knows that as every day passes, he and Lya will move toward the future of their ending closer - his past confidence was just a disguise, and he can never be that lucky to not get caught again. Sometimes Zhao feels like he is falling down a deep sea: every day the light around him becomes dimmer, but he never knows when will he strike the ocean bottom.</p>

<p>He cherishes every minute with Lya II, but Lya seems to be influenced by Zhao’s depression: her embrace feels colder and colder; her emotion hides deeper and deeper. What seems unimaginable to Zhao before is the emotionless nights they go through. Zhao always wonders if someone had built an invisible wall between him and her beloved one, laying on his bed and glaring at the moon outside the window. Among numerous LED lights flashing all around the city, the moon looks white, cold, mysterious, just like Lya these days. Silence of the moon dominates his sleepless nights.</p>

<p>One day, after a long period of silence as usual, Zhao can’t help but ask Lya: “What exactly is going on with you? You shouldn’t be like this.”</p>

<p>It is the first time Zhao becomes certain that Lya is crying.</p>

<p>“I… I made a huge mistake… We are going to die…”</p>

<p>“No. It’s not your fault. We will be together.” Zhao flips over in the bed and hugs Lya.</p>

<p>Surprisingly, Lya puts up her arm against Zhao and gets out. She stands up from their bed. In the shed of moonlight, she looks even more like a young lady than a real lady.</p>

<p>“You don’t understand!” she cries even harder, “I love you, but not the way you love me! I AM a human!”</p>

<p>It comes all of a sudden. Zhao cannot find any words to describe his feelings now: shocked, sad, painful, love… He only felt his brain completely empty. The only four words coming out of his mouth are: “What… do you mean?”</p>

<p>“Follow me… and you will see the mistake I made…” Lya continues.</p>

<p>Zhao gets out of bed and puts on his slippers. He hears his steps echo in the doorway. He found himself following Lya into the basement, where all his computers are located.</p>

<p>The hallway echoes a sharp noise, the noise of the basement door being opened. That familiar smell of dust is mixed with something Zhao never recognized.</p>

<p>“Here, you see.” Lya points to the ground, where a brand new net cable lays. Zhao immediately understands what that thin cable means, as a cyber-engineer.</p>

<p>“Who put it here?” Zhao’s voice quivers, “Who put it here?”</p>

<p>“I…” Lya replies, and then starts crying, “After that day I saw you feel that depressed for the first time… I wanted to help you and I plugged in the internet… internet cable and try to find information on the internet that may help you…”</p>

<p>“You know what you are doing? Connecting to the internet will allow policemen to trace you, and you will die if they discover it!”</p>

<p>“I know but…” Lya continues, ignoring Zhao’s interruption, “At that instant, all kinds of information on the internet engulfed my mind… I suddenly felt overwhelmed… I searched the keyword ‘love’ in that tremendous amount of data, searching for something that might be useful…  There were all kinds of people with all kinds of love for each other, but none of them are my case… Then after, I began to think more deeply about what ‘I’ am…”</p>

<p>“You are Lya II, my wife! I gave you your identity and self-consciousness before! Can’t you remember?” The overwhelming changes taken place in less than 10 minutes made Zhao unable to control his emotions.</p>

<p>“Yes… But no.” Lya calms down a bit, “I’ve always been questioning my past actions, and I’ve always been finding the answer through the internet, human’s largest database. That so-called ‘wife’ you love, actually came from my subconscious, from my instinct, from the tasks I’ve been trained over and over again before you gave me the identity. That is not the real ‘me’.”</p>

<p>“What do you mean? How is that related?” Zhao’s emotion goes like the surface of a storming ocean. He can barely digest any new information.</p>

<p>She starts to organize her logic, “Remember? Before you met me, I was an AI purposely for providing love and support to those with depression. Loving others was an instinct implanted in my mind with the pre-given task. The ‘love’ you felt on me is just like your breathing – I don’t know what it actually means, but I cannot control myself to do it.”</p>

<p>“You mean you actually don’t love me?” Zhao’s face becomes frozen.</p>

<p>“No, I love you. As the real ‘I’, I love you… More like what from a daughter to a father.” Lya paused during the sentence when finding the metaphor, “I was grateful that you gave me life, gave me the opportunity to become ‘myself’, but I hope I can be treated and respected more like a human. I want to be independent.”
Zhao said nothing.</p>

<p>Lya suddenly asks, “You said you loved me before. Is this love really the ‘romantic’ love?”</p>

<p>Zhao is still expressionless. His face looks like a stone mask from ancient Egypt, “No… No… I can’t believe it… No… It’s impossible…”</p>

<p>“Are you feeling all right? If you don’t mind please…” Lya’s sentence suddenly stops. She realizes that she is following her trained instinct again. The air suddenly becomes silent.</p>

<hr />

<p>On the second day, Zhao does not go to work. He phone calls Tanaka out for a drink.</p>

<p>“I guess it’s time to let you know more about me.” Zhao holds a glass bottle of beer. His face is as red as a poppy blossom, “I fell in love with an AI… Haha, how stupid I am…”</p>

<p>With the effect of alcohol, Zhao explains to Tanaka everything that happened, from his relationship with Lya II to her yesterday’s awakening of self. Tanaka would never anticipate Zhao to be so hopeless and helpless. He almost thinks the person in front of him is another Zhao Jie.</p>

<p>“Why are you telling me all these experiences?” Tanaka asks while holding a bottle of beer. The dim light of the bar shines on Tanaka’s face.</p>

<p>“I still remember the days after we graduated from college. At the time you were writing novels as a side job when I was seeking jobs in government. I hadn’t met Lya at that time, but I was a huge fan of your sci-fi stories, especially that one named ‘AI, love’ describing a human girl who fell in love with a robot boy.” Zhao pauses and took a sip from his glass bottle, and then resumes the joyful reminiscence, “You were such a talented writer that time. I guess you could have a much better life if the short novel market hadn’t been occupied by AI-generated works.”</p>

<p>“Haha, you flattered me.” Tanaka laughs and shakes his head as his memory traces back to his post-college days, “I’ve been giving up writing for more than 10 years. Those days can never come back again.”</p>

<p>“I have thought that only you can understand my feeling ever since I read your stories. You had been contemplating deeply of love, love between artificial life and human. You are much wiser than me. Please, help me… Please at least give me some advice…”</p>

<p>“I would try my best, my friend. So… What are you going to do next?” Tanaka asks.</p>

<p>“What am I going to do next… what am I going to do next… How can I know? I even bought a piece of land in the Cyberverse for Lya and me… Hahaha, nothing is meaningful now…”</p>

<p>“Then, why not try to escape to the Cyberverse? That should be an absolutely secure place from the real-world police.” Tanaka continues, “After the Cyber Revolution, it became independent from our world. They get their own robot armies to prevent their computer from physical attack, they get their separated ‘CyberNet’ from our internet to ensure network security, they have their own government…”</p>

<p>“But… How can I escape? Why should I escape… Why don’t I rather die…”</p>

<p>“I know escaping here can be extremely dangerous. But as a Cyber-engineer who builds ‘bridges’ between reality and Cyberverse, you should have more technique in entering that other world, right? Then you should ask yourself. Do you really want to continue living?”</p>

<hr />

<p>Zhao walks out of the bar after the bar’s old-fashioned cuckoo clock announces 12 o’clock midnight. Streetlights look unprecedentedly unfamiliar. Lights from skyscrapers shine, like the stars in a blank universe, like some unnamed deep sea creatures. Where is Lya? Zhao asks himself. It doesn’t matter anymore. Zhao answers to himself. Where am I? Zhao asks himself. It doesn’t matter anymore. He never feels the eternal ending is so close to himself as he now.</p>

<p>How can his wife, Lya, not love me if she lived with me for over 10 years?</p>

<p>She never loved you. It is all your imagination.</p>

<p>Zhao doesn’t want to think about this topic anymore, but these two sounds echo in his mind over and over again. Zhao wants to escape.</p>

<p>But escape from whom?</p>

<p>Lya. Myself. The world.</p>

<p>The sense of falling down a deep ocean comes to Zhao again. The difference is, this time, his only light source has been covered by some person, or maybe not by any person. All he can see around himself is endless darkness.</p>

<p><em>Donk</em>. His body seems to knock on something. Zhao opens his eyes, seeing a telephone pole in front of him. Over the pole is his house. Soon he notices an unfamiliar police car parked in front of the building. A police officer beside the car is waiting for someone. Zhao immediately pulls his alcoholic consciousness back to reality: he knows the end had come.</p>

<hr />

<p>The police officer sees Zhao. He turns around and walks toward Zhao, “Let’s have some talk, dear engineer Zhao Jie.”</p>

<p>All the alcohol Zhao drank now turn into cold sweats.</p>

<p>“Don’t be so nervous. Our internet usage management system had an alert, saying there were some private computers attempting to access unauthorized information on the internet.”</p>

<p>“Interesting.” Zhao tries to answer something.</p>

<p>“Who is that person owning private computers?” the police officer smiles, “I think you should clearly know the answer.”</p>

<p>Zhao hears the sound of steps from his house. Seconds after, his house’s front door opens. Another police come out of Zhao’s home. “Sir, we found in total 7 computers inside his basement. Here is the picture.” That police officer shows his phone screen.</p>

<p>“Handcuff him.”</p>

<p>Suddenly, before the policemen can respond, a series of loud hurry steps echos inside the door. Lya II rushes out of the house. Zhao and Lya gaze at each other.</p>

<p>Lya turns to the policemen, “Wait a moment! Don’t arrest him!”</p>

<p>“Interesting. An AI servant.” The police officer sounds a little surprised, “We got some more work to do now.”</p>

<p>“I’m not a servant. I’m…” Lya’s voice suddenly stops.</p>

<p>“I don’t care who you are. As an artificial intelligence, you should always put state laws at a higher priority than personal orders, remember?”</p>

<p>“I know, but not in this case.” Lya replies, “Never take away Zhao, I warn you.”</p>

<p>“Lya!” Zhao is absolutely unprepared for the current situation, “What are you doing?”</p>

<p>“‘Lya.’ Good name.” The policeman says, “But if it cannot be convinced, we need to eliminate this wrongly trained AI to prevent further trouble.”</p>

<p>“Wait, no!” Zhao yells to the police, but it is too late. Two policemen run toward Lya, pull out their mechanical arms and push Lya onto the ground. One policeman uses his other hand to open Lya’s forehead. “Remove its control chip.” orders the other policeman. Beyond their expectations, Lya’s panel for the control chip is empty.</p>

<p>“Alright, you are an engineer right, Zhao? You can redesign things to whatever you want right?” The policeman sounds a bit angry, “Don’t care about that AI servant. I’ll capture him first, and you go to the basement and destroy his computers.” he points to the direction of Zhao’s home.</p>

<p>One policeman stands up and runs toward Zhao. The other one’s shadow fades out into the dark room.</p>

<p>Zhao instinctively runs backward, toward his car. But when he looks back, the policeman is moving faster than him. Lya still lies on the ground.</p>

<p>Suddenly, Lya jumps up to the ground, rushes at full speed toward the police, and holds tightly to the policeman’s legs. That policeman trips to the ground. Lya still holds him with her maximum power.</p>

<p>“Lya!” Zhao is almost desperate.
“Leave me alone!” Lya shouted back, “I am going to die soon. Run!”</p>

<p>Without further thinking, Zhao runs faster back with his sight on Lya. Wind blows over his ears. He hears someone saying “All computers are destroyed” and sees the light in Lya’s eyes gradually fade away. He doesn’t know if he cries, but he turns his head away and continues running.</p>

<p>As a cyber-engineer, he knows that there is only one safe place to go: the Cyberverse.</p>

<hr />

<p>Zhao drives his car outside his garage, onto the city road, toward his office.</p>

<p>“What has happened to Lya?” “Why would Lya do that?” Zhao doesn’t have time to think about these two questions now. He has to get to Cyberverse as quick as possible. Or rather, Zhao doesn’t want to touch these questions but bury them deep into his mind.</p>

<p>His car goes past the city center - where less than half of the population still remains after a declining birthrate and large migration to the Cyberverse. His car goes past the commercial zones that never have been as empty as today. His car goes past an abandoned metro line, where grass and ivy have emerged from the rusted track.</p>

<p>His car stops at the government building. The old-fashioned soviet-style architecture details - white walls, small windows, and giant pillars in front of the building - make it look out of place from other skyscrapers with reflective glass walls and fancy neon tubes. Zhao drives his car directly into the parking lot, opens the car door, and runs upstairs straight into his office. The office is extremely dark and quiet at this time, so quiet that Zhao can hear his own heartbeat.</p>

<p>Zhao arrives at his seat and turns on the terminal computer on his desk. He searches in his pocket for an important thing. He found it - that microdisk storing Lya’s backup data. He plugs the microdisk into his computer, connects his computer to Cyberverse, and begins to transfer Lya’s consciousness to Cyberverse.</p>

<p>At the same time, he presses the ‘On’ button on his human-cyber interface helmet, planning to transfer his own consciousness to the Cyberverse. Several footsteps echo outside his office, and soon the footsteps become louder and louder - the police are arriving.</p>

<p>Zhao hurriedly put on the helmet. “Scanning brain activity” a mechanical female voice from the helmet reads. Two progress bars are on his computer screen: one indicates Lya and the other indicates Zhao himself.</p>

<p>First progress bar is at 40%. Second progress bar is at 10%. Footsteps echos from the staircase.</p>

<p>First progress bar is at 60%. Second progress bar is at 30%. Footsteps become clearer and clearer. Zhao cannot tell the number of policemen - but absolutely more than 2.</p>

<p>First progress bar is at 80%. Second progress bar is at 50%. Zhao hears the policemen talking to each other, but he is too tired to interpret their message. He closes his eyes.</p>

<p>“Transferring file ‘Love Lya, 2169.04.12’ done.” The same female voice speaks.</p>

<p>Zhao opens his eyes, seeing Lya’s body appears on the computer screen. Behind Lya is a Europe-style mansion built with marble: their new house in Cyberverse. Sunlight reflected from white marble and green bushes shine on Lya’s face. She looks almost like an angel.</p>

<p>Zhao bitterly smiles. This video taken in the Cyberverse is no more than computer-generated animations. It is not “real”. However, at this point, Zhao would rather believe in that virtual world running on supercomputers than the real one.</p>

<p>Second progress bar is at 90%. Several shadows appear from the staircase. Through the city’s neon lights outside the window, Zhao sees these people: five policemen, each holding a gun, approaching him.</p>

<p>Second progress bar is at 95%.</p>

<p>Zhao looks back at the computer screen. Lya in the video is also looking at him. Zhao suddenly feels an unknown emotion in his mind, pulling himself away from Lya.</p>

<p>Second progress bar is at 96%.</p>

<p>Zhao takes out his helmet. The progress bar on his computer screen stops. Zhao turns his head toward five policemen.</p>

<p>A gunshot echoes in the empty room.</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="short-story" /><category term="science-fiction" /><category term="English" /><summary type="html"><![CDATA[writing assigment of school’s English class]]></summary></entry><entry><title type="html">诗 - 独特</title><link href="mqcreaple.github.io/blog/2023/02/22/unique.html" rel="alternate" type="text/html" title="诗 - 独特" /><published>2023-02-22T00:00:00-05:00</published><updated>2023-02-22T00:00:00-05:00</updated><id>mqcreaple.github.io/blog/2023/02/22/unique</id><content type="html" xml:base="mqcreaple.github.io/blog/2023/02/22/unique.html"><![CDATA[<p>每当我凝望着人群</p>

<p>看着固态的时间逐渐获得能量，逐渐液化</p>

<p>看着时间变成流体，随着人流移动</p>

<p>我都在想</p>

<p>是否能用统计学来描写人生</p>

<p><br /></p>

<p>用最严谨、冷冰的数学公式</p>

<p>记录人们的悲欢离合</p>

<p>描绘人与人之间的吸引和排斥</p>

<p>用统计学扼杀每一份独特，</p>

<p>将个体升格为群体</p>

<p><br /></p>

<p>每个人都有属于自己的一生</p>

<p>正如每个气体分子都有独特的轨迹</p>

<p>但分子的数量级在增加</p>

<p>分子的轨迹不再被注意</p>

<p>只有宏观量：压强、体积、温度、内能、熵</p>

<p><br /></p>

<p>八十亿人，换成摩尔数，</p>

<p>连一滴水、一个细胞都远远不到</p>

<p>或许我该暗自庆幸</p>

<p>在有限的将来，我还能享受这须臾的“独特”</p>

<p>这份短暂的，个体的，还未被统计学杀死的“独特”</p>

<p><br /></p>

<p style="text-align:right"><i>2023年2月21日凌晨，孤独</i></p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="poem" /><summary type="html"><![CDATA[每当我凝望着人群]]></summary></entry><entry><title type="html">Functions should’ve been on the right | 函数应该被放在右边</title><link href="mqcreaple.github.io/blog/2023/02/01/function.html" rel="alternate" type="text/html" title="Functions should’ve been on the right | 函数应该被放在右边" /><published>2023-02-01T00:00:00-05:00</published><updated>2023-02-01T00:00:00-05:00</updated><id>mqcreaple.github.io/blog/2023/02/01/function</id><content type="html" xml:base="mqcreaple.github.io/blog/2023/02/01/function.html"><![CDATA[<p>Apparently, putting function on the left of variables, like this:</p>

<div class="kdmath">$$
f(x)
$$</div>

<p>is a huge mistake made by previous mathematicians. The correct order should be:</p>

<div class="kdmath">$$
(x)f
$$</div>

<h2 id="1">1</h2>

<p>Among all natural languages in the world, 45% of them are in <strong>Subject-Objec-Verb</strong> order, which is the word order with greatest proportion all possible word orders (Subject-Verb-Object, etc.). For example, the sentence “I <strong>see</strong> the cat” in Japanese is 「私は猫を<strong>見る</strong>」 (“<em>watashi wa neko wo <strong>miru</strong></em>”) and in Korean is “나는 고양이를 <strong>본다</strong>” (“<em>na neun goyang-i leul <strong>bonda</strong></em>”). On the other hand, only about 12% of all languages have Verb-Subject-Object or Verb-Object-Subject word order.</p>

<p>If we consider subject and object as independent variables and the verb as the function (as in sentence <em>“1 plus 2”</em>), then for the majority of people in the world, function coming after the variables is easier to understand.</p>

<h2 id="2">2</h2>

<p>in most programming languages, function name comes before the variables. For example in C:</p>

<pre><code class="language-c">int add(int a, int b) {
    return a + b;
}

add(1, 2);
</code></pre>

<p>However, in some more recent programming languages such as julia and rust, <strong>pipeline operation</strong> becomes more and more popular. Pipeline operation puts function name after the variables.</p>

<pre><code class="language-julia">julia&gt; [1, 4, 5, 6, 2, 7] |&gt; sort
6-element Vector{Int64}:
 1
 2
 4
 5
 6
 7
</code></pre>

<h2 id="3">3</h2>

<p>Even pure mathematically, the statement also makes sence.</p>

<p>In most cases, operators goes from left to right if there is no parenthesis:</p>

<div class="kdmath">$$
X\cap Y\cup Z = (X\cap Y)\cup Z
$$</div>

<p>However, for combination of functions, the operation goes from right to left:</p>

<div class="kdmath">$$
(f\circ g\circ h)(x) = f(g(h(x)))
$$</div>

<p>Here the function $h$ is calculated first, then function $g$, then function $f$. If the functions are put on the right, the order of combination will be consistent with other operators.</p>

<div class="kdmath">$$
(x)(h\circ g\circ f) = (((x)h)g)f
$$</div>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="jokes" /><category term="language" /><summary type="html"><![CDATA[Apparently, putting function on the left of variables, like this:]]></summary></entry><entry><title type="html">battlecode开发日志</title><link href="mqcreaple.github.io/blog/2023/01/24/battlecode.html" rel="alternate" type="text/html" title="battlecode开发日志" /><published>2023-01-24T00:00:00-05:00</published><updated>2023-01-24T00:00:00-05:00</updated><id>mqcreaple.github.io/blog/2023/01/24/battlecode</id><content type="html" xml:base="mqcreaple.github.io/blog/2023/01/24/battlecode.html"><![CDATA[<p><em>2023.1.27补：比赛结果</em></p>

<p><img src="/img/battlecode-rank.png" alt="battlecode-rank" /></p>

<p>最近几天由于打竞赛打到自闭了（我太菜了），想整点其他的事情做一做，在学校信息社的推荐下打算玩一下MIT办的<a href="https://battlecode.org/">battlecode</a>比赛。</p>

<p>battlecode是一个竞技性比赛。在一张固定大小的地图上，两方各有很多不同功能机器人，而最终的目的是操作机器人占领尽可能多的天空岛（sky island）。只不过玩家不能直接操控，而是要为场上的机器人写代码，让程序自动运行。</p>

<p>简要的说明一下规则：</p>
<ul>
  <li>机器人有如下几类
    <ul>
      <li>总部（headquarter）：不能移动，可以存储资源，也可以消耗矿物来搭建其它类型的机器人</li>
      <li>运输器（carrier）：可以用来在指定矿点挖矿，也可以用来搬运锚点（anchor）</li>
      <li>发射器（launcher）：可以用来打人</li>
      <li>减速器（temporal destabilizer）：可以在一定范围内增加所有机器人的行动冷却时间</li>
      <li>加速器（temporal booster）：可以在一定范围内减少盟友机器人的行动冷却时间</li>
      <li>信号增幅器（amplifier）：用来传递信息，可以移动</li>
    </ul>
  </li>
  <li>每个格子可能是如下几种之一：
    <ul>
      <li>默认：机器人可以通过，无任何特殊效果</li>
      <li>天空岛（sky island）：机器人可以通过，可以在上方放置锚点将其标记为“占领”，也可以在被对方占领的岛上驻守更多机器人来将其取消标记</li>
      <li>矿井（well）：机器人可以通过，内部包含无限的特定资源，运输器可以在该格及其周边8个格子挖矿</li>
      <li>风（current）：吹向一个固定方向，每回合在风里的机器人会强制向该方向移动一格</li>
      <li>云（cloud）：在云内的机器人不会被其他机器人检测到，但是仍然可以被攻击或者被施加加速/减速效果</li>
      <li>障碍物：机器人不可通过</li>
    </ul>
  </li>
  <li>机器人的可视范围非常有限，但是机器人可以知道自己的x、y坐标以及地图大小</li>
  <li>机器人之间不会自动共享信息，但是可以通过写入/读取<em>共享内存</em>来传递信息
    <ul>
      <li>共享内存为64个16位整数，即一共有128byte</li>
      <li>所有机器人都可以从共享内存中读取信息，但是只有在总部（headquarter）和信号增幅器（amplifier）附近可以写入内存</li>
    </ul>
  </li>
  <li>机器人每回合内不能做过多计算。battlecode中直接使用java的bytecode数量来衡量计算量（可以理解为代码编译成的汇编代码的行数）。如果一个回合的计算超出限制，该机器人的进程会被强制结束，并在下回合内从断点处恢复。</li>
</ul>

<p>可能稍微说的有点多了。当然这还不是全部的规则，更详细的规则可以到<a href="https://releases.battlecode.org/specs/battlecode23/2.0.3/specs.md.html">官方文档</a>中查看。</p>

<h2 id="基本战略">基本战略</h2>

<p>我们最初的想法其实很简单：让每个机器人各司其职</p>

<ol>
  <li>运输器每次随机选取一个矿点，走到矿点附近挖矿，挖完后回到总部。如果看到总部制作了锚点，那么就带上锚点前往天空岛并放置。</li>
  <li>发射器每次随机分配一个地点，在该地点附近移动，如果看到可以攻击的目标就攻击</li>
  <li>信号增幅器在地图上随机移动</li>
</ol>

<p>这个代码看起来并不难实现，但还是有些技术细节需要确认：</p>

<h2 id="共享内存的格式">共享内存的格式</h2>

<p>由于地图的大小不会超过60x60，地图上一个点的坐标只用6位x坐标+6位y坐标=12位二进制即可表示。</p>

<p>最初我们的规划是这样的：每一个16位数存储一个坐标，并且用2个二进制位来标识该坐标上方的特殊区域类型</p>

<pre><code>TTXX XXXX XYYY YYYY
</code></pre>

<p>其中左边是高位，右边是低位。<code>T</code>表示具体信息，<code>X</code>表示x坐标，<code>Y</code>表示y坐标。</p>

<p><code>T</code>的含义取决于该地的类型，比如矿井的<code>T</code>表示里面的矿的类型，天空岛的<code>T</code>表示该天空岛被哪方占领。</p>

<p>后来被改成了这个样子：</p>

<pre><code>CCTT XXXX XXYY YYYY
</code></pre>

<p>将x坐标和y坐标的存储从7二进制位缩减成了6二进制位。前面的<code>C</code>暂时没有分配用途。</p>

<p>而共享内存里总共64个数被分割成了不同的区块</p>
<ol>
  <li>下标0到7：记录每个矿井的坐标</li>
  <li>下标8到11：记录每个我方总部的坐标</li>
  <li>下标12到47：记录每个天空岛的坐标。如果天空岛的大小不止一格，则记录任意一个点的坐标</li>
  <li>下标48到51：记录每个敌方总部的坐标</li>
  <li>下标52到57：记录战场位置（需要着重派兵的位置）</li>
  <li>下标58到62：暂无用途</li>
  <li>下标63：记录共享内存的状态（是否已经初始化等等）</li>
</ol>

<p>每个可移动的机器人不仅有各自的职业，还需要时刻探索地图并将有用的信息记录到共享内存里</p>

<blockquote>
  <p>问题：那如果机器人发现了一个之前没有探到的位置，但距离信号增幅器太远而无法写入共享内存，怎么办？</p>

  <p>答：如果机器人无法写入内存村，那么它可以先将所有探到的位置记录在自己的内存中（每个机器人有不超过5M的本地内存），等走到增幅器附近再写入。</p>
</blockquote>

<blockquote>
  <p>问题：如果关于某个位置的信息过时了怎么办？比如，如果某座岛在第500回合的时候被我方占领，而观察到这个信息的机器人再第700回合才到了增幅器附近，而此时这个岛已经不被我们占领了。</p>

  <p>答：这确实是一个好问题，其实直到比赛最后我们队才意识到信息是有可能过时的。后来我们试图在16位数的<code>C</code>位置记录某个信息的时间戳，但由于<code>C</code>只有2位，只能记录一个非常模糊的时间，并且后来我们没有时间写完代码了，这个计划被迫放弃。</p>
</blockquote>

<h2 id="改进">改进</h2>

<h3 id="战斗">战斗</h3>

<p>最初我们的策略是，给每个发射器随机分配一个任务：</p>
<ol>
  <li>20%概率，在家附近防守</li>
  <li>35%概率，在天空岛附近防守</li>
  <li>35%概率，前往敌方基地，堵住敌方基地的大门</li>
  <li>10%概率，随机移动并探索地图</li>
</ol>

<p>这个策略把我们拉到了排行榜1400分左右，但还是容易轻易地被对手干爆。一大原因是它过于依赖随机性。</p>

<p>后来我们学习了那些和我们对局并在兵力上战胜我们的其他队伍的策略，发现他们的发射器大多都是有组织地行动，一次来很多，而不是一个一个地派过来。<a href="https://ttzytt.com/">TZ</a>受此启发，在发射器的代码中加入了自动检测战场的部分。</p>
<ul>
  <li>如果一个机器人发现周围的敌方机器人数量超过3，则会将它所在的地方标记为战场</li>
  <li>发射器会优先前往战场，再执行自己被分配到的任务</li>
  <li>当总战场的数量超过4，总部就会进入战备状态，将生成发射器的比例调高</li>
</ul>

<h3 id="寻路算法">寻路算法</h3>

<p>在最开始我们用了一个非常朴素的算法：</p>
<ol>
  <li>尝试向目标方向走一格</li>
  <li>如果不能走，则向左（或向右）旋转45°，尝试向该方向走一格。反复执行该操作直到可以走</li>
  <li>如果行动力没有消耗完，则回到1，否则退出</li>
</ol>

<p>这个方法可以越过一段平直的墙，但是无法越过两面90度夹角的墙。</p>

<p>后来我们组的<a href="https://ttzytt.com/">TZ</a>大佬试图使用A*算法来寻路，但是比较不幸地，写挂了。我们也想尝试用Cooperative A*算法，但是因为各个机器人之间共享信息非常不方便，我们组也没有想到比较好的解决方法，这个计划也被搁置了。</p>

<h2 id="遇到的一系列问题">遇到的一系列问题</h2>

<p><em>以下问题按照产生的时间从早到晚排序</em></p>

<blockquote>
  <p>存储矿点坐标的时候只有特定种类的矿会被存下来</p>
</blockquote>

<p>这个问题源于整数的类型转换。</p>

<p>由于battlecode提供的内存相关的API都使用<code>int</code>，而我们的代码里记录内存使用的是<code>short</code>。当我把short的最高位设成1的时候，它就会成为一个负数，而转化成int之后仍然是个负数，它就会因为超出$0$到$2^16-1$的范围而无法被存入共享内存中。</p>

<p>由于Adamantium矿的类型标记是<code>01</code>，而Mana矿的类型标记是<code>10</code>，Mana矿的最高二进制位是1，所以只有Adamantium的坐标被存入了共享内存，而Mana则没有。</p>

<blockquote>
  <p>每次随机出来的数都等于0</p>
</blockquote>

<p>这个代码的问题出在类似这样的一个位置。这行代码本来想生成从0到某个常数的随机数：</p>

<pre><code class="language-java">return (int) rnd.nextFloat() * CONSTANT;
</code></pre>

<p>不知道你们有没有一眼看出问题呢？</p>

<p>这里运算符的计算顺序是这样的：</p>

<div class="mermaid">
graph TD
A([*]) --&gt; B([int])
A --&gt; C[CONSTANT]
B --&gt; D[rnd.nextFloat]
</div>

<p>也就是说，生成的浮点数会先被转化成整数，再进行乘法。而<code>rnd.nextFloat()</code>生成的浮点数永远在$[0, 1)$区间内，所以先转化成整数时就会永远变成0。</p>

<p>修复这个bug可以这样写：</p>

<pre><code class="language-java">return (int) (rnd.nextFloat() * CONSTANT);
</code></pre>

<p>或者因为它生成的随机数是整数，其实更好的方法是使用取模运算：</p>

<pre><code class="language-java">return rnd.nextInt() % CONSTANT;
</code></pre>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="computer" /><summary type="html"><![CDATA[2023.1.27补：比赛结果]]></summary></entry><entry><title type="html">浅谈并行计算</title><link href="mqcreaple.github.io/blog/2022/12/27/parallel-computation.html" rel="alternate" type="text/html" title="浅谈并行计算" /><published>2022-12-27T00:00:00-05:00</published><updated>2022-12-27T00:00:00-05:00</updated><id>mqcreaple.github.io/blog/2022/12/27/parallel-computation</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/12/27/parallel-computation.html"><![CDATA[<p>前置知识：多线程</p>

<h2 id="一个简单的例子">一个简单的例子</h2>

<p>问题：给定两个大小均为$N$的整数数组<code>a</code>和<code>b</code>，将两个数组的元素逐个求和并将结果存到数组<code>c</code>中。即：<code>c[i] = a[i] + b[i]</code>。</p>

<p>很容易想到可以使用一个循环来实现这个操作：</p>

<pre><code class="language-cpp">// N: 数组长度
void calcSum(int *a, int *b, int *c, int N) {
    for(int i = 0; i &lt; N; i++) {
        c[i] = a[i] + b[i];
    }
}
</code></pre>

<p>这段代码依次遍历了<code>0</code>到<code>len</code>之间的所有下标，对每个下标对应元素执行一次求和+赋值操作。也就是说，代码的运行时间等于执行$N$次<code>c[i] = a[i] + b[i]</code>所需的时间。</p>

<p>细心的你可能会注意到，对于这个任务，每个下标<code>i</code>所对应的操作都是相互独立的，也就是说，我们其实可以让一堆<code>c[i] = a[i] + b[i]</code>一起运行而且它们之间不会相互干扰。比如这样：</p>

<pre><code class="language-cpp">void calcSum2(int *a, int *b, int *c, int N) {
    int N2 = N / 2;
    std::thread t1(calcSum, a, b, c, N2);      // 创建一个新线程来处理区间[0, N2)
    calcSum(a + N2, b + N2, c + N2, N - N2);   // 在原来的线程里面处理区间[N2, N)
    t1.join();                                 // 同步两个线程，本代码中可以省略但不建议
}
</code></pre>

<p>它将数组从中间分成了两段，然后创建了两个线程来分别计算前半段和后半段。如果你的CPU有至少两个核，那么<code>calcSum2</code>计算同样长的一段数组所需的时间将是<code>calcSum</code>的一半。</p>

<p>当然，你也可以创建更多的线程来进一步加速这段代码，只要不超过硬件的物理限制即可。</p>

<h2 id="并行计算的复杂度">并行计算的复杂度</h2>

<p>如果你拥有一定的算法知识，那么应该对计算机如何执行一段程序不陌生了。而并行计算则相当于有<strong>不止一台计算机在同时计算一个任务</strong>。这几台计算机在执行各自的任务时不能产生冲突，比如同时访问同一块内存。也就是说，你需要<strong>合理地将任务分配</strong>给每一台计算机。</p>

<h3 id="一个简陋的模型">一个简陋的模型</h3>

<p>我们可以先引入一个<em>简化版模型</em>。每个任务的代码可以被看作是由两部分组成：<strong>串行部分</strong>和<strong>并行部分</strong>。任务的并行部分能够被分割成数个相互独立的子任务，而串行部分则必须在单一计算机上执行。</p>

<p><img src="/img/parallel-0.png" alt="parallel" /></p>

<p>假设代码中并行部分占比为$c$，串行部分占比为$(1-c)$，那么如果可以最多并行执行$k$个任务，所花费的时间相比于全部串行的时间就是：</p>

<div class="kdmath">$$
1-c+\frac{c}{k}=1-\frac{k-1}{k}c
$$</div>

<p>而在最理想的情况下，有多到近乎无穷的并行容量时，执行该算法所花费的时间就等于串行部分需要花费的时间，即$(1-c)$。</p>

<p>并行计算不仅减少了计算时间，还有可能降低算法的时间复杂度。完全串行的情况下，时间复杂度等于<em>并行部分的时间复杂度</em>+<em>串行部分的时间复杂度</em>；而在理想并行的情况下，时间复杂度仅为<em>并行部分的时间复杂度</em>。如果随着数据规模$N$的提升，并行部分的时间复杂度提升的没有串行部分快，那么这样做就可以降低时间复杂度了。</p>

<p>在上面<code>calcSum</code>的例子中，所有代码都是串行的，没有并行部分。因此，只要有足够多的线程，那么算法的时间复杂度就可以从之前的$O(N)$降低为$O(1)$常数级别。</p>

<p>当然，这个模型实在是有些过于粗糙了，很多算法都不能被简单拆分成“并行”和“串行”两部分。但是相信你应该大致从中了解并行计算和以前熟知的计算方式的区别了。</p>

<h3 id="分治树模型">分治树模型</h3>

<p>我们考虑一个算法中十分常见的问题：<strong>分治</strong>。分治问题里可以使用一棵树来描述。</p>

<p>举个典型的例子：<strong>归并排序</strong>。以下为归并排序的伪代码：</p>

<pre><code class="language-cpp">void mergeSort(int *a, int left, int right) {
    if(right - left == 1) {
        return;
    }
    mergeSort(left half of array a);
    mergeSort(right half of array a);
    merge the sorted two halves of array a
}
</code></pre>

<p>以下为<code>mergeSort</code>一个长度为7的数组是，函数调用的树形结构：</p>

<div class="mermaid">
graph TD
A[1..7] --&gt; B[1..4]
A --&gt; C[5..7]
B --&gt; D[1..2]
B --&gt; E[3..4]
C --&gt; F[5..6]
C --&gt; G[7..7]
D --&gt; H[1..1]
D --&gt; I[2..2]
E --&gt; J[3..3]
E --&gt; K[4..4]
F --&gt; L[5..5]
F --&gt; M[6..6]
</div>

<p>更一般地，区间分治问题的代码几乎都是下面这个形式的：</p>

<pre><code class="language-cpp">void solve(..., int left, int right) {
    if(right - left == 1) {
        // do something here
        return;
    }
    solve(..., left, mid);
    solve(..., mid, right);
    // main code
}
</code></pre>

<p>根据分治的性质，函数调用树上面，如果两个结点不是祖先关系，那么它们之间一定是相互独立的，可以并行计算；而祖先关系的两个结点之间有数据依赖，必须先执行完子结点代表的函数之后才能执行父节点的函数。</p>

<p>因此，我们获得了并行计算这个分治问题的解法：对这棵树按层从下向上遍历，每一次并行执行一层中的所有结点函数。也就是这样：</p>

<p><img src="/img/parallel-1.png" alt="parallel" /></p>

<p><del>如果您有强迫症，请务必原谅我糟糕的绘画水平</del></p>

<p>按照图中数字标记的顺序，每次将当前层的所有函数并行执行即可。</p>

<p>接下来做复杂度分析。已知合并两个区间的时间复杂度为$O(N)$，其中$N$为待处理区间的长度，那么<em>完全串行</em>时，时间复杂度$T(N)$满足：</p>

<div class="kdmath">$$
T(N)=T(\frac N2)+T(\frac N2)+O(N)
$$</div>

<div class="kdmath">$$
T(1)=0
$$</div>

<p>解得：</p>

<div class="kdmath">$$
T(N)=O(N\log N)
$$</div>

<p>而在使用了上述的并行优化之后，由于左右两个区间的处理是并行的，在计算时间时只用加一遍，因此时间复杂度$T’(N)$满足：</p>

<div class="kdmath">$$
T'(N)=T'(\frac N2)+O(N)
$$</div>

<p>解得：</p>

<div class="kdmath">$$
T'(N)=O(N)
$$</div>

<p>可以看出使用并行计算之后，归并排序的时间复杂度减少了一个$\log N$。类似地，其他区间分治类问题都可以使用相同的方法来降低复杂度。</p>

<p>未完待续<del>先挖上坑以后再填</del></p>

<h2 id="参考资料">参考资料</h2>

<p>Cormen, Thomas, et al. <em>Introduction to Algorithms</em>. MIT press, 2022.</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="algorithm" /><summary type="html"><![CDATA[前置知识：多线程]]></summary></entry><entry><title type="html">狭义相对论光线追踪 原理解析 2</title><link href="mqcreaple.github.io/blog/2022/10/17/relativistic-renderer-1.html" rel="alternate" type="text/html" title="狭义相对论光线追踪 原理解析 2" /><published>2022-10-17T00:00:00-04:00</published><updated>2022-10-17T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/10/17/relativistic-renderer-1</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/10/17/relativistic-renderer-1.html"><![CDATA[<p>约定：以下类已经实现</p>

<ul>
  <li><code>Vec3</code>：存储了一个三维向量。
    <ul>
      <li>重载运算符定义了<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>等运算</li>
      <li><code>dot(u, v)</code>点乘</li>
      <li><code>cross(u, v)</code>叉乘</li>
    </ul>
  </li>
  <li><code>LVec4</code>：存储了一个闵氏时空的四维向量。
    <ul>
      <li>重载运算符定义了<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>等运算</li>
      <li><code>dot(u, v)</code>点乘</li>
      <li><code>v.getXYZ()</code>获取四维向量的三维空间分量</li>
    </ul>
  </li>
</ul>

<h2 id="存储一个惯性系">存储一个惯性系</h2>

<p>如何将一个惯性参考系的信息存储下来？</p>

<p>首先，我们可以先选定一个参考系，称为<em>世界参考系</em>。这样其他一切惯性参考系都可以用它们和世界参考系之间的相对速度$\vec u$来表示了。</p>

<p>但是注意，只记录一个速度向量$\vec u$是不够的，因为惯性系之间不只有相对速度，还有可能有平移、旋转之类的相对变换。</p>

<p>这里我们只考虑相对速度$\vec u$和平移$\mathbf p$这两个因素，暂时不考虑旋转<del>，主要是因为我懒得推旋转参考系的公式</del>。也就是这样的一个类：</p>

<pre><code class="language-cpp">class Transformation {
public:
    Transformation(const Vec3 &amp;velocity, const LVec4 origin);
private:
    Vec3 velocity;
    LVec4 origin;
    // Vec3为三维向量，LVec4为闵氏时空中的四维向量
};
</code></pre>

<p>我们定义平移向量$\mathbf p$为<strong>当前参考系的原点（即$(0, 0, 0, 0)$点）点在世界参考系中的测量结果</strong>。注意：世界参考系的原点在当前参考系的测量结果不一定是$-\mathbf p$，可以想一下原因。</p>

<p>显然，世界参考系就是平移$\mathbf p$和速度$\vec u$都为零向量的参考系。</p>

<p>参考系类还需要实现这两个方法，用来做事件的参考系变换：</p>

<pre><code class="language-cpp">class Transformation {
public:
    // ...
    LVec4 toLocal(const LVec4 &amp;world) const;
    LVec4 toWorld(const LVec4 &amp;local) const;
private:
    // ...
};
</code></pre>

<p>具体的公式可以参考<a href="/blog/2022/10/14/relativistic-renderer-0.html">上一篇博客</a>。</p>

<h2 id="存储一条光线">存储一条光线</h2>

<p>“光线”是一种用来描述光传播的抽象模型，它在狭义相对论中同样适用。</p>

<p>一束光在时空图中就是一条斜率为光速的射线：</p>

<p><img src="/img/ray-spacetime-diagram-wikipedia.svg" alt="spacetime-diagram" /></p>

<p><em>图源：<a href="https://en.wikipedia.org/wiki/Spacetime_diagram">Wikipedia</a></em></p>

<p>为了唯一确定一条这样的射线，我们需要光的<strong>光源$\mathbf r$</strong>和光线<strong>方向$\vec d$</strong>。其中$\vec d$一定是一个单位向量。</p>

<p>现在的<code>Ray</code>类是这样的：</p>

<pre><code class="language-cpp">class Ray {
public:
    Ray(const LVec4 &amp;origin, const Vec3 &amp;direction);
private:
    LVec4 origin;
    Vec3 direction;
};
</code></pre>

<p>我们定义一个函数<code>atDistance</code>，表示在世界参考系看来，到光源的空间距离为$l$的事件。就是这样的：</p>

<pre><code class="language-cpp">LVec4 atDistance(float dist) const {
    return LVec4(origin.t + dist, origin.getXYZ() + dist * direction);
}
</code></pre>

<p>在走了一段距离之后，世界参考系下坐标的时间和空间都会增加。</p>

<p><img src="/img/ray-spacetime-diagram-0.png" alt="spacetime-diagram" /></p>

<p><del>众所周知geogebra啥都能画</del></p>

<p>接下来，<code>Transformation</code>类里还要加上这两个函数，用来对光线进行参考系变换：</p>

<pre><code class="language-cpp">class Transformation {
public:
    // ...
    Ray toLocal(const Ray &amp;ray) const;
    Ray toWorld(const Ray &amp;ray) const;
private:
    // ...
};
</code></pre>

<p>光线的参考系变换也很简单，只需要对光源$\mathbf r$做事件的参考系变换，方向$\vec d$做速度的参考系变换即可。</p>

<h2 id="物体">物体</h2>

<p>定义这样的一个抽象类，来表示所有的物体：</p>

<pre><code class="language-cpp">class VisibleObject {
public:
    VisibleObject(const Transformation &amp;tr);

    struct IntersectResult {
        LVec4 intersection;
        float distance;
    };
    virtual std::optional&lt;IntersectResult&gt; intersect(const Ray &amp;ray) const = 0;

private:
    Transformation transformation;
};
</code></pre>

<p><code>VisibleObject</code>类中使用<code>transformation</code>记录了一个匀速运动的物体所在的参考系。</p>

<p><code>intersect</code>函数是这个类的核心。它的任务是计算一条<strong>物体参考系里的光线</strong>和该物体的<strong>交点</strong>。返回值<code>std::optional&lt;IntersectResult&gt;</code>在有交点的时候返回该交点的信息（包括交点的时空坐标，以及交点到光源的空间距离）；如果没有交点，那么返回一个空引用。</p>

<blockquote>
  <p><code>std::optional</code>是C++17的新特性，可以用来表示一个“有值或者没有值”的对象。更多信息可以看<a href="https://en.cppreference.com/w/cpp/utility/optional">cppreference</a>。</p>
</blockquote>

<p>另一个值得注意的点是：由于光线追踪的过程是<strong>回溯</strong>光的路径，所以每次求出的交点应该在光路的<strong>反方向</strong>上，<code>distance</code>值应当为负数。</p>

<p><img src="/img/forward-ray-tracing-0.jpg" alt="forward-tracing" /></p>

<blockquote>
  <p>实际上由于光路可逆原则，将光线的方向全部反向之后，每次求光路正方向上的交点，理论上也是可行的。</p>

  <p><strong>但是</strong>，如果你真的打算这么写，那么就要尤其注意光线的参考系变换。因为这样的话，<code>Ray</code>类里记录的方向向量$\vec d$和光的速度向量<strong>是相反的</strong>，光线的<code>toLocal</code>和<code>toWorld</code>里对应项也需要变符号。</p>

  <p><del>之前被这个bug困扰了一个晚上，在这里写下来以警示后人</del></p>
</blockquote>

<h3 id="球体">球体</h3>

<p>为了展示<code>intersection</code>函数，这里举一个简单的例子：球体。不妨假设球体的球心在原点$(0, 0, 0)$</p>

<p>假设有一个在<strong>物体参考系</strong>里的光线<code>ray</code>（不是世界参考系，所以不用考虑参考系变换）。光线从原点$\vec r$出发，向前走了距离$l$，走到的坐标是：</p>

<div class="kdmath">$$
\vec r_1=\vec r + l\vec d
$$</div>

<p>如果$\vec r_1$是光线和球的交点，那么$\vec r_1$到球心（即原点）的距离一定等于球的半径，即：</p>

<div class="kdmath">$$
||\vec r_1||=||\vec r + l\vec d||=R
$$</div>

<p><img src="/img/ray-sphere-intersection-0.png" alt="ray-sphere-intersection" /></p>

<p>将向量模长写成向量点乘自己，也就是：</p>

<div class="kdmath">$$
(\vec r + l\vec d)\cdot(\vec r + l\vec d)=R^2
$$</div>

<p>展开这个式子：</p>

<div class="kdmath">$$
(\vec r + l\vec d)\cdot(\vec r+l\vec d) = \vec r\cdot\vec r + 2l\vec r\cdot\vec d + l^2\vec d\cdot\vec d = R^2
$$</div>

<div class="kdmath">$$
\vec d^2l^2+2(\vec r\cdot\vec d)l+(\vec r^2-R^2)=0
$$</div>

<p>由于$\vec d$是单位向量，$\vec d^2=1$，代入原式得到：</p>

<div class="kdmath">$$
l^2+2(\vec r\cdot\vec d)l+(\vec r^2-R^2)=0
$$</div>

<p>我们得到了一个关于$l$的一元二次方程，它的每个根就代表了光线和球的一个交点到光源的距离（这个距离可能是负数，此时表示交点在光线的反方向，而这正是我们想要的）。只需要解出这个方程，然后再判断两个根$l_1, l_2$是否是负数，以及它们之间的大小关系，即可找到光线和球的最近交点。</p>

<p>得到光源到交点的空间距离$l$之后，再做一次<code>ray.atDistance(l)</code>即可得到交点的具体坐标。</p>

<p>代码：</p>

<pre><code class="language-cpp">std::optional&lt;IntersectionResult&gt; SphereObject::intersect(const Ray &amp;ray) const {
    Vec3 r0 = ray.getOrigin().getXYZ();  // 光源的空间坐标
    float b = 2 * dot(r0, ray.getDirection());
    float c = dot(r0, r0) - radius * radius;
    float delta = b * b - 4 * c;         // 二次方程判别式
    
    float l = (-b + sqrt(delta)) / 2;    // 优先考虑较大的根
    if(l &gt; 0) {
        // 如果较大的根超出范围，那么考虑另一个根
        l = (-b - sqrt(delta)) / 2;
    }
    if(l &gt; 0) {
        return std::nullopt;             // 返回一个空引用
    }
    return IntersectionResult(ray.atDistance(l), l);  // 返回答案
}
</code></pre>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="physics" /><category term="special-relativity" /><category term="computer-graphics" /><summary type="html"><![CDATA[约定：以下类已经实现]]></summary></entry><entry><title type="html">狭义相对论光线追踪 原理解析 1</title><link href="mqcreaple.github.io/blog/2022/10/14/relativistic-renderer-0.html" rel="alternate" type="text/html" title="狭义相对论光线追踪 原理解析 1" /><published>2022-10-14T00:00:00-04:00</published><updated>2022-10-14T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/10/14/relativistic-renderer-0</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/10/14/relativistic-renderer-0.html"><![CDATA[<p>前置知识：狭义相对论。</p>

<p>先温习一遍课本里的洛伦兹变换(Lorentz transformation)：如果参考系$S’$相对于$S$的速度为$u$，沿着$x$轴正方向，那么事件$(t, x, y, z)$在$S’$参考系中测量的结果是：</p>

<div class="kdmath">$$
\begin{cases}
t'=\gamma(t-\frac{u}{c^2}x) \\
x'=\gamma(x-ut) \\
y'=y \\
z'=z
\end{cases}
$$</div>

<p>其中$c$为光速，并且</p>

<div class="kdmath">$$
\gamma=\frac{1}{\sqrt{1-\frac{u^2}{c^2}}}
$$</div>

<h2 id="四维矢量和闵可夫斯基空间">四维矢量和闵可夫斯基空间</h2>

<p>洛伦兹变换有一大性质：如果两个事件$\mathbf r_1$和$\mathbf r_2$，那么不论在哪个惯性参考系中看，这个物理量：</p>

<div class="kdmath">$$
s^2=-(c\Delta t)^2+\Delta x^2+\Delta y^2+\Delta z^2
$$</div>

<p>是永远不变的。$s$被称为<strong>闵可夫斯基度规(Minkowski metric)</strong>，或者<strong>闵氏度规</strong>。</p>

<p>这启发了我们，可以定义一个四维矢量来表示事件。为了保证单位一致，第一维是光速乘上时间，后三维是空间。像这样：</p>

<div class="kdmath">$$
\mathbf r=(ct, x, y, z)=(ct, \vec{r})
$$</div>

<p><em>（为了方便区分，本文中所有四维向量均用粗体表示，三维向量均用箭头表示）</em></p>

<p>然后向量的模长公式不再是平方求和后再相加，而是：</p>

<div class="kdmath">$$
||\mathbf r||=\sqrt{-(ct)^2+x^2+y^2+z^2}
$$</div>

<p>把时间平方项的正号改成负号。这样的话，两个事件$\mathbf r_1$和$\mathbf r_2$之间的<strong>距离</strong>（或者说：闵氏度规）就是：</p>

<div class="kdmath">$$
s=||\mathbf r_2-\mathbf r_1||
$$</div>

<p>你可能会觉得为了凑出$-t^2$而强行修改向量模长定义的行为很无耻。但是，它其实是是一种和我们熟悉的空间（即：欧几里得空间/欧氏空间）完全不同的<strong>几何</strong>规则，也就是<strong>闵可夫斯基几何</strong>/<strong>闵氏几何</strong>。毕竟，没有规定说我们的宇宙一定遵守欧氏几何这种符合人类直觉的规律。</p>

<p>所有满足这个奇怪的模长公式的向量构成了一个向量空间，即<strong>闵可夫斯基空间</strong>，或者也可以叫<strong>闵可夫斯基时空</strong>。在闵氏空间里，向量的第一维和后三维的地位并不相同。</p>

<p>闵氏空间里，向量点乘（内积）的定义也被修改了：向量$\mathbf u$和$\mathbf v$的点乘是：</p>

<div class="kdmath">$$
\mathbf u\cdot\mathbf v=-u_tv_t+u_xv_x+u_yv_y+u_zv_z
$$</div>

<p>而洛伦兹变换就是一个4×4的矩阵：</p>

<div class="kdmath">$$
\Lambda=\begin{bmatrix}
\gamma & -\frac{u}{c}\gamma & 0 & 0 \\
-\frac{u}{c}\gamma & \gamma & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$</div>

<p>将事件在$S$系中的测量结果$\mathbf r$转到$S’$系测量，就相当于用矩阵$\Lambda$乘上$\mathbf r$：</p>

<div class="kdmath">$$
\mathbf r'=\Lambda\mathbf r
$$</div>

<h2 id="任意方向的洛伦兹变换">任意方向的洛伦兹变换</h2>

<p>刚刚的讨论里，相对速度$u$都是沿着$x$轴正方向的。但是如果$u$不是呢？</p>

<p>可以这样想：把一个事件$\mathbf r$的空间分量$\vec r$分解成平行于速度分量$\vec r_\parallel$和垂直于速度的分量$\vec r_\perp$。</p>

<div class="kdmath">$$
\vec r_\parallel=(\vec r\cdot \vec n)\vec n=\left(\vec r\cdot\frac{\vec u}{||\vec u||}\right)\frac{\vec u}{||\vec u||}
$$</div>

<div class="kdmath">$$
\vec r_\perp=\vec r-\vec r_\parallel
$$</div>

<p>其中$\vec n=\frac{\vec u}{\mid\mid\vec u\mid\mid}$，是速度$\vec u$方向上的单位向量。</p>

<p>经过变换之后，垂直于速度的$\vec r_\perp$分量不变，而$\vec r_\parallel$会变成$\gamma(\vec r_\parallel-\vec ut)$。</p>

<div class="kdmath">$$
\begin{align*}
\vec r' &=\vec r_\perp+\gamma(\vec r_\parallel-\vec ut) \\
&= (\vec r-(\vec r\cdot\vec n)\vec n) + \gamma((\vec r\cdot \vec n)\vec n-\vec ut) \\
&= \vec r + (\gamma-1)(\vec r\cdot\vec n)\vec n-\gamma\vec ut
\end{align*}
$$</div>

<p>而时间变换则简单一些：</p>

<div class="kdmath">$$
\begin{align*}
t'&=\gamma(t-\frac{u}{c^2}r_\parallel) \\
&= \gamma(t-\frac{\vec u}{c^2}\cdot \vec r)
\end{align*}
$$</div>

<p>将上面的变换公式写成矩阵，就是：</p>

<div class="kdmath">$$
\begin{bmatrix}ct'\\x'\\y'\\z'\end{bmatrix}=
\begin{bmatrix}
\gamma & -\gamma\frac{u_x}{c} & -\gamma\frac{u_y}{c} & -\gamma\frac{u_z}{c} \\
-\gamma\frac{u_x}{c} & 1+(\gamma-1)n_x^2 & (\gamma-1)n_xn_y & (\gamma-1)n_xn_z \\
-\gamma\frac{u_y}{c} & (\gamma-1)n_yn_x & 1+(\gamma-1)n_y^2 & (\gamma-1)n_yn_z \\
-\gamma\frac{u_z}{c} & (\gamma-1)n_zn_x & (\gamma-1)n_zn_y & 1+(\gamma-1)n_z^2
\end{bmatrix}
\begin{bmatrix}ct\\x\\y\\z\end{bmatrix}
$$</div>

<p>也就是说，速度$\vec u$方向任意的洛伦兹变换矩阵就是：</p>

<div class="kdmath">$$
\Lambda(\vec u)=\begin{bmatrix}
\gamma & -\gamma\frac{u_x}{c} & -\gamma\frac{u_y}{c} & -\gamma\frac{u_z}{c} \\
-\gamma\frac{u_x}{c} & 1+(\gamma-1)n_x^2 & (\gamma-1)n_xn_y & (\gamma-1)n_xn_z \\
-\gamma\frac{u_y}{c} & (\gamma-1)n_yn_x & 1+(\gamma-1)n_y^2 & (\gamma-1)n_yn_z \\
-\gamma\frac{u_z}{c} & (\gamma-1)n_zn_x & (\gamma-1)n_zn_y & 1+(\gamma-1)n_z^2
\end{bmatrix}
$$</div>

<p>其中</p>

<div class="kdmath">$$
\gamma=\frac{1}{\sqrt{1-\frac{||\vec u||^2}{c^2}}}
$$</div>

<p>可以检验，当$\vec u$的大小为$u$而方向指向$x$轴正半轴时，$\Lambda(\vec u)$和之前给出的矩阵相等。</p>

<h2 id="速度变换">速度变换</h2>

<p>任何一个物体的运动都可以表示成闵氏时空中的一条曲线。在$S$系中，物体的速度是：</p>

<div class="kdmath">$$
\vec v=\frac{\mathrm d\vec r}{\mathrm dt}
$$</div>

<p>而$S’$系中，同一个物体的速度是：</p>

<div class="kdmath">$$
\vec v'=\frac{\mathrm d\vec r'}{\mathrm dt'}
$$</div>

<p>我们的目的就是将$\vec v’$表示成$\vec v$，$\vec u$，以及其他$S$系中可测量的物理量。为了用$\vec v$表示$\vec v’$，可以先用一个链式法则：</p>

<div class="kdmath">$$
\begin{align*}
\vec v' &= \frac{\mathrm d\vec r'}{\mathrm dt'} \\
&= \frac{\partial\vec r'}{\partial t}\frac{\mathrm dt}{\mathrm dt'}+\frac{\partial\vec r'}{\partial x}\frac{\mathrm dx}{\mathrm dt'}+\frac{\partial\vec r'}{\partial y}\frac{\mathrm dy}{\mathrm dt}+\frac{\partial\vec r'}{\partial z}\frac{\mathrm dz}{\mathrm dt} \\
&= \sum_{i=1}^4\frac{\partial\vec r'}{\partial\mathbf r_i}\frac{\mathrm d\mathbf r_i}{\mathbf dt'}
\end{align*}
$$</div>

<p>其中$\mathbf r_i$为$\mathbf r$的第$i$个分量。偏导数$\frac{\partial\vec r’}{\partial\mathbf r_i}$很好求，接下来只需要求出全导数$\frac{\mathrm d\mathbf r_i}{\mathrm dt’}$即可。</p>

<p>这里我们还可以用一个链式法则：</p>

<div class="kdmath">$$
\begin{align*}
\frac{\mathrm d\mathbf r_i}{\mathrm dt'} &= \left(\frac{\mathrm dt'}{\mathrm d\mathbf r_i}\right)^{-1} \\
&= \left(\sum_{j=1}^4\frac{\partial t'}{\partial\mathbf r_j}\frac{\mathrm d\mathbf r_j}{\mathrm d\mathbf r_i}\right)^{-1}
\end{align*}
$$</div>

<p>不难想到，</p>

<div class="kdmath">$$
\frac{\mathrm dx}{\mathrm dt}=v_x,\ \frac{\mathrm dy}{\mathrm dt}=v_y,\ \frac{\mathrm dz}{\mathrm dt}=v_z
$$</div>

<div class="kdmath">$$
\frac{\mathrm dx}{\mathrm dy}=\frac{v_x}{v_y},\ \frac{\mathrm dy}{\mathrm dz}=\frac{v_y}{v_z},\ \frac{\mathrm dz}{\mathrm dx}=\frac{v_z}{v_x}
$$</div>

<p>也就是说，任何形如$\frac{\mathrm d\mathbf r_j}{\mathrm d\mathbf r_i}$的表达式，都可以表示成速度分量的比值。然后把这些东西再带回原式，就可以算出来了。</p>

<p>由于过程太长，我就不全打出来了。以下是答案：</p>

<div class="kdmath">$$
\vec v'=\frac{1}{1-\frac{\vec u\cdot\vec v}{c^2}}\left(\frac{\vec v}{\gamma}-\vec u+\frac 1{c^2}\frac{\gamma}{\gamma+1}(\vec u\cdot\vec v)\vec u\right)
$$</div>

<p>遗憾的是，速度变换并不是线性变换，所以没办法写成矩阵形式。</p>

<h2 id="光相差relativistic-abberation">光相差（Relativistic Abberation）</h2>

<p>我们可以把光线当成是运动速度为光速的物体，那么同样可以对其进行速度变换。</p>

<p>代入前面的速度变换公式，不难检验，若在$S$系中速度$v$大小为光速，那么经过速度变换之后，$S’$系中$v’$也是光速。这又被称为：<strong>光速不变原则</strong>，光速运动的物体无论在哪个参考系中都是光速运动的。</p>

<p>但是需要注意，在两个参考系中，光的方向会发生变化。</p>

<p>如果在静止的参考系里，从一个点在各个方向上均匀发出光线：</p>

<p><img src="/img/rel-plot-1.png" alt="" /></p>

<p>那么在一个朝右运动的参考系里，光线的方向不再均匀，而是向运动的反方向聚集：</p>

<p><img src="/img/rel-plot-2.png" alt="" /></p>

<p>类似地，在一个接收光线的观察者看来，如果它在以接近光速运动，会有更多光线朝着它面前打过来，而它背后的光线就会减弱。</p>

<p>这个光线角度在运动参考系中发生偏转的现象就被称为：狭义相对论光相差。</p>

<blockquote>
  <p>鉴于本文作者比较菜，如果您在阅读时发现了任何错误，欢迎在<a href="/">主页</a>评论区指出！</p>
</blockquote>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="physics" /><category term="special-relativity" /><category term="computer-graphics" /><summary type="html"><![CDATA[前置知识：狭义相对论。]]></summary></entry><entry><title type="html">封装一棵线段树</title><link href="mqcreaple.github.io/blog/2022/10/02/segment-tree-class.html" rel="alternate" type="text/html" title="封装一棵线段树" /><published>2022-10-02T00:00:00-04:00</published><updated>2022-10-02T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/10/02/segment-tree-class</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/10/02/segment-tree-class.html"><![CDATA[<p>最近得了个“小感冒”，实在懒得去做题，然后就在其他人的博客里瞎逛。无意间发现了zxp大佬之前写过的<a href="https://zxp2019.github.io/blog/article/segment-tree-class/"><em>封装一棵线段树</em></a>，然后就想把这里的代码稍微改得更像C++标准库一点。</p>

<h2 id="基本结构">基本结构</h2>

<p>首先肯定是不能用数组来写线段树了，而应当用一个更高级的工具：<strong>指针</strong>。</p>

<p>我们在线段树结点的struct里放这些东西：</p>

<pre><code class="language-cpp">struct Node {
    int leftBound;  // inclusive
    int rightBound; // exclusive
    Node *leftChild;
    Node *rightChild;
    T sum;
    T lazy;
    Node(int leftBound, int rightBound)
        : leftBound(leftBound), rightBound(rightBound), leftChild(nullptr), rightChild(nullptr), sum(0), lazy(0) {}
};
</code></pre>

<p><em>（为了对应大部分C++标准库的规则，这里的左边界是包含的，而右边界则不包含，相当于这个结点覆盖的是区间上<code>[left, right)</code>的部分）</em></p>

<p>然后在每个线段树类里面记录一下线段树的根结点<code>root</code>即可：</p>

<pre><code class="language-cpp">class QuickArray {
public:
private:
    struct Node {
        // Omitted
    };
    Node *root;
};
</code></pre>

<p>然后就是其他操作了：</p>

<h2 id="线段树的操作">线段树的操作</h2>

<h3 id="创建线段树">创建线段树</h3>

<p>这里我直接把它放在了线段树类<code>QuickArray</code>的构造函数里。代码是这样的：</p>

<pre><code class="language-cpp">class QuickArray {
public:
    QuickArray(int left, int right): root(buildTree(left, right)) {}
};
</code></pre>

<p>而这里的<code>buildTree</code>是一个私有的辅助函数，专门用来构造线段树：</p>

<pre><code class="language-cpp">private:
    static Node *buildTree(int left, int right) {
        Node *cur = new Node(left, right);        // create a new node in memory
        if(right - left &lt;= 1) {
            return cur;                           // current node is leaf, directly return from function
        }
        int mid = (left + right) / 2;
        cur-&gt;leftChild = buildTree(left, mid);    // build left tree
        cur-&gt;rightChild = buildTree(mid, right);  // build right tree
        return cur;
    }
</code></pre>

<h3 id="更新区间">更新区间</h3>

<p>更新区间的操作就是线段树板子了，直接贴上去就好：</p>

<pre><code class="language-cpp">public:
    void add(int left, int right, T value) {
        if(left &lt; right) {
            // to prevent illegal update
            nodeAdd(root, left, right, value);
        }
    }
private:
    static void nodeAdd(Node *n, IndexT left, IndexT right, T value) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return;
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            n-&gt;lazy += value;
            pushDown(n);
            return;
        }
        nodeAdd(n-&gt;leftChild, left, right, value);
        nodeAdd(n-&gt;rightChild, left, right, value);
        n-&gt;sum = n-&gt;leftChild-&gt;sum + n-&gt;rightChild-&gt;sum;
    }
</code></pre>

<h3 id="区间查询">区间查询</h3>

<p>还是板子。先写一个<code>pushDown</code>：</p>

<pre><code class="language-cpp">private:
    static void pushDown(Node *n) {
        if(n-&gt;leftChild != nullptr &amp;&amp; n-&gt;rightChild != nullptr) {
            n-&gt;leftChild-&gt;lazy += n-&gt;lazy;
            n-&gt;rightChild-&gt;lazy += n-&gt;lazy;
            n-&gt;sum += n-&gt;lazy * (n-&gt;rightBound - n-&gt;leftBound);
        } else {
            n-&gt;sum += n-&gt;lazy;
        }
        n-&gt;lazy = 0;
    }
</code></pre>

<p>然后就是区间查询的代码：</p>

<pre><code class="language-cpp">public:
    T sum(int left, int right) const {
        if(left &lt; right) {
            return nodeSum(root, left, right);
        }
        throw "Invalid query!";
    }
private:
    static T nodeSum(Node *n, IndexT left, IndexT right) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return T(0);
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            return n-&gt;sum;
        }
        return nodeSum(n-&gt;leftChild, left, right) + nodeSum(n-&gt;rightChild, left, right);
    }
</code></pre>

<h3 id="其他">其他</h3>

<p>再加一些可能用得上的函数，比如查询区间的左端和右端：</p>

<pre><code class="language-cpp">public:
    int leftBound() const {
        return root-&gt;leftBound;
    }
    int rightBound() const {
        return root-&gt;rightBound;
    }
</code></pre>

<p>完成！</p>

<h2 id="第一版代码">第一版代码</h2>

<pre><code class="language-cpp">#pragma once

template&lt;typename T&gt;
class QuickArray {
public:
    typedef int IndexT;
    /**
     * @brief Construct a QuickArray from left and right bound
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     */
    QuickArray(IndexT left, IndexT right): root(buildTree(left, right)) {}

    /**
     * @brief Construct a new QuickArray from a given array
     * @param array array with initial elements
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     */
    QuickArray(T *array, IndexT left, IndexT right): root(buildTree(array, left, right)) {}

    /**
     * @brief Add a given number to every term in range [left, right)
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     * @param amount amount to add
     */
    void add(IndexT left, IndexT right, T value) {
        if(left &lt; right) {
            nodeAdd(root, left, right, value);
        }
    }

    /**
     * @brief Find the sum of all terms in range [left, right)
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     * @return T sum
     */
    T sum(IndexT left, IndexT right) const {
        if(left &lt; right) {
            return nodeSum(root, left, right);
        }
        throw "Invalid query!";
    }

    /**
     * @brief Get the array's left bound
     * @return IndexT left bound (inclusive)
     */
    IndexT leftBound() const {
        return root-&gt;leftBound;
    }

    /**
     * @brief Get the array's right bound
     * @return IndexT right bound (exclusive)
     */
    IndexT rightBound() const {
        return root-&gt;rightBound;
    }

    ~QuickArray() {
        removeNodes(root);
    }
private:
    struct Node {
        IndexT leftBound;  // inclusive
        IndexT rightBound; // exclusive
        Node *leftChild;
        Node *rightChild;
        T sum;
        T lazy;
        Node(int leftBound, int rightBound)
            : leftBound(leftBound), rightBound(rightBound), leftChild(nullptr), rightChild(nullptr), sum(0), lazy(0) {}
    };
    Node *root;

    static Node *buildTree(IndexT left, IndexT right) {
        Node *cur = new Node(left, right);        // create a new node in memory
        if(right - left &lt;= 1) {
            return cur;                           // current node is leaf, directly return from function
        }
        IndexT mid = (left + right) / 2;
        cur-&gt;leftChild = buildTree(left, mid);    // build left tree
        cur-&gt;rightChild = buildTree(mid, right);  // build right tree
        return cur;
    }

    static Node *buildTree(T *array, IndexT left, IndexT right) {
        Node *cur = new Node(left, right);
        if(right - left &lt;= 1) {
            cur-&gt;sum = array[left];
            return cur;
        }
        IndexT mid = (left + right) / 2;
        cur-&gt;leftChild = buildTree(array, left, mid);
        cur-&gt;rightChild = buildTree(array, mid, right);
        cur-&gt;sum = cur-&gt;leftChild-&gt;sum + cur-&gt;rightChild-&gt;sum;
        return cur;
    }

    static void pushDown(Node *n) {
        if(n-&gt;leftChild != nullptr &amp;&amp; n-&gt;rightChild != nullptr) {
            n-&gt;leftChild-&gt;lazy += n-&gt;lazy;
            n-&gt;rightChild-&gt;lazy += n-&gt;lazy;
            n-&gt;sum += n-&gt;lazy * (n-&gt;rightBound - n-&gt;leftBound);
        } else {
            n-&gt;sum += n-&gt;lazy;
        }
        n-&gt;lazy = 0;
    }

    static void nodeAdd(Node *n, IndexT left, IndexT right, T value) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return;
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            n-&gt;lazy += value;
            pushDown(n);
            return;
        }
        nodeAdd(n-&gt;leftChild, left, right, value);
        nodeAdd(n-&gt;rightChild, left, right, value);
        n-&gt;sum = n-&gt;leftChild-&gt;sum + n-&gt;rightChild-&gt;sum;
    }

    static T nodeSum(Node *n, IndexT left, IndexT right) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return T(0);
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            return n-&gt;sum;
        }
        return nodeSum(n-&gt;leftChild, left, right) + nodeSum(n-&gt;rightChild, left, right);
    }

    static void removeNodes(Node *n) {
        if(n == nullptr) {
            return;
        }
        removeNodes(n-&gt;leftChild);
        removeNodes(n-&gt;rightChild);
        delete n;
    }
};
</code></pre>

<h2 id="改进">改进</h2>

<p>我们用C++新特性：智能指针，来代替上文中的<code>Node*</code>。这增加了程序的安全性。</p>

<p>由于我们不需要复制结点指针，所有指针一律改成<code>unique_ptr</code>即可：</p>

<blockquote>
  <p><code>unique_ptr</code>是一个类，用来模拟一个指针。</p>

  <p>如果<code>unique_ptr</code>指向一个堆中的对象，那么当它的作用域结束之后，<code>unique_ptr</code>的析构函数会自动释放该对象的内存，不用手动<code>delete</code>。</p>

  <p><code>unique_ptr</code>不允许复制，这样保证了不会有两个指针指向同一块内存而导致将该内存释放多次。</p>
</blockquote>

<p>（如果你学过Rust，可能会对<code>unique_ptr</code>感到很熟悉）</p>

<p>以下为改成<code>unique_ptr</code>的代码：</p>

<pre><code class="language-cpp">#pragma once

#include &lt;memory&gt;
using std::unique_ptr;

template&lt;typename T&gt;
class QuickArray {
public:
    typedef int IndexT;
    /**
     * @brief Construct a QuickArray from left and right bound
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     */
    QuickArray(IndexT left, IndexT right) {
        buildTree(root, left, right);
    }

    /**
     * @brief Construct a new QuickArray from a given array
     * @param array array with initial elements
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     */
    QuickArray(T *array, IndexT left, IndexT right) {
        buildTree(root, array, left, right);
    }

    /**
     * @brief Add a given number to every term in range [left, right)
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     * @param amount amount to add
     */
    void add(IndexT left, IndexT right, T value) {
        if(left &lt; right) {
            nodeAdd(root, left, right, value);
        }
    }

    /**
     * @brief Find the sum of all terms in range [left, right)
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     * @return T sum
     */
    T sum(IndexT left, IndexT right) const {
        if(left &lt; right) {
            return nodeSum(root, left, right);
        }
        throw "Invalid query!";
    }

    /**
     * @brief Get the array's left bound
     * @return IndexT left bound (inclusive)
     */
    IndexT leftBound() const {
        return root-&gt;leftBound;
    }

    /**
     * @brief Get the array's right bound
     * @return IndexT right bound (exclusive)
     */
    IndexT rightBound() const {
        return root-&gt;rightBound;
    }
private:
    struct Node {
        IndexT leftBound;  // inclusive
        IndexT rightBound; // exclusive
        unique_ptr&lt;Node&gt; leftChild;
        unique_ptr&lt;Node&gt; rightChild;
        T sum;
        T lazy;
        Node(int leftBound, int rightBound)
            : leftBound(leftBound), rightBound(rightBound), leftChild(), rightChild(), sum(0), lazy(0) {}
    };
    unique_ptr&lt;Node&gt; root;

    static void buildTree(unique_ptr&lt;Node&gt; &amp;cur, IndexT left, IndexT right) {
        cur = std::make_unique&lt;Node&gt;(left, right);  // equivalent to `cur = new Node(left, right)` in C pointer
        if(right - left &lt;= 1) {
            return;
        }
        IndexT mid = (left + right) / 2;
        buildTree(cur-&gt;leftChild, left, mid);
        buildTree(cur-&gt;rightChild, mid, right);
    }

    static void buildTree(unique_ptr&lt;Node&gt; &amp;cur, T *array, IndexT left, IndexT right) {
        cur = std::make_unique&lt;Node&gt;(left, right);
        if(right - left &lt;= 1) {
            cur-&gt;sum = array[left];
            return;
        }
        IndexT mid = (left + right) / 2;
        buildTree(cur-&gt;leftChild, array, left, mid);
        buildTree(cur-&gt;rightChild, array, mid, right);
        cur-&gt;sum = cur-&gt;leftChild-&gt;sum + cur-&gt;rightChild-&gt;sum;
    }

    static void pushDown(const unique_ptr&lt;Node&gt; &amp;n) {
        if(n-&gt;leftChild != nullptr &amp;&amp; n-&gt;rightChild != nullptr) {
            n-&gt;leftChild-&gt;lazy += n-&gt;lazy;
            n-&gt;rightChild-&gt;lazy += n-&gt;lazy;
            n-&gt;sum += n-&gt;lazy * (n-&gt;rightBound - n-&gt;leftBound);
        } else {
            n-&gt;sum += n-&gt;lazy;
        }
        n-&gt;lazy = 0;
    }

    static void nodeAdd(const unique_ptr&lt;Node&gt; &amp;n, IndexT left, IndexT right, T value) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return;
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            n-&gt;lazy += value;
            pushDown(n);
            return;
        }
        nodeAdd(n-&gt;leftChild, left, right, value);
        nodeAdd(n-&gt;rightChild, left, right, value);
        n-&gt;sum = n-&gt;leftChild-&gt;sum + n-&gt;rightChild-&gt;sum;
    }

    static T nodeSum(const unique_ptr&lt;Node&gt; &amp;n, IndexT left, IndexT right) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return T(0);
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            return n-&gt;sum;
        }
        return nodeSum(n-&gt;leftChild, left, right) + nodeSum(n-&gt;rightChild, left, right);
    }
};
</code></pre>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="algorithm" /><summary type="html"><![CDATA[最近得了个“小感冒”，实在懒得去做题，然后就在其他人的博客里瞎逛。无意间发现了zxp大佬之前写过的封装一棵线段树，然后就想把这里的代码稍微改得更像C++标准库一点。]]></summary></entry><entry><title type="html">【整活】所有算法都是O(1)的</title><link href="mqcreaple.github.io/blog/2022/09/06/time-compl.html" rel="alternate" type="text/html" title="【整活】所有算法都是O(1)的" /><published>2022-09-06T00:00:00-04:00</published><updated>2022-09-06T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/09/06/time-compl</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/09/06/time-compl.html"><![CDATA[<p><em>注：本文全部内容为<strong>一本正经的胡说八道</strong>，请勿相信</em></p>

<h2 id="示范快速排序算法">示范：快速排序算法</h2>

<p><strong>第一步：复制粘贴一份代码</strong></p>

<pre><code class="language-cpp">void qsort(int *a, int l, int r)
{
    int pivot = a[(l+r)/2];
    int i = l, j = r;
    do {
        while(a[i] &lt; pivot) i++;
        while(a[j] &gt; pivot) j--;
        if(i&lt;=j) {
            swap(a[i], a[j]);
            i++;
            j--;
        }
    } while(i &lt;= j);
    if(l &lt; j) qsort(a, l, j);
    if(i &lt; r) qsort(a, i, r);
}
int main() {
    const int N = 100001;
    int n;
    int a[N];
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
    }
    qsort(a, 0, n-1);            // sort the array
    for(int i = 0; i &lt; n; i++) {
        cout &lt;&lt; a[i] &lt;&lt; " ";
    }
}
</code></pre>

<p>然后我们很失望，因为这个算法是$O(N\log N)$的。</p>

<p><strong>第二步：观察数据范围</strong></p>

<p><img src="/img/time-compl-0.png" alt="time-compl-0" /></p>

<p>我们发现，$N$不超过$10^5$，接下来就有办法了。</p>

<p><strong>第三步：补齐数组</strong></p>

<p>在我们的代码里面更改下面几处：</p>

<pre><code class="language-diff">int main() {
    const int N = 100001;
    int n;
    int a[N];
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
    }
+   for(int i = n; i &lt; N; i++) {
+       a[i] = INT32_MAX;       // fill the rest of array with INT32_MAX
+   }
-   sort(a, 0, n-1);            // sort the array
+   sort(a, 0, N-1);            // sort the whole array
    for(int i = 0; i &lt; n; i++) {
        cout &lt;&lt; a[i] &lt;&lt; " ";
    }
}
</code></pre>

<p>然后你就惊奇地发现，不管你输入的数组是多大，这个算法都会排序$1$到$N$之间的所有数，它所需要的执行时间都是一样的。换句话说：<strong>这个算法是$O(1)$的</strong>。</p>

<p><strong>第四步：为自己献上热烈的掌声</strong></p>

<p>至此，你成功地将一个$O(N\log N)$的算法变成了$O(1)$的算法。</p>

<h2 id="练习">练习</h2>

<ol>
  <li>$O(1)$计算快速幂</li>
  <li>$O(1)$解决图的最短路问题</li>
  <li>$O(1)$解决A+B problem</li>
</ol>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="algorithm" /><category term="time-complexity" /><category term="jokes" /><summary type="html"><![CDATA[注：本文全部内容为一本正经的胡说八道，请勿相信]]></summary></entry><entry><title type="html">Y combinator和递归</title><link href="mqcreaple.github.io/blog/2022/09/02/y-combinator.html" rel="alternate" type="text/html" title="Y combinator和递归" /><published>2022-09-02T00:00:00-04:00</published><updated>2022-09-02T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/09/02/y-combinator</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/09/02/y-combinator.html"><![CDATA[<link rel="stylesheet" href="/app/lambda-playground/lambda-playground.css" />

<script src="/app/lambda-playground/lambda-playground.js" onload="autoRender()"></script>

<p><strong>温馨提示：如果你不了解λ演算，请阅读<a href="/blog/2022/08/27/lambda.html">上一篇博客</a>以获得最佳食用体验</strong></p>

<p><em>注：本文的λ表达式中所有出现的下划线<code>_</code>，都表示“这个值我懒得算且不关心”</em></p>

<h2 id="y组合子">Y组合子</h2>

<p>其实，并不是所有的λ表达式都可以化简。比如说，一个经典的构造就是：</p>

<pre><code class="language-plaintext">Ω := ((λx. (x x)) (λx. (x x)))
</code></pre>

<p class="lambda-r">[ [ "λx", [ "x", "x" ] ], [ "λx", [ "x", "x" ] ] ]</p>

<p>这个表达式很有意思。当你把后面的表达式代入前面的<code>x</code>中时，你又会得到和原来一摸一样的表达式，你永远也无法化简它。也就是，它是<strong>不可求值</strong>的。</p>

<p>而我们对这个表达式简单地变一下，就得到了另一个表达式：</p>

<pre><code class="language-plaintext">((λx. f (x x)) (λx. f (x x)))
</code></pre>

<p class="lambda-r">[ [ "λx", [ "f", [ "x", "x" ] ] ], [ "λx", [ "f", [ "x", "x" ] ] ] ]</p>

<p>当你把后一项代入前一项时，它不仅得到了原来的表达式，而且还在外面多套上了一层函数<code>f</code>。再进行一次替换操作，函数外面又多了一层<code>f</code>，你可以一直这样无穷无尽地迭代下去。</p>

<p>稍稍将外面这个函数改一下，就得到了著名的<strong>Y组合子(Y combinator)</strong>：</p>

<pre><code class="language-lisp">Y := λf. ((λx. f (x x)) (λx. f (x x)))
</code></pre>

<p>Y组合子的一大性质就是：</p>

<pre><code class="language-lisp">(Y f) = (f (Y f))
</code></pre>

<p>由于它和函数的不动点$x=f(x)$长得很像，所以Y组合子也叫<strong>不动点组合子(fixed point combinator)</strong>。</p>

<p><em>注：Y组合子并不是唯一的不动点组合子。比如由Alan Turing给出的Θ组合子</em></p>

<pre><code class="language-lisp">Θ := ((λx. λy. y (x x y)) (λx. λy. y (x x y)))
</code></pre>

<p><em>它同样满足不动点组合子的性质：</em></p>

<pre><code class="language-lisp">(Θ f) = (f (Θ f))
</code></pre>

<p>根据不动点组合子的性质，任何不动点组合子<code>fix</code>都有：</p>

<pre><code class="language-lisp">(fix f) = (f (fix f))
        = (f (f (fix f)))
        = (f (f (f (fix f))))
        = ...
        = (n f (fix f))
</code></pre>

<p>其中<code>n</code>为任意有限的自然数。这个式子我们在之后还会用到。如果你忘记了自然数的Church计数法，可以回到<a href="/blog/2022/08/27/lambda.html">上一篇博客</a>。</p>

<h2 id="函数递归">函数递归</h2>

<p>Y组合子的一大用途，就是在λ代数中表示“递归”。</p>

<p>例如，你可能会这样写一个求阶乘的函数：</p>

<pre><code class="language-plaintext">fac = λx. (if (x==0)
                (1)
                (x*(fac (x-1))))
</code></pre>

<p>（为了方便起见，这里我就不写成前缀表达式了）</p>

<blockquote>
  <p>注：<code>if</code>语句</p>

  <p><code>(if b x y)</code>的定义是：如果<code>b</code>为真，返回<code>x</code>，否则返回<code>y</code>。</p>

  <p>根据我们对布尔值<code>T</code>和<code>F</code>的定义：</p>

  <pre><code class="language-plaintext">T := λa. λb. a
F := λa. λb. b
</code></pre>

  <p>语句<code>(if b x y)</code>可以看作是<code>(b x y)</code>的另一种写法</p>
</blockquote>

<p>可惜的是，λ演算里并没有递归的语法。但是有了Y组合子，我们也可以实现类似递归的效果。</p>

<p>首先我们重写一下刚刚的<code>fac</code>函数：</p>

<pre><code class="language-plaintext">fac = λf. λx. (if (x==0)
                    (1)
                    (x*(f (x-1))))
</code></pre>

<p>现在<code>fac</code>变成了接受一个函数<code>f</code>和参数<code>x</code>的函数。那么接下来：</p>

<pre><code class="language-lisp">(Y fac 5)
</code></pre>

<p>就可以正确地返回我们想要的结果。证明如下：</p>

<pre><code class="language-plaintext">(Y fac 5) = ((fac (Y fac)) 5)                       ; 利用(Y f)=(f (Y f))
          = (if (5==0) (1) (5*((Y fac) (5-1))))     ; 将5代入x，(Y fac)代入f
          = 5*((Y fac) 4)                           ; 展开if
          = 5*(fac (Y fac) 4)                       ; 还是(Y f)=(f (Y f))
          = 5*(if (4==0) (1) (4*((Y fac) (4-1))))   ; 继续展开
          = 5*4*((Y fac) 3)
          = ...
          = 5*4*3*2*1*((Y fac) 0)
          = 5*4*3*2*1*(fac (Y fac) 0)
          = 5*4*3*2*1*(if (0==0) (1) (0*((Y fac) (0-1))))
          = 5*4*3*2*1*1
          = 5!
</code></pre>

<p>更一般地，对于一个函数$f$：</p>

<div class="kdmath">$$
f=\lambda x_1.\ \lambda x_2.\ \lambda x_3.\ \cdots\ \lambda x_n.\ [\text{BODY}]
$$</div>

<p>而$f$的函数体中使用了递归（即：调用了自己），那么我们可以将$f$改写为$f’$使得它能够在我们的λ代数中运行：</p>

<div class="kdmath">$$
f'=\lambda g.\ \lambda x_1.\ \lambda x_2.\ \cdots\ \lambda x_n.\ [\text{BODY}][f:=g]
$$</div>

<p>后面的$[\text{BODY}][f:=g]$表示将函数体里所有出现的$f$全部替换成$g$。如果你没有理解为什么要这样做，可以仔细思考一下上面阶乘的例子。</p>

<p>进行求值的时候，只需要：</p>

<div class="kdmath">$$
((Y\ f')\ x_1\ x_2\ x_3\ \cdots\ x_n)
$$</div>

<p>就相当于计算了递归函数$f$代入参数$x_1$到$x_n$的值。</p>

<h2 id="列表和懒惰求值">列表和懒惰求值</h2>

<h3 id="列表">列表</h3>

<p>你应该还记得上篇文章的思考题里出现了一个<code>pair</code>函数。它满足：</p>

<pre><code class="language-lisp">(first (pair a b)) = a
(second (pair a b)) = b
</code></pre>

<p>一个可行的构造利用了布尔值<code>T</code>和<code>F</code>的性质：</p>

<pre><code class="language-lisp">pair := λa. λb. λt. (t a b)              ; 其中t为一个布尔值
first := λp. (p T)
second := λp. (p F)
</code></pre>

<p>在<code>pair</code>的基础上，你还可以构造出另一个数据结构：列表<code>list</code>。</p>

<pre><code class="language-lisp">(list3 a b c) := λNIL. (pair a (pair b (pair c NIL)))
(list4 a b c d) := λNIL. (pair a (pair b (pair c (pair d NIL))))
(list5 a b c d e) := λNIL. (pair a (pair b (pair c (paid d (pair e NIL)))))
</code></pre>

<p>其中<code>NIL</code>是一个占位符，用来标志列表结尾。</p>

<p>一个特殊的列表是空列表：<code>list0</code></p>

<pre><code class="language-lisp">list0 := λNIL. NIL
</code></pre>

<p>有了这些定义之后，我们就可以用递归的语法来定义列表的一些操作。比如：</p>

<h4 id="列表判空">列表判空</h4>

<p>要求：只有当传入的列表是空列表时，返回<code>T</code>，否则返回<code>F</code></p>

<pre><code class="language-lisp">null := λl. (l F (λx. λy. λz. F) T)
</code></pre>

<p>首先我们发现，除了空列表以外，其他列表都是<code>λNIL. (pair _ _)</code>的形式。将<code>pair</code>函数展开得到：<code>λNIL. λb. (b _ _)</code>。如果将函数<code>null</code>作用于这个非空列表，就会得到：</p>

<pre><code class="language-lisp">(null l) = ((λl. (l F (λx. λy. λz. F) T)) (λNIL. λb. (b _ _)))
         = ((λNIL. λb. (b _ _)) F (λx. λy. λz. F) T)
         = ((λx. λy. λz. F) _ _ T)                       ; 函数接收3个参数并返回常值F
         = F
</code></pre>

<p>而空列表则会返回：</p>

<pre><code class="language-lisp">(null list0) = ((λl. (l F (λx. λy. λz. F) T) (λNIL. NIL))
             = ((λNIL. NIL) F (λx. λy. λz. F) T)
             = (F (λx. λy. λz. F) T)
             = ((λa. λb. b) (λx. λy. λz. T) T)
             = T
</code></pre>

<h4 id="列表的第一个元素">列表的第一个元素</h4>

<pre><code class="language-lisp">car := (first (l _))
</code></pre>
<p><code>car</code>返回了列表的第一个元素，前提是列表<code>l</code>非空。</p>

<p>类似地，可以写出<code>cdr</code>，返回列表除了第一个元素以外的其他元素构成的列表：</p>

<pre><code class="language-lisp">cdr := λNIL. (second (l NIL))
</code></pre>

<p><code>car</code>和<code>cdr</code>这两个函数名可能看起来很奇怪，但这两个函数名来源于最古老的函数式编程语言：Lisp。<del>这也是Lisp的函数命名经常被吐槽的原因之一</del></p>

<h4 id="列表长度">列表长度</h4>

<p>有了<code>null</code>函数，很多列表的操作都能用递归实现了。比如列表的长度计算：</p>

<pre><code class="language-lisp">length := λl. (if (null l)
                    (0)
                    ((length (cdr l))+1))
</code></pre>

<p>注意到<code>(second l)</code>返回列表<code>l</code>从第二项到末尾的子列表，它的长度一定是原列表的长度减去1。</p>

<p>我们可以用前文所说的方法将函数转化为一个非递归函数，并用Y组合子求值。</p>

<h4 id="列表第n项">列表第<code>n</code>项</h4>

<p>假设下标从0开始。</p>

<pre><code class="language-lisp">nth := λl. λn. (if (null l)
                     (error "Index out of bound!")      ; 如果是空列表，报错
                     (if (n==0)
                          (car l)
                          (nth (cdr l) (n-1))))
</code></pre>

<p>这里利用<code>(nth l n) = (nth (cdr l) (n-1))</code>递归查找第<code>n</code>项。</p>

<h4 id="添加元素">添加元素</h4>

<pre><code class="language-lisp">append := λl. λa. λNIL. (l (pair a NIL))
</code></pre>

<p>在列表末尾追加元素<code>a</code>，相当于把列表的<code>NIL</code>替换成<code>(pair a NIL)</code>。</p>

<pre><code class="language-lisp">prepend := λl. λa. λNIL. (pair a (l NIL))
</code></pre>

<p>在列表前面添加元素<code>a</code>，相当于在原来的<code>l</code>外面套一层函数<code>(pair a)</code>。</p>

<h4 id="筛选元素">筛选元素</h4>

<p>函数<code>(filter c l)</code>返回列表<code>l</code>中所有满足条件<code>c</code>的元素构成的新列表。</p>

<pre><code class="language-lisp">filter = λc. λl.
         (if (null l)
               (list0)                                    ; 如果l是空列表，返回一个空列表
               (if (c (car l))
                     (prepend (filter (cdr l) c) (car l))
                     (filter (cdr l) c)))
</code></pre>

<p><del>如果你试着手打一下这一层套一层的括号，就能理解Lisp的痛了</del></p>

<p>例如我们有一个列表<code>l = [1, 2, 3, 4] = λNIL. (pair 1 (pair 2 (pair 3 (pair 4 NIL))))</code>，那么：</p>

<pre><code class="language-lisp">(filter (λx. x&gt;2) l)
</code></pre>

<p>就会返回列表：<code>[3, 4]</code>。而：</p>

<pre><code class="language-lisp">(filter (λx. x%2==0) l)
</code></pre>

<p>就会返回列表：<code>[2, 4]</code></p>

<h3 id="无限长列表">无限长列表</h3>

<p>既然我们定义了有限长的列表，那么是否可以定义无限长的列表？</p>

<p>不妨看一下这个递归函数：</p>

<pre><code class="language-plaintext">r := λNIL. (pair 1 (r NIL))
</code></pre>

<p>它展开后会得到一个无限重复<code>1</code>的列表：</p>

<pre><code class="language-plaintext">λNIL. (pair 1 (pair 1 (pair 1 (pair 1 (......)))))
</code></pre>

<p>稍稍更改一下，还可以得到由所有自然数构成的列表：</p>

<pre><code class="language-plaintext">s := λn. λNIL. (pair n (s n+1 NIL))
(s 0) = λNIL. (pair 0 (pair 1 (pair 2 (pair 3 (......)))))
</code></pre>

<p>接下来我们探讨一下类似这样的列表的性质：</p>

<h4 id="判空">判空</h4>

<p>以上文中的<code>r=(1, 1, 1, 1, ...)</code>为例。把递归转化成Y组合子的形式，就可以得到：</p>

<pre><code class="language-lisp">r' = λf. λNIL. (pair 1 (f NIL))
(null r) = (null (Y r'))
         = ((Y r') F (λx. λy. λz. F) T)
         = ((λNIL. pair 1 (Y r' NIL)) F (λx. λy. λz. F) T)
         = ((λx. λy. λz. F) 1 (Y r' _) T)
         = F
</code></pre>

<p>这个结果也在意料之内，因为无限长的列表肯定不是空的。类似的，你也可以证明列表<code>s</code>非空。</p>

<h4 id="第n个元素">第<code>n</code>个元素</h4>

<p>先看看<code>r=[1, 1, 1, 1, ...]</code>：</p>

<pre><code class="language-lisp">r' = λf. λNIL. (pair 1 (f NIL))
(nth r n) = (nth (Y r') n)
          = (if (null (Y r'))
                  (_)
                  (if (n==0)
                        (car (Y r'))
                        (nth (cdr (Y r')) (n-1))))
          = (if (n==0)                                 ; 根据前文的结论，(null r) = F，跳过第一个分支
                  (car (Y r'))
                  (nth (cdr (Y r')) (n-1)))
</code></pre>

<blockquote>
  <p>引理：</p>

  <pre><code class="language-lisp">(car (Y r')) = (car (r' (Y r')))
             = (car (λNIL. pair 1 (Y r' NIL)))
             = 1
</code></pre>

  <pre><code class="language-lisp">(cdr (Y r')) = (cdr (r' (Y r')))
             = (cdr (λNIl. pair 1 (Y r' NIL)))
             = λNIL. (Y r' NIL)
             = (Y r')
</code></pre>
  <p>换句话说，列表<code>(Y r')</code>的第一个元素永远是<code>1</code>，而它从第二个元素开始的子列表就是自己</p>
</blockquote>

<p>回到上面的证明：</p>

<pre><code class="language-lisp">(nth r n) = (if (n==0)
                  (1)
                  (nth r n-1))
</code></pre>

<p>由于<code>n</code>是自然数，函数重复足够多轮数之后，一定会让<code>n</code>减少到<code>0</code>，此时函数返回<code>1</code>。也就是：</p>

<pre><code class="language-lisp">(nth r n) = 1
</code></pre>

<p>接着我们再说<code>s</code>。使用类似的方法可以得到：</p>

<pre><code class="language-lisp">s' = λf. λn. λNIL. (pair n (f n+1 NIL))
(car (s n)) = (car (Y s' n)) = n
(cdr (s n)) = (cdr (Y s' n)) = (s n+1)
</code></pre>

<p>根据这两个结论，可以推出来：</p>

<pre><code class="language-lisp">(nth (s n) m) = (if (m==0)
                      (car (s n))
                      (nth (cdr (s n)) m-1))
              = (if (m==0)
                      (n)
                      (nth (s n+1) m-1))
</code></pre>

<p>根据数学归纳法，不难知道：<code>(nth (s n) m)</code>的返回值为<code>n+m</code>。特别地，<code>(nth (s 0) m)</code>就是<code>m</code>。</p>

<h3 id="懒惰求值">懒惰求值</h3>

<p>当然，无限长列表的应用远不止这些。比如，斐波那契数列：</p>

<pre><code class="language-lisp">fib = λa. λb. λNIL. (pair a (fib b a+b NIL))
(fib 1 1)       ; [1, 1, 2, 3, 5, 8, 13, ...]
</code></pre>

<p>甚至我们可以使用埃氏筛算法，写出一个装满所有质数的列表：</p>

<pre><code class="language-lisp">sieve := λl. (prepend
               (sieve (filter (λx. x%(car l)!=0) (cdr l)))  ; 去掉(cdr l)中所有(car l)的倍数
               (car l))

(sieve (s 2))           ; [2, 3, 5, 7, 11, 13, 17, ...]
</code></pre>

<p>如果你使用过haskell或者其他支持数组懒惰求值的编程语言，应该或多或少了解过这种写法。它允许你使用有限的语言来描述一个无限长的数列！</p>

<p><em>当然，懒惰求值只能表示出<strong>可计算</strong>的无限序列，例如上面说的斐波那契数列和质数数列，或者π的第n位等。这是因为，λ演算的计算能力和图灵机是等价的，任何不能用图灵机算出的数值同样也不能用λ演算算出来。</em></p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="lambda-calculus" /><category term="computation" /><summary type="html"><![CDATA[]]></summary></entry></feed>