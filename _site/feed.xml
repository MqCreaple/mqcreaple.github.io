<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="mqcreaple.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="mqcreaple.github.io/" rel="alternate" type="text/html" /><updated>2022-09-10T01:24:15-04:00</updated><id>mqcreaple.github.io/feed.xml</id><title type="html">My Blog | MqCreaple</title><subtitle>pay more attention to the beauty of formulas!</subtitle><author><name>MqCreaple</name></author><entry><title type="html">【整活】所有算法都是O(1)的</title><link href="mqcreaple.github.io/blog/2022/09/06/time-compl.html" rel="alternate" type="text/html" title="【整活】所有算法都是O(1)的" /><published>2022-09-06T00:00:00-04:00</published><updated>2022-09-06T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/09/06/time-compl</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/09/06/time-compl.html"><![CDATA[<p><em>注：本文全部内容为<strong>一本正经的胡说八道</strong>，请勿相信</em></p>

<h2 id="示范快速排序算法">示范：快速排序算法</h2>

<p><strong>第一步：复制粘贴一份代码</strong></p>

<pre><code class="language-cpp">void qsort(int *a, int l, int r)
{
    int pivot = a[(l+r)/2];
    int i = l, j = r;
    do {
        while(a[i] &lt; pivot) i++;
        while(a[j] &gt; pivot) j--;
        if(i&lt;=j) {
            swap(a[i], a[j]);
            i++;
            j--;
        }
    } while(i &lt;= j);
    if(l &lt; j) qsort(a, l, j);
    if(i &lt; r) qsort(a, i, r);
}
int main() {
    const int N = 100001;
    int n;
    int a[N];
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
    }
    qsort(a, 0, n-1);            // sort the array
    for(int i = 0; i &lt; n; i++) {
        cout &lt;&lt; a[i] &lt;&lt; " ";
    }
}
</code></pre>

<p>然后我们很失望，因为这个算法是$O(N\log N)$的。</p>

<p><strong>第二步：观察数据范围</strong></p>

<p><img src="/img/time-compl-0.png" alt="time-compl-0" /></p>

<p>我们发现，$N$不超过$10^5$，接下来就有办法了。</p>

<p><strong>第三步：补齐数组</strong></p>

<p>在我们的代码里面更改下面几处：</p>

<pre><code class="language-diff">int main() {
    const int N = 100001;
    int n;
    int a[N];
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
    }
+   for(int i = n; i &lt; N; i++) {
+       a[i] = INT32_MAX;       // fill the rest of array with INT32_MAX
+   }
-   sort(a, 0, n-1);            // sort the array
+   sort(a, 0, N-1);            // sort the whole array
    for(int i = 0; i &lt; n; i++) {
        cout &lt;&lt; a[i] &lt;&lt; " ";
    }
}
</code></pre>

<p>然后你就惊奇地发现，不管你输入的数组是多大，这个算法都会排序$1$到$N$之间的所有数，它所需要的执行时间都是一样的。换句话说：<strong>这个算法是$O(1)$的</strong>。</p>

<p><strong>第四步：为自己献上热烈的掌声</strong></p>

<p>至此，你成功地将一个$O(N\log N)$的算法变成了$O(1)$的算法。</p>

<h2 id="练习">练习</h2>

<ol>
  <li>$O(1)$计算快速幂</li>
  <li>$O(1)$解决图的最短路问题</li>
  <li>$O(1)$解决A+B problem</li>
</ol>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="algorithm" /><category term="time-complexity" /><category term="jokes" /><summary type="html"><![CDATA[注：本文全部内容为一本正经的胡说八道，请勿相信]]></summary></entry><entry><title type="html">Y combinator和递归</title><link href="mqcreaple.github.io/blog/2022/09/02/y-combinator.html" rel="alternate" type="text/html" title="Y combinator和递归" /><published>2022-09-02T00:00:00-04:00</published><updated>2022-09-02T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/09/02/y-combinator</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/09/02/y-combinator.html"><![CDATA[<link rel="stylesheet" href="/app/lambda-playground/lambda-playground.css" />

<script src="/app/lambda-playground/lambda-playground.js" onload="autoRender()"></script>

<p><strong>温馨提示：如果你不了解λ演算，请阅读<a href="/blog/2022/08/27/lambda.html">上一篇博客</a>以获得最佳食用体验</strong></p>

<p><em>注：本文的λ表达式中所有出现的下划线<code>_</code>，都表示“这个值我懒得算且不关心”</em></p>

<h2 id="y组合子">Y组合子</h2>

<p>其实，并不是所有的λ表达式都可以化简。比如说，一个经典的构造就是：</p>

<pre><code class="language-plaintext">Ω := ((λx. (x x)) (λx. (x x)))
</code></pre>

<p class="lambda-r">[ [ "λx", [ "x", "x" ] ], [ "λx", [ "x", "x" ] ] ]</p>

<p>这个表达式很有意思。当你把后面的表达式代入前面的<code>x</code>中时，你又会得到和原来一摸一样的表达式，你永远也无法化简它。也就是，它是<strong>不可求值</strong>的。</p>

<p>而我们对这个表达式简单地变一下，就得到了另一个表达式：</p>

<pre><code class="language-plaintext">((λx. f (x x)) (λx. f (x x)))
</code></pre>

<p class="lambda-r">[ [ "λx", [ "f", [ "x", "x" ] ] ], [ "λx", [ "f", [ "x", "x" ] ] ] ]</p>

<p>当你把后一项代入前一项时，它不仅得到了原来的表达式，而且还在外面多套上了一层函数<code>f</code>。再进行一次替换操作，函数外面又多了一层<code>f</code>，你可以一直这样无穷无尽地迭代下去。</p>

<p>稍稍将外面这个函数改一下，就得到了著名的<strong>Y组合子(Y combinator)</strong>：</p>

<pre><code class="language-lisp">Y := λf. ((λx. f (x x)) (λx. f (x x)))
</code></pre>

<p>Y组合子的一大性质就是：</p>

<pre><code class="language-lisp">(Y f) = (f (Y f))
</code></pre>

<p>由于它和函数的不动点$x=f(x)$长得很像，所以Y组合子也叫<strong>不动点组合子(fixed point combinator)</strong>。</p>

<p><em>注：Y组合子并不是唯一的不动点组合子。比如由Alan Turing给出的Θ组合子</em></p>

<pre><code class="language-lisp">Θ := ((λx. λy. y (x x y)) (λx. λy. y (x x y)))
</code></pre>

<p><em>它同样满足不动点组合子的性质：</em></p>

<pre><code class="language-lisp">(Θ f) = (f (Θ f))
</code></pre>

<p>根据不动点组合子的性质，任何不动点组合子<code>fix</code>都有：</p>

<pre><code class="language-lisp">(fix f) = (f (fix f))
        = (f (f (fix f)))
        = (f (f (f (fix f))))
        = ...
        = (n f (fix f))
</code></pre>

<p>其中<code>n</code>为任意有限的自然数。这个式子我们在之后还会用到。如果你忘记了自然数的Church计数法，可以回到<a href="/blog/2022/08/27/lambda.html">上一篇博客</a>。</p>

<h2 id="函数递归">函数递归</h2>

<p>Y组合子的一大用途，就是在λ代数中表示“递归”。</p>

<p>例如，你可能会这样写一个求阶乘的函数：</p>

<pre><code class="language-plaintext">fac = λx. (if (x==0)
                (1)
                (x*(fac (x-1))))
</code></pre>

<p>（为了方便起见，这里我就不写成前缀表达式了）</p>

<blockquote>
  <p>注：<code>if</code>语句</p>

  <p><code>(if b x y)</code>的定义是：如果<code>b</code>为真，返回<code>x</code>，否则返回<code>y</code>。</p>

  <p>根据我们对布尔值<code>T</code>和<code>F</code>的定义：</p>

  <pre><code class="language-plaintext">T := λa. λb. a
F := λa. λb. b
</code></pre>

  <p>语句<code>(if b x y)</code>可以看作是<code>(b x y)</code>的另一种写法</p>
</blockquote>

<p>可惜的是，λ演算里并没有递归的语法。但是有了Y组合子，我们也可以实现类似递归的效果。</p>

<p>首先我们重写一下刚刚的<code>fac</code>函数：</p>

<pre><code class="language-plaintext">fac = λf. λx. (if (x==0)
                    (1)
                    (x*(f (x-1))))
</code></pre>

<p>现在<code>fac</code>变成了接受一个函数<code>f</code>和参数<code>x</code>的函数。那么接下来：</p>

<pre><code class="language-lisp">(Y fac 5)
</code></pre>

<p>就可以正确地返回我们想要的结果。证明如下：</p>

<pre><code class="language-plaintext">(Y fac 5) = ((fac (Y fac)) 5)                       ; 利用(Y f)=(f (Y f))
          = (if (5==0) (1) (5*((Y fac) (5-1))))     ; 将5代入x，(Y fac)代入f
          = 5*((Y fac) 4)                           ; 展开if
          = 5*(fac (Y fac) 4)                       ; 还是(Y f)=(f (Y f))
          = 5*(if (4==0) (1) (4*((Y fac) (4-1))))   ; 继续展开
          = 5*4*((Y fac) 3)
          = ...
          = 5*4*3*2*1*((Y fac) 0)
          = 5*4*3*2*1*(fac (Y fac) 0)
          = 5*4*3*2*1*(if (0==0) (1) (0*((Y fac) (0-1))))
          = 5*4*3*2*1*1
          = 5!
</code></pre>

<p>更一般地，对于一个函数$f$：</p>

<div class="kdmath">$$
f=\lambda x_1.\ \lambda x_2.\ \lambda x_3.\ \cdots\ \lambda x_n.\ [\text{BODY}]
$$</div>

<p>而$f$的函数体中使用了递归（即：调用了自己），那么我们可以将$f$改写为$f’$使得它能够在我们的λ代数中运行：</p>

<div class="kdmath">$$
f'=\lambda g.\ \lambda x_1.\ \lambda x_2.\ \cdots\ \lambda x_n.\ [\text{BODY}][f:=g]
$$</div>

<p>后面的$[\text{BODY}][f:=g]$表示将函数体里所有出现的$f$全部替换成$g$。如果你没有理解为什么要这样做，可以仔细思考一下上面阶乘的例子。</p>

<p>进行求值的时候，只需要：</p>

<div class="kdmath">$$
((Y\ f')\ x_1\ x_2\ x_3\ \cdots\ x_n)
$$</div>

<p>就相当于计算了递归函数$f$代入参数$x_1$到$x_n$的值。</p>

<h2 id="列表和懒惰求值">列表和懒惰求值</h2>

<h3 id="列表">列表</h3>

<p>你应该还记得上篇文章的思考题里出现了一个<code>pair</code>函数。它满足：</p>

<pre><code class="language-lisp">(first (pair a b)) = a
(second (pair a b)) = b
</code></pre>

<p>一个可行的构造利用了布尔值<code>T</code>和<code>F</code>的性质：</p>

<pre><code class="language-lisp">pair := λa. λb. λt. (t a b)              ; 其中t为一个布尔值
first := λp. (p T)
second := λp. (p F)
</code></pre>

<p>在<code>pair</code>的基础上，你还可以构造出另一个数据结构：列表<code>list</code>。</p>

<pre><code class="language-lisp">(list3 a b c) := λNIL. (pair a (pair b (pair c NIL)))
(list4 a b c d) := λNIL. (pair a (pair b (pair c (pair d NIL))))
(list5 a b c d e) := λNIL. (pair a (pair b (pair c (paid d (pair e NIL)))))
</code></pre>

<p>其中<code>NIL</code>是一个占位符，用来标志列表结尾。</p>

<p>一个特殊的列表是空列表：<code>list0</code></p>

<pre><code class="language-lisp">list0 := λNIL. NIL
</code></pre>

<p>有了这些定义之后，我们就可以用递归的语法来定义列表的一些操作。比如：</p>

<h4 id="列表判空">列表判空</h4>

<p>要求：只有当传入的列表是空列表时，返回<code>T</code>，否则返回<code>F</code></p>

<pre><code class="language-lisp">null := λl. (l F (λx. λy. λz. F) T)
</code></pre>

<p>首先我们发现，除了空列表以外，其他列表都是<code>λNIL. (pair _ _)</code>的形式。将<code>pair</code>函数展开得到：<code>λNIL. λb. (b _ _)</code>。如果将函数<code>null</code>作用于这个非空列表，就会得到：</p>

<pre><code class="language-lisp">(null l) = ((λl. (l F (λx. λy. λz. F) T)) (λNIL. λb. (b _ _)))
         = ((λNIL. λb. (b _ _)) F (λx. λy. λz. F) T)
         = ((λx. λy. λz. F) _ _ T)                       ; 函数接收3个参数并返回常值F
         = F
</code></pre>

<p>而空列表则会返回：</p>

<pre><code class="language-lisp">(null list0) = ((λl. (l F (λx. λy. λz. F) T) (λNIL. NIL))
             = ((λNIL. NIL) F (λx. λy. λz. F) T)
             = (F (λx. λy. λz. F) T)
             = ((λa. λb. b) (λx. λy. λz. T) T)
             = T
</code></pre>

<h4 id="列表的第一个元素">列表的第一个元素</h4>

<pre><code class="language-lisp">car := (first (l _))
</code></pre>
<p><code>car</code>返回了列表的第一个元素，前提是列表<code>l</code>非空。</p>

<p>类似地，可以写出<code>cdr</code>，返回列表除了第一个元素以外的其他元素构成的列表：</p>

<pre><code class="language-lisp">cdr := λNIL. (second (l NIL))
</code></pre>

<p><code>car</code>和<code>cdr</code>这两个函数名可能看起来很奇怪，但这两个函数名来源于最古老的函数式编程语言：Lisp。<del>这也是Lisp的函数命名经常被吐槽的原因之一</del></p>

<h4 id="列表长度">列表长度</h4>

<p>有了<code>null</code>函数，很多列表的操作都能用递归实现了。比如列表的长度计算：</p>

<pre><code class="language-lisp">length := λl. (if (null l)
                    (0)
                    ((length (cdr l))+1))
</code></pre>

<p>注意到<code>(second l)</code>返回列表<code>l</code>从第二项到末尾的子列表，它的长度一定是原列表的长度减去1。</p>

<p>我们可以用前文所说的方法将函数转化为一个非递归函数，并用Y组合子求值。</p>

<h4 id="列表第n项">列表第<code>n</code>项</h4>

<p>假设下标从0开始。</p>

<pre><code class="language-lisp">nth := λl. λn. (if (null l)
                     (error "Index out of bound!")      ; 如果是空列表，报错
                     (if (n==0)
                          (car l)
                          (nth (cdr l) (n-1))))
</code></pre>

<p>这里利用<code>(nth l n) = (nth (cdr l) (n-1))</code>递归查找第<code>n</code>项。</p>

<h4 id="添加元素">添加元素</h4>

<pre><code class="language-lisp">append := λl. λa. λNIL. (l (pair a NIL))
</code></pre>

<p>在列表末尾追加元素<code>a</code>，相当于把列表的<code>NIL</code>替换成<code>(pair a NIL)</code>。</p>

<pre><code class="language-lisp">prepend := λl. λa. λNIL. (pair a (l NIL))
</code></pre>

<p>在列表前面添加元素<code>a</code>，相当于在原来的<code>l</code>外面套一层函数<code>(pair a)</code>。</p>

<h4 id="筛选元素">筛选元素</h4>

<p>函数<code>(filter c l)</code>返回列表<code>l</code>中所有满足条件<code>c</code>的元素构成的新列表。</p>

<pre><code class="language-lisp">filter = λc. λl.
         (if (null l)
               (list0)                                    ; 如果l是空列表，返回一个空列表
               (if (c (car l))
                     (prepend (filter (cdr l) c) (car l))
                     (filter (cdr l) c)))
</code></pre>

<p><del>如果你试着手打一下这一层套一层的括号，就能理解Lisp的痛了</del></p>

<p>例如我们有一个列表<code>l = [1, 2, 3, 4] = λNIL. (pair 1 (pair 2 (pair 3 (pair 4 NIL))))</code>，那么：</p>

<pre><code class="language-lisp">(filter (λx. x&gt;2) l)
</code></pre>

<p>就会返回列表：<code>[3, 4]</code>。而：</p>

<pre><code class="language-lisp">(filter (λx. x%2==0) l)
</code></pre>

<p>就会返回列表：<code>[2, 4]</code></p>

<h3 id="无限长列表">无限长列表</h3>

<p>既然我们定义了有限长的列表，那么是否可以定义无限长的列表？</p>

<p>不妨看一下这个递归函数：</p>

<pre><code class="language-plaintext">r := λNIL. (pair 1 (r NIL))
</code></pre>

<p>它展开后会得到一个无限重复<code>1</code>的列表：</p>

<pre><code class="language-plaintext">λNIL. (pair 1 (pair 1 (pair 1 (pair 1 (......)))))
</code></pre>

<p>稍稍更改一下，还可以得到由所有自然数构成的列表：</p>

<pre><code class="language-plaintext">s := λn. λNIL. (pair n (s n+1 NIL))
(s 0) = λNIL. (pair 0 (pair 1 (pair 2 (pair 3 (......)))))
</code></pre>

<p>接下来我们探讨一下类似这样的列表的性质：</p>

<h4 id="判空">判空</h4>

<p>以上文中的<code>r=(1, 1, 1, 1, ...)</code>为例。把递归转化成Y组合子的形式，就可以得到：</p>

<pre><code class="language-lisp">r' = λf. λNIL. (pair 1 (f NIL))
(null r) = (null (Y r'))
         = ((Y r') F (λx. λy. λz. F) T)
         = ((λNIL. pair 1 (Y r' NIL)) F (λx. λy. λz. F) T)
         = ((λx. λy. λz. F) 1 (Y r' _) T)
         = F
</code></pre>

<p>这个结果也在意料之内，因为无限长的列表肯定不是空的。类似的，你也可以证明列表<code>s</code>非空。</p>

<h4 id="第n个元素">第<code>n</code>个元素</h4>

<p>先看看<code>r=[1, 1, 1, 1, ...]</code>：</p>

<pre><code class="language-lisp">r' = λf. λNIL. (pair 1 (f NIL))
(nth r n) = (nth (Y r') n)
          = (if (null (Y r'))
                  (_)
                  (if (n==0)
                        (car (Y r'))
                        (nth (cdr (Y r')) (n-1))))
          = (if (n==0)                                 ; 根据前文的结论，(null r) = F，跳过第一个分支
                  (car (Y r'))
                  (nth (cdr (Y r')) (n-1)))
</code></pre>

<blockquote>
  <p>引理：</p>

  <pre><code class="language-lisp">(car (Y r')) = (car (r' (Y r')))
             = (car (λNIL. pair 1 (Y r' NIL)))
             = 1
</code></pre>

  <pre><code class="language-lisp">(cdr (Y r')) = (cdr (r' (Y r')))
             = (cdr (λNIl. pair 1 (Y r' NIL)))
             = λNIL. (Y r' NIL)
             = (Y r')
</code></pre>
  <p>换句话说，列表<code>(Y r')</code>的第一个元素永远是<code>1</code>，而它从第二个元素开始的子列表就是自己</p>
</blockquote>

<p>回到上面的证明：</p>

<pre><code class="language-lisp">(nth r n) = (if (n==0)
                  (1)
                  (nth r n-1))
</code></pre>

<p>由于<code>n</code>是自然数，函数重复足够多轮数之后，一定会让<code>n</code>减少到<code>0</code>，此时函数返回<code>1</code>。也就是：</p>

<pre><code class="language-lisp">(nth r n) = 1
</code></pre>

<p>接着我们再说<code>s</code>。使用类似的方法可以得到：</p>

<pre><code class="language-lisp">s' = λf. λn. λNIL. (pair n (f n+1 NIL))
(car (s n)) = (car (Y s' n)) = n
(cdr (s n)) = (cdr (Y s' n)) = (s n+1)
</code></pre>

<p>根据这两个结论，可以推出来：</p>

<pre><code class="language-lisp">(nth (s n) m) = (if (m==0)
                      (car (s n))
                      (nth (cdr (s n)) m-1))
              = (if (m==0)
                      (n)
                      (nth (s n+1) m-1))
</code></pre>

<p>根据数学归纳法，不难知道：<code>(nth (s n) m)</code>的返回值为<code>n+m</code>。特别地，<code>(nth (s 0) m)</code>就是<code>m</code>。</p>

<h3 id="懒惰求值">懒惰求值</h3>

<p>当然，无限长列表的应用远不止这些。比如，斐波那契数列：</p>

<pre><code class="language-lisp">fib = λa. λb. λNIL. (pair a (fib b a+b NIL))
(fib 1 1)       ; [1, 1, 2, 3, 5, 8, 13, ...]
</code></pre>

<p>甚至我们可以使用埃氏筛算法，写出一个装满所有质数的列表：</p>

<pre><code class="language-lisp">sieve := λl. (prepend
               (sieve (filter (λx. x%(car l)!=0) (cdr l)))  ; 去掉(cdr l)中所有(car l)的倍数
               (car l))

(sieve (s 2))           ; [2, 3, 5, 7, 11, 13, 17, ...]
</code></pre>

<p>如果你使用过haskell或者其他支持数组懒惰求值的编程语言，应该或多或少了解过这种写法。它允许你使用有限的语言来描述一个无限长的数列！</p>

<p><em>当然，懒惰求值只能表示出<strong>可计算</strong>的无限序列，例如上面说的斐波那契数列和质数数列，或者π的第n位等。这是因为，λ演算的计算能力和图灵机是等价的，任何不能用图灵机算出的数值同样也不能用λ演算算出来。</em></p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="lambda-calculus" /><category term="computation" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">用λ演算建立数学</title><link href="mqcreaple.github.io/blog/2022/08/27/lambda.html" rel="alternate" type="text/html" title="用λ演算建立数学" /><published>2022-08-27T00:00:00-04:00</published><updated>2022-08-27T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/08/27/lambda</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/08/27/lambda.html"><![CDATA[<link rel="stylesheet" href="/app/lambda-playground/lambda-playground.css" />

<script src="/app/lambda-playground/lambda-playground.js" onload="autoRender()"></script>

<p>在古早之前（大约我初一的时候），我写过一篇博客<del>遗憾的是现在它已经找不到了</del>，讲述了如何用纯集合论的方法构建自然数。学过数学分析的小朋友们相信对这个知识点已经不陌生了。</p>

<p>不过，集合论并不是唯一一种可以用来构建自然数的方法。今天，我就要介绍另一个可行的方法：<strong>λ演算</strong>。</p>

<p>当然在这之前，我先简单介绍一下λ演算：</p>

<h2 id="什么是λ演算">什么是λ演算？</h2>

<p>相信大家对函数已经不陌生了。比如下面这个函数：</p>

<div class="kdmath">$$
f(x)=2x
$$</div>

<p>它输入一个变量$x$，输出一个数，并且满足输出的数一定是输入的两倍。</p>

<p>接下来我们介绍一种新的记号，用来表示同一个函数：</p>

<div class="kdmath">$$
f=\lambda x.\ 2x
$$</div>

<p>这个表达式分为两段，第一段以λ开头，表示一个参数，第二段则是函数体。我们称这样的表达式为：<strong>λ表达式</strong>。</p>

<p>同时，我们也简单修改一下调用函数的记号：把括号写在函数前面，而不是后面</p>

<div class="kdmath">$$
\begin{align*}
(f\ 2) &= ((\lambda x.\ 2x)\ 2) \\
&= 2\cdot 2 \\
&= 4
\end{align*}
$$</div>

<p>我知道这对初学者来说看起来很别扭，但只要熟悉就好了。</p>

<p>λ表达式的求值很简单。只需要找到和传入的参数相对应的λ项，然后将函数体的所有对应项全都替换成传入的参数即可。</p>

<h3 id="多元函数">多元函数</h3>

<p>你可能会问，如果函数接受多个参数，该怎么办？比如下面这个函数：</p>

<div class="kdmath">$$
f(x, y)=x+2y
$$</div>

<p>答案很简单，只需要这样写：</p>

<div class="kdmath">$$
f=\lambda x.\ \lambda y.\ x+2y
$$</div>

<p>表达式前面有两个$\lambda$，就表示函数接受两个参数。比如：</p>

<div class="kdmath">$$
\begin{align*}
(f\ 2\ 3) &= ((\lambda x.\ \lambda y.\ x+2y)\ 2\ 3) \\
&= 2+2\cdot 3 \\
&= 8
\end{align*}
$$</div>

<p>同时，这个表达式还有一种解读方法。我们将$f$看作一个关于$x$的单值函数，但函数返回了另一个λ表达式：</p>

<div class="kdmath">$$
f=\lambda x.\ (\lambda y.\ x+2y)
$$</div>

<div class="kdmath">$$
\begin{align*}
(f\ 2) &= ((\lambda x.\ (\lambda y.\ x+2y))\ 2) \\
&= \lambda y.\ 2+2y
\end{align*}
$$</div>

<p>此时它的返回值还需要再接受一个参数，才能得到一个确定的值。</p>

<p>换句话说，我们把一个二元函数，变成了一个“返回一个一元函数”的一元函数。我们称这个步骤为函数的<strong>柯里化（Currying）</strong>。它同样适用于更多元的函数。</p>

<div class="kdmath">$$
f:U\times V\to W\quad\simeq\quad g:U\to(V\to W)
$$</div>

<blockquote>
  <p>柯里化是λ演算和函数式编程的一大难点，同时也是一大精妙之处</p>
</blockquote>

<p>进一步推广，我们还可以把常数看作是一个接受0个参数的函数，只不过没什么必要去这样做罢了。</p>

<p>当然了，常见的加减乘除之类的运算都是二元函数，因此其实在标准的λ语法中，四则运算应该这样写：</p>

<div class="kdmath">$$
a+b \Rightarrow (+\ a\ b)
$$</div>

<div class="kdmath">$$
a-b \Rightarrow (-\ a\ b)
$$</div>

<div class="kdmath">$$
a\cdot b \Rightarrow (*\ a\ b)
$$</div>

<div class="kdmath">$$
a/b \Rightarrow (/\ a\ b)
$$</div>

<p>如果你学过波兰表达式(Polish Notation)，你应该对这样的写法不陌生：<strong>这其实就是加上括号的波兰表达式！</strong></p>

<p>当然，除了四则运算，其他的二元运算都有类似的规则，例如判断运算（$\gt, \lt, =, \ne, \ge, \le$），逻辑运算（<code>AND</code>, <code>OR</code>, <code>NOT</code>）等。</p>

<blockquote>
  <p>思考题：结合上述知识，你能说说这些表达式是什么含义吗？</p>

  <div class="kdmath">$$
(*\ 3)
$$</div>

  <div class="kdmath">$$
(=\ 2)
$$</div>
</blockquote>

<h2 id="函数的函数">“函数”的函数</h2>

<p>我们发现，λ表达式并没有对参数的类型做限定。也就是说，<em>向λ表达式里传入一个函数也是完全合法的！</em></p>

<p>我们看一个例子：</p>

<div class="kdmath">$$
R=\lambda f.\ \lambda x.\ (f\ (f\ x))
$$</div>

<p>这个表达式$R$的意义就是：传入一个函数和一个值，把这个函数在值上做两遍。</p>

<p>举个例子：</p>

<div class="kdmath">$$
\begin{align*}
(R\ (\lambda x.\ x^2)\ 2) &= ((\lambda f.\ \lambda x.\ (f\ (f\ x)))\ (\lambda x.\ x^2))\ 2) \\
&= ((\lambda x.\ x^2)\ ((\lambda x.\ x^2)\ 2)) \\
&= ((\lambda x.\ x^2)\ 4) \\
&= 16
\end{align*}
$$</div>

<p>下面是一个简单的演示。点击图中的$R$将其展开，拖动函数参数到对应的λ位置来进行参数替换。</p>

<p class="lambda-r" data-repl-table="{ &quot;R&quot;: [ &quot;λf&quot;, &quot;λx&quot;, [ &quot;f&quot;, [ &quot;f&quot;, &quot;x&quot; ] ] ] }">[ "R", [ "λx", [ "^", "x", "2" ] ], "2" ]</p>

<p>当然，使用前面<em>柯里化</em>的思想，我们也可以这样看：$R$输入一个λ表达式，输出一个λ表达式，其中输出的表达式是输入的表达式重复两遍的结果。</p>

<div class="kdmath">$$
(R\ f)=\lambda x.\ (f\ (f\ x))
$$</div>

<p>同时这也告诉我们一个道理：在λ语言中，很多情况下括号是不能省略的。比如</p>

<div class="kdmath">$$
(f\ (g\ x))
$$</div>

<p>就是变量$x$先被$g$作用再被$f$作用，而</p>

<div class="kdmath">$$
(f\ g\ x)
$$</div>

<p>则是函数$g$和变量$x$同时传入$f$中。</p>

<h2 id="逻辑运算">逻辑运算</h2>

<p>相信从上面的介绍中，你已经初步掌握了λ演算。接下来我们将要玩一个小游戏：只用λ演算，不用任何额外的工具（包括逻辑运算，数值运算等一切你熟悉到不能再熟悉的东西），看看你能搭建出什么东西。</p>

<p>没有逻辑运算，就意味着我们没有定义“真”、“假”等概念。那么，我们能不能从λ演算中把这些东西定义出来呢？</p>

<p>首先我们想到，“真”和“假”是一组对立的概念，就像是硬币的两面。从这里出发，我们先写出这样的定义：</p>

<div class="kdmath">$$
T:=\lambda x.\ \lambda y.\ x
$$</div>

<div class="kdmath">$$
F:=\lambda x.\ \lambda y.\ y
$$</div>

<p>在这样的定义下，“真”就是给定两个东西取出第一个，而“假”则是给定两个东西取出第二个。注意到这两个定义中我们没有用到任何运算。</p>

<h3 id="逻辑非">逻辑非</h3>

<p>有了这两个定义，那么逻辑非（Not）就很好定义了。它的定义如下：</p>

<div class="kdmath">$$
(\lnot) := \lambda a.\ (a\ F\ T)
$$</div>

<p>不要忘记了$T$和$F$的含义：$T$表示选择第一个东西，而$F$表示选择第二个东西。也就是说，如果$a=T$，它就会选择第一个参数，也就是$F$；反之，如果$a=F$，它就会选第二个参数，就是$T$。</p>

<p>如果你没有理解这个定义，不妨看下面的演示。请你按照以下顺序操作：</p>

<ol>
  <li>点击<code>NOT</code>将其展开</li>
  <li>将后面的<code>T</code>或<code>F</code>拖动到对应位置</li>
  <li>将首位的<code>T</code>或<code>F</code>展开</li>
  <li>将后面的两个参数拖动到对应位置</li>
</ol>

<p class="lambda-r">[ "NOT", "T" ]</p>

<p class="lambda-r">[ "NOT", "F" ]</p>

<h3 id="逻辑与和逻辑或">逻辑与和逻辑或</h3>

<p>逻辑与的定义则相对复杂，因为它需要接受两个参数。</p>

<p>不难发现，计算$a\land b$时，假如$a$为真，则运算结果就等于$b$，反之如果$a$为假，则运算结果一定是假。</p>

<p>因此我们给出了逻辑与的λ定义：</p>

<div class="kdmath">$$
(\land):=\lambda a.\ \lambda b.\ (a\ b\ F)
$$</div>

<p>类似地，如果$a=T$，那么就会选择第一个参数$b$，它的返回值就取决于$b$的值；而如果$a=F$，它就一定会返回$F$。</p>

<p>同样你也可以看这里的演示：</p>

<p class="lambda-r">[ "AND", "T", "T" ]</p>

<p class="lambda-r">[ "AND", "T", "F" ]</p>

<p class="lambda-r">[ "AND", "F", "T" ]</p>

<p class="lambda-r">[ "AND", "F", "F" ]</p>

<p>类比逻辑与的定义，我们也可以写出逻辑或的定义：</p>

<div class="kdmath">$$
(\lor):=\lambda a.\ \lambda b.\ (a\ T\ b)
$$</div>

<p>以及演示：</p>

<p class="lambda-r">[ "OR", "T", "T" ]</p>

<p class="lambda-r">[ "OR", "T", "F" ]</p>

<p class="lambda-r">[ "OR", "F", "T" ]</p>

<p class="lambda-r">[ "OR", "F", "F" ]</p>

<h3 id="组合逻辑">组合逻辑</h3>

<p>有了逻辑运算的三兄弟：与、或、非，其余的一切逻辑运算都可以被表示出来了。比如：</p>

<div class="kdmath">$$
\text{xor}:=\lambda a.\ \lambda b.\ (\lor\ (\land\ a\ (\lnot\ b))\ (\land\ b\ (\lnot\ a)))
$$</div>

<p>当然也可利用λ的性质，写出一个更简洁的异或运算：</p>

<div class="kdmath">$$
\text{xor}:=\lambda a.\ \lambda b.\ (a\ (\lnot\ b)\ b)
$$</div>

<h3 id="谓词和逻辑运算">谓词和逻辑运算</h3>

<p>我们定义，如果有一个λ表达式$p$的返回值要么是$T$，要么是$F$，则$p$称为一个<strong>谓词</strong>。</p>

<p>比如，判断两个自然数相等的运算：</p>

<div class="kdmath">$$
(=\ a\ b)
$$</div>

<p>就是一个谓词。</p>

<h2 id="自然数">自然数</h2>

<p>回想一下自然数的五条公理：</p>

<ol>
  <li>$0$是自然数</li>
  <li>每一个自然数$n$都有一个后继，记为$n^+$</li>
  <li>任何两个不同的元素，它们的后继也不同
    <ul>
      <li>或者说，$(n^+)$这个函数是$\N\to \N$的单射</li>
    </ul>
  </li>
  <li>除了$0$以外每一个自然数都有一个前驱</li>
  <li>假如命题$p$满足：$p(0)$为真，且任何$p(n)$为真可以推出$p(n+1)$为真，则任何$k\in\N$都有$p(k)$为真
    <ul>
      <li>或者说，数学归纳法在$\N$上成立</li>
    </ul>
  </li>
</ol>

<p>一个可行的构造是由λ演算的提出者Alonzo Church提出的方案，我们称其为<strong>Church计数</strong>。其自然数的构造如下：</p>

<div class="kdmath">$$
\begin{align*}
0 & :=\lambda f.\ \lambda x.\ x \\
1 & :=\lambda f.\ \lambda x.\ (f\ x) \\
2 & :=\lambda f.\ \lambda x.\ (f\ (f\ x)) \\
3 & :=\lambda f.\ \lambda x.\ (f\ (f\ (f\ x)))) \\
\vdots \\
n & :=\lambda f.\ \lambda x.\ (f^{\circ n}\ x) \\
\vdots
\end{align*}
$$</div>

<p>也就是说，第$n$个自然数，就是将一个函数重复$n$遍。</p>

<p>那么自然数的后继就可以这样定义：</p>

<div class="kdmath">$$
\text{succ}:=\lambda n.\ \lambda f.\ \lambda x.\ (f\ (n\ f\ x))
$$</div>

<p>注意：你可能会以为$\text{succ}$接受三个参数，但使用它时，只用一个参数$n$，返回一个带有两个参数$f,x$的λ表达式。</p>

<p>举个例子，我们想要计算$1$的后继：</p>

<div class="kdmath">$$
\begin{align*}
(\text{succ}\ 1) &= ((\lambda n.\ \lambda f.\ \lambda x.\ (f\ (n\ f\ x)))\ 1) \\
&= \lambda f.\ \lambda x.\ (f\ (1\ f\ x)) \\
&= \lambda f.\ \lambda x.\ (f\ (f\ x))
\end{align*}
$$</div>

<p>查一下表，不难发现这个λ表达式就是自然数$2$。</p>

<p class="lambda-r">[ "SUCC", "1" ]</p>

<h3 id="加法">加法</h3>

<p>将上面后继的定义稍稍更改一下，即可得到加法的定义：</p>

<div class="kdmath">$$
(+):=\lambda m.\ \lambda n.\ \lambda f.\ \lambda x.\ (m\ f\ (n\ f\ x))
$$</div>

<p>根据定义，$(n\ f\ x)$是函数$f$在$x$上重复数字$n$遍，而$(m\ f)$又是函数$f$重复数字$m$遍。两者复合之后就是函数$f$重复了$m+n$遍。</p>

<p>这里就不手打示例公式了，大家可以在下面操作一下。</p>

<p class="lambda-r">[ "+", "1", "2" ]</p>

<p>一个等价的表达式是这样的：</p>

<div class="kdmath">$$
(+):=\lambda m.\ \lambda n.\ (m\ \text{succ}\ n)
$$</div>

<p>相当于在数$n$上使用$m$次$\text{succ}$函数。</p>

<h3 id="乘法">乘法</h3>

<p>不难想到乘法可以这样定义：</p>

<div class="kdmath">$$
(\times):=\lambda m.\ \lambda n.\ (m\ (+\ n)\ 0)
$$</div>

<p>不要忘了，$(+\ n)$是一个λ表达式，输入一个数，输出它加上$n$的结果。这个表达式的含义就是：从$0$开始，重复$m$次操作，每次给数加上$n$。那么最后得到的就是数$m\times n$。</p>

<p>但是，它还有一个更简洁的形式：</p>

<div class="kdmath">$$
(\times):=\lambda m.\ \lambda n.\ \lambda f.\ (m\ (n\ f))
$$</div>

<p>其中$(n\ f)$返回一个λ表达式，表示将函数$f$重复$n$遍，而$(m\ (n\ f))$则是进一步把$(n\ f)$重复了$m$遍。那么$f$总共就被重复了$m\times n$遍。</p>

<p>可以看一下这个演示：</p>

<p class="lambda-r">[ "*", "2", "3" ]</p>

<p class="lambda-r">[ "*", "3", "2" ]</p>

<h3 id="前驱">前驱</h3>

<p>相对于前面的运算，“求前驱”是一个相对更难的操作，因为它需要从一个表达式上面“剥掉”一层函数调用。比如：</p>

<div class="kdmath">$$
3=\lambda f.\ \lambda x.\ (f\ (f\ (f\ x)))\xrightarrow{\text{pred}} 2=\lambda f.\ \lambda x.\ (f\ (f\ x))
$$</div>

<p>我们想到，假如能够构造出一个函数$R$，使得它第一次作用在某个值$x$上得到的是它本身，而第二、三、四、…次之后，每次往$x$上面套一层$f$。那么只需要：</p>

<div class="kdmath">$$
(n\ R\ x)
$$</div>

<p>就可以得到$(f^{\circ(n-1)}\ x)$了。</p>

<p>可惜，你想得美。这种函数不可能存在，因为$R$这个函数不是一个纯函数。</p>

<p>如果我们已知：</p>

<div class="kdmath">$$
(R\ x) = x
$$</div>

<p>那么将$R$在$x$上作用两遍的结果一定也是：</p>

<div class="kdmath">$$
\begin{align*}
(R\ (R\ x)) &= (R\ x) \\
&= x
\end{align*}
$$</div>

<p>但是，你也不要小瞧了λ演算的威力。我们虽然没法构造一个这样的函数，但可以构造一个功能类似的函数：</p>

<div class="kdmath">$$
T=\lambda g.\ \lambda h.\ (h\ (g\ f))
$$</div>

<p>使用这个函数时，需要向里面传入一个常值λ表达式：$(\lambda u.\ x)$</p>

<div class="kdmath">$$
\begin{align*}
(T\ (\lambda u.\ x)) &= \lambda h.\ (h\ ((\lambda u.\ x)\ f)) \\
&= \lambda h.\ (h\ x) \\
&= \lambda u.\ (u\ x)
\end{align*}
$$</div>

<p class="lambda-r" data-repl-table="{&quot;T&quot;:[&quot;λg&quot;,&quot;λh&quot;,[&quot;h&quot;,[&quot;g&quot;,&quot;f&quot;]]]}">["T", ["λu", "x"]]</p>

<p>如果再把$T$作用到刚刚算得的结果上，就是：</p>

<div class="kdmath">$$
\begin{align*}
(T\ (T\ (\lambda u.\ x))) &= (T\ (\lambda u.\ (u\ x))) \\
&= \lambda h.\ (h\ ((\lambda u.\ (u\ x))\ f)) \\
&= \lambda h.\ (h\ (f\ x)) \\
&= \lambda u.\ (u\ (f\ x))
\end{align*}
$$</div>

<p class="lambda-r" data-repl-table="{&quot;T&quot;:[&quot;λg&quot;,&quot;λh&quot;,[&quot;h&quot;,[&quot;g&quot;,&quot;f&quot;]]]}">["T", ["λu", ["u", "x"]]]</p>

<p>进一步的，如果作用三次$T$，就会得到：</p>

<div class="kdmath">$$
\lambda u.\ (u\ (f\ (f\ x)))
$$</div>

<p class="lambda-r" data-repl-table="{&quot;T&quot;:[&quot;λg&quot;,&quot;λh&quot;,[&quot;h&quot;,[&quot;g&quot;,&quot;f&quot;]]]}">["T", ["λu", ["u", ["f", "x"]]]]</p>

<p>通过归纳法不难得到，在$(\lambda u.\ x)$上作用$n$次$T$，得到的结果就是：</p>

<div class="kdmath">$$
\lambda u.\ (u\ (f^{\circ(n-1)}\ x))
$$</div>

<p>注意到我们在这个表达式里发现了一个$(f^{\circ(n-1)}\ x)$，这就是要求的值！最后一步就是消去函数$u$，一个简单的方法就是将$u$代入单位函数$\text{id}=\lambda v.\ v$即可。</p>

<div class="kdmath">$$
\begin{align*}
&(\lambda u.\ (u\ (f^{\circ(n-1)}\ x))\ (\lambda v.\ v)) \\
=& ((\lambda v.\ v)\ (f^{\circ(n-1)}\ x)) \\
=& (f^{\circ(n-1)}\ x)
\end{align*}
$$</div>

<p>综合上述结果，我们得到了前驱$\text{pred}$的λ表达式，若传入的$n\gt 0$，那么它返回$n-1$，否则返回$0$：</p>

<div class="kdmath">$$
\text{pred}:=\lambda n.\ \lambda f.\ \lambda x.\ ((n\ T\ (\lambda u.\ x))\ \text{id})
$$</div>

<p class="lambda-r">[ "PRED", "0" ]</p>

<p class="lambda-r">[ "PRED", "1" ]</p>

<p class="lambda-r">[ "PRED", "2" ]</p>

<h3 id="减法">减法</h3>

<p>有了前驱运算，减法就不难定义了：</p>

<div class="kdmath">$$
(-):=\lambda m.\ \lambda n.\ (n\ \text{pred}\ m)
$$</div>

<p>当然，由于自然数没有负数，假如被减数$m$小于$n$，减法运算的结果就是$0$。</p>

<h3 id="判断">判断</h3>

<p>我们可以定义一个函数来判断某个数是不是$0$：</p>

<div class="kdmath">$$
\text{iszero}:=\lambda n.\ (n\ (\lambda u.\ F)\ T)
$$</div>

<p>函数$(\lambda u.\ F)$是一个永远返回$F$的常值函数。所以，只要$n\gt0$，$(\text{iszero}\ n)$就会返回$F$。</p>

<p>再加上之前定义的减法，我们就可以定义“大于等于”函数：</p>

<div class="kdmath">$$
(\ge):=\lambda m.\ \lambda n.\ (\text{iszero}\ (-\ n\ m))
$$</div>

<p>再根据大于等于来定义自然数的相等：</p>

<div class="kdmath">$$
(=):=\lambda m.\ \lambda n.\ (\land\ (\ge\ m\ n)\ (\ge\ n\ m))
$$</div>

<h2 id="思考题">思考题</h2>

<p>你能使用λ演算来定义一个类似C++中<code>std::pair</code>的数据结构吗？</p>

<blockquote>
  <p>要求：使用函数</p>

  <div class="kdmath">$$
(\text{pair}\ a\ b)
$$</div>

  <p>来构造一个对象，并使用$(\text{first}\ p)$和$(\text{second}\ p)$来获取一个pair的第一和第二个值。</p>
</blockquote>

<p>你能在这个结构的基础上，用λ演算来定义所有的<strong>整数</strong>及其相应的数值和逻辑运算吗？</p>

<h2 id="参考资料">参考资料</h2>

<p>[1] “Lambda Calculus.” <em>Wikipedia</em>, <a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>. Accessed 26 Aug. 2022.</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="lambda-calculus" /><category term="computation" /><summary type="html"><![CDATA[在古早之前（大约我初一的时候），我写过一篇博客遗憾的是现在它已经找不到了，讲述了如何用纯集合论的方法构建自然数。学过数学分析的小朋友们相信对这个知识点已经不陌生了。 不过，集合论并不是唯一一种可以用来构建自然数的方法。今天，我就要介绍另一个可行的方法：λ演算。 当然在这之前，我先简单介绍一下λ演算： 什么是λ演算？ 相信大家对函数已经不陌生了。比如下面这个函数： $$ f(x)=2x $$ 它输入一个变量$x$，输出一个数，并且满足输出的数一定是输入的两倍。 接下来我们介绍一种新的记号，用来表示同一个函数： $$ f=\lambda x.\ 2x $$ 这个表达式分为两段，第一段以λ开头，表示一个参数，第二段则是函数体。我们称这样的表达式为：λ表达式。 同时，我们也简单修改一下调用函数的记号：把括号写在函数前面，而不是后面 $$ \begin{align*} (f\ 2) &= ((\lambda x.\ 2x)\ 2) \\ &= 2\cdot 2 \\ &= 4 \end{align*} $$ 我知道这对初学者来说看起来很别扭，但只要熟悉就好了。 λ表达式的求值很简单。只需要找到和传入的参数相对应的λ项，然后将函数体的所有对应项全都替换成传入的参数即可。 多元函数 你可能会问，如果函数接受多个参数，该怎么办？比如下面这个函数： $$ f(x, y)=x+2y $$ 答案很简单，只需要这样写： $$ f=\lambda x.\ \lambda y.\ x+2y $$ 表达式前面有两个$\lambda$，就表示函数接受两个参数。比如： $$ \begin{align*} (f\ 2\ 3) &= ((\lambda x.\ \lambda y.\ x+2y)\ 2\ 3) \\ &= 2+2\cdot 3 \\ &= 8 \end{align*} $$ 同时，这个表达式还有一种解读方法。我们将$f$看作一个关于$x$的单值函数，但函数返回了另一个λ表达式： $$ f=\lambda x.\ (\lambda y.\ x+2y) $$ $$ \begin{align*} (f\ 2) &= ((\lambda x.\ (\lambda y.\ x+2y))\ 2) \\ &= \lambda y.\ 2+2y \end{align*} $$ 此时它的返回值还需要再接受一个参数，才能得到一个确定的值。 换句话说，我们把一个二元函数，变成了一个“返回一个一元函数”的一元函数。我们称这个步骤为函数的柯里化（Currying）。它同样适用于更多元的函数。 $$ f:U\times V\to W\quad\simeq\quad g:U\to(V\to W) $$ 柯里化是λ演算和函数式编程的一大难点，同时也是一大精妙之处 进一步推广，我们还可以把常数看作是一个接受0个参数的函数，只不过没什么必要去这样做罢了。 当然了，常见的加减乘除之类的运算都是二元函数，因此其实在标准的λ语法中，四则运算应该这样写： $$ a+b \Rightarrow (+\ a\ b) $$ $$ a-b \Rightarrow (-\ a\ b) $$ $$ a\cdot b \Rightarrow (*\ a\ b) $$ $$ a/b \Rightarrow (/\ a\ b) $$ 如果你学过波兰表达式(Polish Notation)，你应该对这样的写法不陌生：这其实就是加上括号的波兰表达式！ 当然，除了四则运算，其他的二元运算都有类似的规则，例如判断运算（$\gt, \lt, =, \ne, \ge, \le$），逻辑运算（AND, OR, NOT）等。 思考题：结合上述知识，你能说说这些表达式是什么含义吗？ $$ (*\ 3) $$ $$ (=\ 2) $$ “函数”的函数 我们发现，λ表达式并没有对参数的类型做限定。也就是说，向λ表达式里传入一个函数也是完全合法的！ 我们看一个例子： $$ R=\lambda f.\ \lambda x.\ (f\ (f\ x)) $$ 这个表达式$R$的意义就是：传入一个函数和一个值，把这个函数在值上做两遍。 举个例子： $$ \begin{align*} (R\ (\lambda x.\ x^2)\ 2) &= ((\lambda f.\ \lambda x.\ (f\ (f\ x)))\ (\lambda x.\ x^2))\ 2) \\ &= ((\lambda x.\ x^2)\ ((\lambda x.\ x^2)\ 2)) \\ &= ((\lambda x.\ x^2)\ 4) \\ &= 16 \end{align*} $$ 下面是一个简单的演示。点击图中的$R$将其展开，拖动函数参数到对应的λ位置来进行参数替换。 [ "R", [ "λx", [ "^", "x", "2" ] ], "2" ] 当然，使用前面柯里化的思想，我们也可以这样看：$R$输入一个λ表达式，输出一个λ表达式，其中输出的表达式是输入的表达式重复两遍的结果。 $$ (R\ f)=\lambda x.\ (f\ (f\ x)) $$ 同时这也告诉我们一个道理：在λ语言中，很多情况下括号是不能省略的。比如 $$ (f\ (g\ x)) $$ 就是变量$x$先被$g$作用再被$f$作用，而 $$ (f\ g\ x) $$ 则是函数$g$和变量$x$同时传入$f$中。 逻辑运算 相信从上面的介绍中，你已经初步掌握了λ演算。接下来我们将要玩一个小游戏：只用λ演算，不用任何额外的工具（包括逻辑运算，数值运算等一切你熟悉到不能再熟悉的东西），看看你能搭建出什么东西。 没有逻辑运算，就意味着我们没有定义“真”、“假”等概念。那么，我们能不能从λ演算中把这些东西定义出来呢？ 首先我们想到，“真”和“假”是一组对立的概念，就像是硬币的两面。从这里出发，我们先写出这样的定义： $$ T:=\lambda x.\ \lambda y.\ x $$ $$ F:=\lambda x.\ \lambda y.\ y $$ 在这样的定义下，“真”就是给定两个东西取出第一个，而“假”则是给定两个东西取出第二个。注意到这两个定义中我们没有用到任何运算。 逻辑非 有了这两个定义，那么逻辑非（Not）就很好定义了。它的定义如下： $$ (\lnot) := \lambda a.\ (a\ F\ T) $$ 不要忘记了$T$和$F$的含义：$T$表示选择第一个东西，而$F$表示选择第二个东西。也就是说，如果$a=T$，它就会选择第一个参数，也就是$F$；反之，如果$a=F$，它就会选第二个参数，就是$T$。 如果你没有理解这个定义，不妨看下面的演示。请你按照以下顺序操作： 点击NOT将其展开 将后面的T或F拖动到对应位置 将首位的T或F展开 将后面的两个参数拖动到对应位置 [ "NOT", "T" ] [ "NOT", "F" ] 逻辑与和逻辑或 逻辑与的定义则相对复杂，因为它需要接受两个参数。 不难发现，计算$a\land b$时，假如$a$为真，则运算结果就等于$b$，反之如果$a$为假，则运算结果一定是假。 因此我们给出了逻辑与的λ定义： $$ (\land):=\lambda a.\ \lambda b.\ (a\ b\ F) $$ 类似地，如果$a=T$，那么就会选择第一个参数$b$，它的返回值就取决于$b$的值；而如果$a=F$，它就一定会返回$F$。 同样你也可以看这里的演示： [ "AND", "T", "T" ] [ "AND", "T", "F" ] [ "AND", "F", "T" ] [ "AND", "F", "F" ] 类比逻辑与的定义，我们也可以写出逻辑或的定义： $$ (\lor):=\lambda a.\ \lambda b.\ (a\ T\ b) $$ 以及演示： [ "OR", "T", "T" ] [ "OR", "T", "F" ] [ "OR", "F", "T" ] [ "OR", "F", "F" ] 组合逻辑 有了逻辑运算的三兄弟：与、或、非，其余的一切逻辑运算都可以被表示出来了。比如： $$ \text{xor}:=\lambda a.\ \lambda b.\ (\lor\ (\land\ a\ (\lnot\ b))\ (\land\ b\ (\lnot\ a))) $$ 当然也可利用λ的性质，写出一个更简洁的异或运算： $$ \text{xor}:=\lambda a.\ \lambda b.\ (a\ (\lnot\ b)\ b) $$ 谓词和逻辑运算 我们定义，如果有一个λ表达式$p$的返回值要么是$T$，要么是$F$，则$p$称为一个谓词。 比如，判断两个自然数相等的运算： $$ (=\ a\ b) $$ 就是一个谓词。 自然数 回想一下自然数的五条公理： $0$是自然数 每一个自然数$n$都有一个后继，记为$n^+$ 任何两个不同的元素，它们的后继也不同 或者说，$(n^+)$这个函数是$\N\to \N$的单射 除了$0$以外每一个自然数都有一个前驱 假如命题$p$满足：$p(0)$为真，且任何$p(n)$为真可以推出$p(n+1)$为真，则任何$k\in\N$都有$p(k)$为真 或者说，数学归纳法在$\N$上成立 一个可行的构造是由λ演算的提出者Alonzo Church提出的方案，我们称其为Church计数。其自然数的构造如下： $$ \begin{align*} 0 & :=\lambda f.\ \lambda x.\ x \\ 1 & :=\lambda f.\ \lambda x.\ (f\ x) \\ 2 & :=\lambda f.\ \lambda x.\ (f\ (f\ x)) \\ 3 & :=\lambda f.\ \lambda x.\ (f\ (f\ (f\ x)))) \\ \vdots \\ n & :=\lambda f.\ \lambda x.\ (f^{\circ n}\ x) \\ \vdots \end{align*} $$ 也就是说，第$n$个自然数，就是将一个函数重复$n$遍。 那么自然数的后继就可以这样定义： $$ \text{succ}:=\lambda n.\ \lambda f.\ \lambda x.\ (f\ (n\ f\ x)) $$ 注意：你可能会以为$\text{succ}$接受三个参数，但使用它时，只用一个参数$n$，返回一个带有两个参数$f,x$的λ表达式。 举个例子，我们想要计算$1$的后继： $$ \begin{align*} (\text{succ}\ 1) &= ((\lambda n.\ \lambda f.\ \lambda x.\ (f\ (n\ f\ x)))\ 1) \\ &= \lambda f.\ \lambda x.\ (f\ (1\ f\ x)) \\ &= \lambda f.\ \lambda x.\ (f\ (f\ x)) \end{align*} $$ 查一下表，不难发现这个λ表达式就是自然数$2$。 [ "SUCC", "1" ] 加法 将上面后继的定义稍稍更改一下，即可得到加法的定义： $$ (+):=\lambda m.\ \lambda n.\ \lambda f.\ \lambda x.\ (m\ f\ (n\ f\ x)) $$ 根据定义，$(n\ f\ x)$是函数$f$在$x$上重复数字$n$遍，而$(m\ f)$又是函数$f$重复数字$m$遍。两者复合之后就是函数$f$重复了$m+n$遍。 这里就不手打示例公式了，大家可以在下面操作一下。 [ "+", "1", "2" ] 一个等价的表达式是这样的： $$ (+):=\lambda m.\ \lambda n.\ (m\ \text{succ}\ n) $$ 相当于在数$n$上使用$m$次$\text{succ}$函数。 乘法 不难想到乘法可以这样定义： $$ (\times):=\lambda m.\ \lambda n.\ (m\ (+\ n)\ 0) $$ 不要忘了，$(+\ n)$是一个λ表达式，输入一个数，输出它加上$n$的结果。这个表达式的含义就是：从$0$开始，重复$m$次操作，每次给数加上$n$。那么最后得到的就是数$m\times n$。 但是，它还有一个更简洁的形式： $$ (\times):=\lambda m.\ \lambda n.\ \lambda f.\ (m\ (n\ f)) $$ 其中$(n\ f)$返回一个λ表达式，表示将函数$f$重复$n$遍，而$(m\ (n\ f))$则是进一步把$(n\ f)$重复了$m$遍。那么$f$总共就被重复了$m\times n$遍。 可以看一下这个演示： [ "*", "2", "3" ] [ "*", "3", "2" ] 前驱 相对于前面的运算，“求前驱”是一个相对更难的操作，因为它需要从一个表达式上面“剥掉”一层函数调用。比如： $$ 3=\lambda f.\ \lambda x.\ (f\ (f\ (f\ x)))\xrightarrow{\text{pred}} 2=\lambda f.\ \lambda x.\ (f\ (f\ x)) $$ 我们想到，假如能够构造出一个函数$R$，使得它第一次作用在某个值$x$上得到的是它本身，而第二、三、四、…次之后，每次往$x$上面套一层$f$。那么只需要： $$ (n\ R\ x) $$ 就可以得到$(f^{\circ(n-1)}\ x)$了。 可惜，你想得美。这种函数不可能存在，因为$R$这个函数不是一个纯函数。 如果我们已知： $$ (R\ x) = x $$ 那么将$R$在$x$上作用两遍的结果一定也是： $$ \begin{align*} (R\ (R\ x)) &= (R\ x) \\ &= x \end{align*} $$ 但是，你也不要小瞧了λ演算的威力。我们虽然没法构造一个这样的函数，但可以构造一个功能类似的函数： $$ T=\lambda g.\ \lambda h.\ (h\ (g\ f)) $$ 使用这个函数时，需要向里面传入一个常值λ表达式：$(\lambda u.\ x)$ $$ \begin{align*} (T\ (\lambda u.\ x)) &= \lambda h.\ (h\ ((\lambda u.\ x)\ f)) \\ &= \lambda h.\ (h\ x) \\ &= \lambda u.\ (u\ x) \end{align*} $$ ["T", ["λu", "x"]] 如果再把$T$作用到刚刚算得的结果上，就是： $$ \begin{align*} (T\ (T\ (\lambda u.\ x))) &= (T\ (\lambda u.\ (u\ x))) \\ &= \lambda h.\ (h\ ((\lambda u.\ (u\ x))\ f)) \\ &= \lambda h.\ (h\ (f\ x)) \\ &= \lambda u.\ (u\ (f\ x)) \end{align*} $$ ["T", ["λu", ["u", "x"]]] 进一步的，如果作用三次$T$，就会得到： $$ \lambda u.\ (u\ (f\ (f\ x))) $$ ["T", ["λu", ["u", ["f", "x"]]]] 通过归纳法不难得到，在$(\lambda u.\ x)$上作用$n$次$T$，得到的结果就是： $$ \lambda u.\ (u\ (f^{\circ(n-1)}\ x)) $$ 注意到我们在这个表达式里发现了一个$(f^{\circ(n-1)}\ x)$，这就是要求的值！最后一步就是消去函数$u$，一个简单的方法就是将$u$代入单位函数$\text{id}=\lambda v.\ v$即可。 $$ \begin{align*} &(\lambda u.\ (u\ (f^{\circ(n-1)}\ x))\ (\lambda v.\ v)) \\ =& ((\lambda v.\ v)\ (f^{\circ(n-1)}\ x)) \\ =& (f^{\circ(n-1)}\ x) \end{align*} $$ 综合上述结果，我们得到了前驱$\text{pred}$的λ表达式，若传入的$n\gt 0$，那么它返回$n-1$，否则返回$0$： $$ \text{pred}:=\lambda n.\ \lambda f.\ \lambda x.\ ((n\ T\ (\lambda u.\ x))\ \text{id}) $$ [ "PRED", "0" ] [ "PRED", "1" ] [ "PRED", "2" ] 减法 有了前驱运算，减法就不难定义了： $$ (-):=\lambda m.\ \lambda n.\ (n\ \text{pred}\ m) $$ 当然，由于自然数没有负数，假如被减数$m$小于$n$，减法运算的结果就是$0$。 判断 我们可以定义一个函数来判断某个数是不是$0$： $$ \text{iszero}:=\lambda n.\ (n\ (\lambda u.\ F)\ T) $$ 函数$(\lambda u.\ F)$是一个永远返回$F$的常值函数。所以，只要$n\gt0$，$(\text{iszero}\ n)$就会返回$F$。 再加上之前定义的减法，我们就可以定义“大于等于”函数： $$ (\ge):=\lambda m.\ \lambda n.\ (\text{iszero}\ (-\ n\ m)) $$ 再根据大于等于来定义自然数的相等： $$ (=):=\lambda m.\ \lambda n.\ (\land\ (\ge\ m\ n)\ (\ge\ n\ m)) $$ 思考题 你能使用λ演算来定义一个类似C++中std::pair的数据结构吗？ 要求：使用函数 $$ (\text{pair}\ a\ b) $$ 来构造一个对象，并使用$(\text{first}\ p)$和$(\text{second}\ p)$来获取一个pair的第一和第二个值。 你能在这个结构的基础上，用λ演算来定义所有的整数及其相应的数值和逻辑运算吗？ 参考资料 [1] “Lambda Calculus.” Wikipedia, https://en.wikipedia.org/wiki/Lambda_calculus. Accessed 26 Aug. 2022.]]></summary></entry><entry><title type="html">埃氏筛的复杂度计算</title><link href="mqcreaple.github.io/blog/2022/08/18/eto.html" rel="alternate" type="text/html" title="埃氏筛的复杂度计算" /><published>2022-08-18T00:00:00-04:00</published><updated>2022-08-18T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/08/18/eto</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/08/18/eto.html"><![CDATA[<p><strong>埃拉托斯特尼筛法（Sieve of Erastosthenis）</strong>，简称<strong>埃氏筛</strong>，是一种可以在极少时间复杂度内算出$n$以内的所有质数的算法。</p>

<h2 id="0-算法流程">#0 算法流程</h2>

<p>对于一个给定的整数$n$，从2开始执行以下操作：</p>

<ol>
  <li>将该数标记为质数</li>
  <li>将所有该数的倍数标记为“非质数”</li>
  <li>找到下一个不被标记为“非质数”的数，重复步骤1</li>
</ol>

<p>算法的逻辑很简单，代码也极其简短。以C语言为例：</p>

<pre><code class="language-c">int sieve(int n, int *ans) {
    int found = 0;         // 已经找到多少个质数
    bool p[n];             // 标记。0为质数，1为非质数
    
    memset(p, 0, n);       // 清空标记数组
    for(int i = 2; i &lt; n; i++) {
        if(p[i]) {
            // i已经被标记为非质数，跳过
            continue;
        }
        ans[found++] = i;  // i为质数，添加至答案数组中
        for(int j = 2; i * j &lt; n; j++) {
            p[i * j] = 1;      // 将所有i的倍数标记为“非质数”
        }
    }
    
    return found;
}
</code></pre>

<h2 id="1-初步分析">#1 初步分析</h2>

<p>那么这个算法的时间复杂度如何计算呢？</p>

<p>我们不妨追踪一下算法的执行过程：</p>

<ul>
  <li>首先从$2$开始，算法遍历了所有$1$到$n$中$2$的倍数，也就是进行了$\frac{n}{2}$步操作</li>
  <li>接下来找到下一个质数：$3$。算法又遍历了$1$到$n$中$3$的倍数，进行了$\frac{n}{3}$步操作</li>
  <li>再然后，跳过$4$找到下一个质数$5$，遍历了$1$到$n$中$5$的倍数，进行了$\frac{n}{5}$步操作</li>
  <li>……</li>
</ul>

<p>那么最后一共执行了多少步操作？答案是一个无穷级数之和：</p>

<div class="kdmath">$$
\frac{n}{2}+\frac{n}{3}+\frac{n}{5}+\frac{n}{7}+\frac{n}{11}+\cdots
$$</div>

<p>将$n$提出来，并将剩余项写成求和符号，就是：</p>

<div class="kdmath">$$
n\cdot\sum_{p\text{ is prime}}\frac 1{p}
$$</div>

<p>问题来了，后面这个无穷级数怎么求？</p>

<h2 id="2-何为时间复杂度">#2 何为时间复杂度？</h2>

<p>可能大部分人会以为这是一个困难的数论问题，但是不要忘了，计算时间复杂度的时候，只需要考虑<strong>数据趋近无穷的趋势</strong>，而<strong>不用考虑具体数值</strong>。</p>

<p>那么如何定义“趋势”？我们不妨借鉴一下小学二年级的高数知识：</p>

<blockquote>
  <p>如果两个趋近无穷的数列$a_n$和$b_n$满足</p>

  <div class="kdmath">$$
\lim_{n\to\infty}\frac{a_n}{b_n}=c
$$</div>

  <p>其中$c$为一个常数且不为$0$，那么这两个数列称为<strong>同阶无穷大</strong>，记作$a_n \sim b_n$。</p>
</blockquote>

<p>根据同阶无穷大定义时间复杂度的大$O$记号了：</p>

<blockquote>
  <p>对于某个算法，如果它只有一个输入$N$，那么将$N$依次代入从$1$开始的所有自然数，记$t_i$为输入数字$i$时算法的运行时间（或者说“执行的操作数”），那么可以得到一个数列$\{t_N\}$。</p>

  <p>假如存在一个<em>简单表达式</em>$q_N$，使得</p>

  <div class="kdmath">$$
t_N\sim q_N
$$</div>

  <p>那么记这个算法的时间复杂度为$O(q_N)$。</p>
</blockquote>

<p>思考题：根据同阶无穷大的定义，证明：</p>
<ul>
  <li>$O(N^2+2N)\sim O(N^2)$</li>
</ul>

<h2 id="3-无穷级数">#3 无穷级数</h2>

<p>即便有了这样的定义，我们就将问题化解为了：<em>寻找一个简单表达式，使得它和“<strong>所有质数的倒数和</strong>”是同阶无穷大</em>。</p>

<p>在这之前，我们可以使用一个已经被证明过的结论：质数分布是$O(N\log N)$的。记第$n$个质数为$p_n$，则：</p>

<div class="kdmath">$$
p_n\sim n\ln n
$$</div>

<p>从这里还不能完全得出我们想要的结论，但我们已经可以对开头提到的无穷级数进行化简了：</p>

<div class="kdmath">$$
\sum_{n=1}^\infty \frac 1{p_n}\sim \sum_{n=1}^\infty \frac 1{n\ln n}
$$</div>

<blockquote>
  <p>引理1：若$a_n, b_n$均<strong>非负</strong>且为同阶无穷小，即$a_n\sim b_n$，则</p>

  <div class="kdmath">$$
\sum_{n=1}^\infty a_n\sim \sum_{n=1}^\infty b_n
$$</div>

  <p>证明：根据同阶无穷小的定义，可得：</p>

  <div class="kdmath">$$
\lim_{n\to\infty}\frac{a_n}{b_n}=c
$$</div>

  <p>根据极限的$\epsilon-N$定义，对于任给的$\epsilon\gt0$，总存在$N\gt0$，使得所有$n\gt N$都有：</p>

  <div class="kdmath">$$
c-\epsilon \lt \frac{a_n}{b_n}\lt c+\epsilon
$$</div>

  <p>因为$n$可以取任何大于$N$的值，再根据恒等式$\frac{a}{b}\lt\frac{a+c}{b+d}\lt\frac{c}{d}$，可以将所有形如$\frac{a_n}{b_n}$的分式合并而不影响其性质：</p>

  <div class="kdmath">$$
c-\epsilon \lt \frac{\sum_{n=N}^\infty a_n}{\sum_{n=N}^\infty b_n} \lt c+\epsilon
$$</div>

  <p>换句话说，存在$N\gt0$使得</p>

  <div class="kdmath">$$
\frac{\sum_{n=N}^\infty a_n}{\sum_{n=N}^\infty b_n}
$$</div>

  <p>是有限且非0的。</p>

  <p>又因为$\sum_{n=1}^{N-1}a_n$和$\sum_{n=1}^{N-1}b_n$是有限的，所以</p>

  <div class="kdmath">$$
\frac{\sum_{n=1}^{N-1}a_n}{\sum_{n=1}^{N-1}b_n}
$$</div>

  <p>是有限的。</p>

  <p>根据恒等式$\frac{a}{b}\lt\frac{a+c}{b+d}\lt\frac{c}{d}$，可以得到：</p>

  <div class="kdmath">$$
\frac{\sum_{n=1}^{N-1}a_n + \sum_{n=N}^\infty a_n}{\sum_{n=1}^{N-1}b_n + \sum_{n=N}^\infty b_n}=\frac{\sum_{n=1}^\infty a_n}{\sum_{n=1}^\infty b_n}
$$</div>

  <p>一定也是有限且非0的。证毕。</p>
</blockquote>

<p>经过此次化简，至少题目看起来像道代数题而不是数论题了，但无穷级数$\sum_{n=1}^\infty \frac 1{n\ln n}$仍然让人没有头绪。</p>

<blockquote>
  <p>引理2：对于一个<strong>单调函数</strong>$f(n)$</p>

  <div class="kdmath">$$
\sum_{n=1}^\infty f(n) \sim \int_1^\infty f(n)\mathrm dn
$$</div>

  <p>证明：</p>

  <p><img src="/img/eto-0.png" alt="eto-0" /></p>

  <div class="kdmath">$$
\int_1^\infty f(n)\mathrm dn=\sum_{k=1}^\infty \int_k^{k+1}f(n)\mathrm dn
$$</div>

  <p>不妨假设函数$f(n)\gt0$，则$f(n)$单调减。又因为$\lim_{n\to\infty}f(n)=0$，因此：</p>

  <div class="kdmath">$$
\begin{align*}
& \sum_{k=1}^\infty f(k)-\sum_{k=1}^\infty \int_k^{k+1}f(n)\mathrm dn \\
= & \sum_{k=1}^\infty\left[ f(k)-\int_k^{k+1}f(n)\mathrm dn \right] \\
\le & \sum_{k=1}^\infty[ f(k)-f(k+1) ] \\
= & f(1) - 0 \\
= & f(1)
\end{align*}
$$</div>

  <p>也就是说$\sum_{n=1}^\infty f(n)$和$\int_1^\infty f(x)\mathrm dx$之间至多相差常数$f(1)$，又因为两者均不为$0$，那么两者之比一定有限且非$0$。</p>

  <p>证毕</p>
</blockquote>

<p>有了这个结论，我们就能直接得到：</p>

<div class="kdmath">$$
\sum_{n=1}^\infty \frac 1{n\ln n} \sim \int_1^\infty \frac{\mathrm dn}{n\ln n}\sim \ln\ln n
$$</div>

<p>回到最初的问题：</p>

<div class="kdmath">$$
N\cdot\sum_{p\text{ is prime}}p \sim N\sum_{n=1}^\infty \frac 1{n\ln n} \sim N\ln\ln N
$$</div>

<p>也就是说，埃氏筛的时间复杂度是$O(N\log\log N)$级别的。</p>

<h2 id="思考题">思考题</h2>

<ol>
  <li>（简单）请用本文中的定理证明：
<span class="kdmath">$\sum_{n=1}^\infty\frac 1n \sim \ln n$</span></li>
  <li>（困难）请不用本文提到的方法证明题目1</li>
</ol>

<h2 id="参考资料">参考资料</h2>

<p>[1] “Sieve of Eratosthenes.” <em>Wikipedia</em>, <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</a>. Accessed 18 Aug. 2022.</p>

<p>[2] “Distribution of Primes.” <em>Brilliant</em>, <a href="https://brilliant.org/wiki/distribution-of-primes/">https://brilliant.org/wiki/distribution-of-primes/</a>. Accessed 18 Aug. 2022.</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="algorithm" /><category term="math" /><category term="time-complexity" /><summary type="html"><![CDATA[埃拉托斯特尼筛法（Sieve of Erastosthenis），简称埃氏筛，是一种可以在极少时间复杂度内算出$n$以内的所有质数的算法。]]></summary></entry><entry><title type="html">git原理简介</title><link href="mqcreaple.github.io/blog/2022/03/04/git.html" rel="alternate" type="text/html" title="git原理简介" /><published>2022-03-04T00:00:00-05:00</published><updated>2022-03-04T00:00:00-05:00</updated><id>mqcreaple.github.io/blog/2022/03/04/git</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/03/04/git.html"><![CDATA[<p>相信大家都对<a href="https://git-scm.com/">git</a>耳熟能详了。Git是一个简单易用的版本管理工具，用户可以在git中修改文件、提交commit（更新到本地仓库）、同步远程仓库等。本篇文章将主要讨论git更新文件和提交commit背后的原理。</p>

<p>前置知识：git基本操作，详见<a href="https://www.runoob.com/git/">runoob</a>和<a href="https://www.w3schools.com/git/">w3schools</a>。</p>

<h2 id="一些名词">一些名词</h2>
<ul>
  <li><strong>工作区（working tree）</strong>表示除去<code>/.git</code>以外的工作目录，即通常写代码的位置。</li>
  <li><strong>暂存区/索引（index）</strong>是执行完<code>git add</code>指令时文件被添加到的地方。如果没有执行过<code>git add</code>命令，git并不会为你自动保存。</li>
  <li><strong>版本库（repository）</strong>是所有当前暂存区和历史上commit过的文件，暂存区可以看作是版本库的一个子集。所有版本库的文件都保存在<code>/.git</code>目录下。</li>
</ul>

<p>所有的历史文件、文件目录、commmit记录等全部保存为二进制对象，统一保存在/.git/objects目录下，文件名为该文件的SHA-1哈希值且没有后缀。</p>

<ul>
  <li>blob：全称为Binary Large Object，是常规文件保存在<code>/.git/objects</code>下的形式。</li>
  <li>tree：目录文件保存在<code>/.git/objects</code>下的形式。</li>
  <li>commit：commit记录保存在<code>/.git/objects</code>下的形式。</li>
</ul>

<pre><code class="language-plaintext">└── objects
    ├── 41
    │   └── a1d4060cf09286c1cd8fe8bdab89ce26b71086
    ├── ce
    │   └── 013625030ba8dba906f756967f9e9ca394464a
    ├── dc
    │   └── a98923d43cd634f4359f8a1f897bf585100cfe
    ├── info
    └── pack
</code></pre>

<p>上图的文件目录中，三个object的SHA-1值分别为：<code>41a1d4...</code>，<code>ce0136...</code>，和<code>dca989...</code>。</p>

<p>可以使用指令：</p>

<pre><code class="language-shell">git hash-object 文件名
</code></pre>

<p>计算一个文件的SHA-1哈希值。</p>

<h2 id="head指针和commit">HEAD指针和commit</h2>

<p><code>HEAD</code>是一个指针，默认指向当前分支的最新一个commit（存储了commit文件的哈希值）。每一次提交新的commit时，<code>HEAD</code>也会相应前移。<code>HEAD</code>存储在<code>/.git/HEAD</code>文件中。</p>

<p>每一个分支也有各自的head，指向当前分支的最后一个commit，各分支的head存储在<code>/.git/refs/heads/</code>分支名文件中。每一次执行<code>git checkout</code>切换分支的时候，实际上就是让全局的<code>HEAD</code>赋值成了另一个分支的head。</p>

<p>总结一下，现在讲过的<code>/.git</code>目录结构都有：</p>

<pre><code class="language-plaintext">.git
├── HEAD          全局HEAD指针
├── objects
│   └── 二进制对象都在这里
└── refs
    └── heads
        └── 各个分支的head
</code></pre>

<p>除了第一个commit，以后的每个commit都会记录上一个commit的哈希值，这样就形成了一个树形结构。</p>

<p>当整个项目只有一个分支时，所有的commit形成一条链：</p>

<div class="mermaid">
graph RL
A[commit<br />a5e2] --&gt; B[commit<br />3d97]
B --&gt; C[commit<br />9cd6]
C --&gt; D[commit<br />729f]
D --&gt; E[commit<br />4375]
E --&gt; F[......]
subgraph master: head
A
end
</div>

<p>有多个分支时，则是这样的：</p>

<div class="mermaid">
graph RL
A[commit<br />a5e2] --&gt; B[commit<br />3d97]
B --&gt; C[commit<br />9cd6]
C --&gt; D[commit<br />729f]
D --&gt; E[commit<br />4375]
E --&gt; F[......]
subgraph master: head
A
end
G[commit<br />fc6a] --&gt; E
H[commit<br />7032] --&gt; G
subgraph branch1: head
H
end
</div>

<h2 id="文件和目录">文件和目录</h2>

<p>之前说过，blob对象和tree对象都存在<code>.git/objects/</code>目录下。Tree对象存储了其他一系列文件的哈希值，可以理解成是一个多叉树的结点，而一般文件是根节点。</p>

<div class="mermaid">
graph TD
A[[root]] --&gt; B([readme.md])
A --&gt; C([.gitignore])
A --&gt; D[[src]]
D --&gt; E([main.cpp])
D --&gt; F([main.h])
A --&gt; G[[test]]
G --&gt; H([test.cpp])
</div>

<p>暂存区/索引对应着<code>/.git/index</code>文件，它记录了当前暂存的所有文件和目录的哈希值。每一次执行<code>git add</code>指令，程序就会在<code>/.git/objects</code>目录中生成一个对应着该文件的blob对象，同时将这个对象的地址加到<code>/.git/index</code>中。</p>

<p>每一个commit结点指向了一个tree节点，表示某一次commit的根目录。两次commit中不变文件不会被创建新对象。</p>

<p><img src="/img/git-file-0.svg" alt="git-file-0" /></p>

<p>这时，如果我们添加了一个<code>.gitignore</code>文件并且执行<code>git add .gitignore</code>命令，就会创建一个新的blob对象并添加进索引。</p>

<p><img src="/img/git-file-1.svg" alt="git-file-1" /></p>

<p>再接下来提交commit，程序就会新建一个表示根目录的tree对象并且指向所有索引（index）中的文件和文件夹。最后再处理commit结点，将其指向上一次的commit，即完成了git提交，如图：</p>

<p><img src="/img/git-file-2.svg" alt="git-file-2" /></p>

<h2 id="总结">总结</h2>

<blockquote>
  <p>Git的所有对象，包括文件、目录、和commit，全部存储在<code>/.git/object/</code>文件夹下。</p>

  <p>Commit结点指向其上一次的commit，形成一个树形结构，每个叶节点对应一个分支的head。</p>

  <p>全局的<code>HEAD</code>指针指向任意一个commit结点，通常是一个特定分支的head。</p>

  <p>blob对应一般的文件，tree对应文件夹，同一个文件夹下所有文件和文件夹组成一个树形结构，但同一个文件有可能被不同版本的文件夹同时指向。</p>

  <p>每次add文件时，git会生成一个新的blob对象并添加到index中。</p>

  <p>每次进行commit时，git会生成tree对象并令其指向所有的子文件，最后让commit结点指向根目录文件夹，同时设置commit结点的上一个结点，最后完成提交。</p>
</blockquote>

<p>Git的版本管理逻辑和信息竞赛里的“可持久化算法”思想很像，都是尽量避免记录过多重复的内容从而减少空间占用。</p>

<p>Git在文件和目录这个树形结构之上，还有一个“commit”的分支结构，这意味着它可以应对更复杂的需求，但也意味着使用者需要记忆更多的命令。</p>

<p>本文仅是一个简单介绍，没有涵盖诸如分支合并和tag等更复杂的功能，如果以后有时间可以更新。</p>

<h2 id="参考资料">参考资料</h2>

<p>[1] Chacon, Scott and Straub, Ben. “Pro Git v2”. Git, <a href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a>.</p>

<p>[2] Wiegley, John. “Git from the Bottom to Up”. GitHub, <a href="https://jwiegley.github.io/git-from-the-bottom-up/">https://jwiegley.github.io/git-from-the-bottom-up/</a>.</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="git" /><category term="github" /><summary type="html"><![CDATA[相信大家都对git耳熟能详了。Git是一个简单易用的版本管理工具，用户可以在git中修改文件、提交commit（更新到本地仓库）、同步远程仓库等。本篇文章将主要讨论git更新文件和提交commit背后的原理。]]></summary></entry><entry><title type="html">2.0公告 &amp;amp; jekyll介绍</title><link href="mqcreaple.github.io/blog/2022/03/01/jekyll.html" rel="alternate" type="text/html" title="2.0公告 &amp;amp; jekyll介绍" /><published>2022-03-01T00:00:00-05:00</published><updated>2022-03-01T00:00:00-05:00</updated><id>mqcreaple.github.io/blog/2022/03/01/jekyll</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/03/01/jekyll.html"><![CDATA[<h2 id="公告">公告</h2>

<p>大约有三四个月没有发新的博客了，不知道还有没有人看。。。</p>

<p>自从这个版本之后，我将舍弃我自己做的那个博客文章发布系统，而采用一个现成的工具：jekyll。主要原因嘛，就是<del>懒得继续写代码</del>jekyll做的比我自己写的系统好用。毕竟造别人已经造过的轮子是无意义的（</p>

<p>现在旧版博客文章还没有完全迁移过来，以后也会陆陆续续全部搞完。</p>

<h2 id="jekyll介绍"><a href="https://jekyllrb.com/">Jekyll</a>介绍</h2>

<p><a href="https://jekyllrb.com/">Jekyll的官方网站</a>上也有详细的文档，第一次使用的话完全可以照着文档操作。我在这里也简单地介绍一下：</p>

<ol>
  <li>Jekyll是用Ruby写成的，安装前请先确保电脑上有ruby环境和ruby的包管理工具rubygems。</li>
  <li>使用如下指令安装Jekyll：
    <pre><code class="language-shell">gem install bundler jekyll
</code></pre>
  </li>
  <li>接下来使用如下指令创建新工程：
    <pre><code class="language-shell">jekyll new 工程名称
</code></pre>
  </li>
  <li>进入目录，你应该看到这样的目录结构
    <pre><code class="language-plaintext">.
├── 404.html
├── Gemfile
├── Gemfile.lock
├── _config.yml
├── about.markdown
├── index.markdown
└── _posts
 └── xxxx-xx-xx-welcome-to-jekyll.markdown
</code></pre>
    <p>简单解释一下：</p>
    <ul>
      <li><code>_config.yml</code>存放了这个工程的基本信息，比如博客标题、描述、作者的邮箱等，也可以在_config.yml上面继续添加新的信息。</li>
      <li><code>Gemfile</code>和<code>Gemfile.lock</code>是一些关于Gem的信息，可以暂时不用管。</li>
      <li><code>404.html</code>是404错误页面，如果用户试图访问一个你没有写过的页面，就会自动跳转到这个页面上。</li>
      <li><code>index.markdown</code>(写成<code>index.md</code>也可以被系统识别)是博客的主页，即在浏览器输入博客地址后第一个看见的页面。</li>
      <li><code>about.markdown</code>(同上，<code>about.md</code>也被允许)是个人介绍页面。</li>
      <li><code>_posts</code>文件夹下放各个博客文章，每个文章都是一个Markdown文件。文章的文件名都应该是<code>YYYY-MM-dd-TITLE.md</code>格式，即4位年份、2为月份、2位日期，后面跟着文章标题，空格用<code>-</code>代替。</li>
    </ul>
  </li>
  <li>Jekyll会将所有在根目录下和<code>_posts</code>目录下的Markdown文件全部编译成HTML，连同其他文件放在<code>_site</code>目录下。也就是说，进行编译后，<code>_site</code>文件夹下就是一个完整的网站，各个博客会被按照类别和日期整理起来。
    <pre><code class="language-shell">bundle exec jekyll serve
</code></pre>
    <p>会进行编译并且将_site目录下的网站运行在http://localhost:4000/上。当服务程序跑起来时，_posts下的Markdown文件发生改动也会实时编译并更改对应的网页内容。</p>
  </li>
  <li>Jekyll的Markdown，准确来说是“加强版Markdown”。每个Markdown文件都有一个header，像这样：
    <pre><code class="language-yaml">---
layout: post
title: XXX-XXX
permalink: /aaa/bbb/
category: blog
---
</code></pre>
    <p>其中</p>
    <ul>
      <li><code>title</code>后面的内容会被自动添加为文件的一级标题，因此并不需要在写Markdown时再写一遍标题。</li>
      <li><code>category</code>是文件的类别，比如这里是<code>blog</code>的话就会在编译为HTML时将其放在<code>_site/blog/</code>文件夹下。</li>
      <li><code>layout</code>是页面的布局方式，Jekyll有一些预定义的layout，比如<code>home</code>, <code>post</code>, <code>page</code>等，也可以自己定义布局方式，比如两列布局、三列布局，将写好的HTML文件放在<code>_layout/</code>文件夹下就可以。但这需要一定的HTML基础。</li>
      <li>默认情况下，编译后的Markdown文件会被放在<code>年/月/日/标题.html</code>目录下。如果不想放在这里，可以更改<code>permalink</code>变量。上例中文件就会被放在<code>/aaa/bbb/index.html</code>。 还有一些其他可以定义的头部参数，详见官网。</li>
    </ul>
  </li>
  <li>Markdown文件中还可以使用变量。形如<code>{{site._____}}</code>的字符串会在编译时被替换成<code>_config.yml</code>里对应的值，例如在我的定义下：
    <pre><code class="language-markdown">My email is {{site.email}}
</code></pre>
    <p>就会变成：</p>
    <pre><code class="language-plaintext">My email is gmq14159@gmail.com
</code></pre>
    <p>类似的，<code>{{page.____}}</code>可以返回Markdown Header里面的对应变量值。详细解释请看Jekyll官方文档。</p>
  </li>
</ol>

<p>关于Jekyll就先讲这么多，更多的信息也可以在网上找到。</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="bulletin" /><category term="jekyll" /><category term="writing" /><summary type="html"><![CDATA[公告]]></summary></entry><entry><title type="html">为何非弹性碰撞下动量守恒而能量不守恒？</title><link href="mqcreaple.github.io/blog/2021/12/19/simulation2.html" rel="alternate" type="text/html" title="为何非弹性碰撞下动量守恒而能量不守恒？" /><published>2021-12-19T00:00:00-05:00</published><updated>2021-12-19T00:00:00-05:00</updated><id>mqcreaple.github.io/blog/2021/12/19/simulation2</id><content type="html" xml:base="mqcreaple.github.io/blog/2021/12/19/simulation2.html"><![CDATA[<h2 id="1-模拟">1. 模拟</h2>

<p>假设现在有两种不同的分子，同种分子之间有引力，异种分子之间有斥力。</p>

<p>我们使用一个理想模型：同种分子之间的使用弹簧连接，弹簧会主动维护一个固定长度$l_0$；异种分子之间的斥力满足平方反比定律。具体公式如下：</p>

<div class="kdmath">$$
\bm F_1=k_1(\bm r_{12} - \bm l_0)
$$</div>

<div class="kdmath">$$
\bm F_2=k_2\cdot\frac{\bm r_{12}}{r_{12}^2}
$$</div>

<p>其中$F_1$为同种分子之间的引力，$F_2$为异种分子之间的斥力。</p>

<p>模拟结果如下：</p>

<ol>
  <li>$k_1:k_2=5:1$，近似为理想刚体的弹性碰撞</li>
</ol>

<p><img src="/img/sim_animation1.gif" alt="animation1" /></p>

<ol>
  <li>$k_1:k_2=1:1$</li>
</ol>

<p><img src="/img/sim_animation2.gif" alt="animation2" /></p>

<ol>
  <li>$k_1:k_2=0.75:1$，碰撞为塑性碰撞</li>
</ol>

<p><img src="/img/sim_animation3.gif" alt="animation3" /></p>

<h2 id="分析">分析</h2>

<p>从这些模拟动画中可以看出在塑性碰撞之后，固体内部的分子自身产生了微小振动，将一部分物体的平动动能转化成了分子的振动动能（即内能）。这就是我们问题的答案：塑性碰撞将宏观物体的能量转化成了微观分子的能量，因此宏观上能量减少了。</p>

<p>值得注意的是，分子的振动并不能带走宏观物体的动量，因为分子的振动是随机的，并且在各个方向上出现的概率相等，因此统计上分子的动量之和应当为0。这也是为什么不论在弹性还是在塑性碰撞中，物体的动量都是守恒的。</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="simulation" /><category term="julia" /><category term="physics" /><summary type="html"><![CDATA[1. 模拟]]></summary></entry><entry><title type="html">算法化求导</title><link href="mqcreaple.github.io/blog/2021/09/11/derivative-m.html" rel="alternate" type="text/html" title="算法化求导" /><published>2021-09-11T00:00:00-04:00</published><updated>2021-09-11T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2021/09/11/derivative-m</id><content type="html" xml:base="mqcreaple.github.io/blog/2021/09/11/derivative-m.html"><![CDATA[<p>求导是一种算符，输入一个表达式，输出另一个表达式</p>

<p>我们学过求导的运算法则，例如$(u+v)’=u’+v’$等等，将这些法则运用于某个表达式，即可实现算法化求导</p>

<p>首先，我们要从表达式树说起</p>

<h2 id="表达式树">表达式树</h2>

<p>任何一个表达式，都可以被拆解成一棵二叉树，其中叶结点为数字或字母，非叶结点则为运算符和函数</p>

<p>例如如下的表达式：</p>

<div class="kdmath">$$
f(x)=3x^2+2\sin(x)
$$</div>

<p>可以被拆解成如下的表达式树：</p>

<div class="mermaid">
graph TD
A((+)) --&gt; B((*))
A --&gt; C((*))
B --&gt; D[3]
B --&gt; E((^))
E --&gt; F[x]
E --&gt; G[2]
C --&gt; H[2]
C --&gt; I((sin))
I --&gt; J[x]
</div>

<p>计算$f(x)$的过程也很简单，只需要将所有未知数都替换成某个特定的值$x_0$，接着从下往上递归，将所有非叶结点替换为计算结果，最后根结点的数值就是答案了</p>

<p>以上面的表达式树为例，如果我们想要计算$f\left(\dfrac{\pi}{2}\right)$的数值，首先把所有$x$结点换成$\frac\pi2$</p>

<div class="mermaid">
graph TD
A((+)) --&gt; B((*))
A --&gt; C((*))
B --&gt; D[3]
B --&gt; E((^))
E --&gt; F[π/2]
E --&gt; G[2]
C --&gt; H[2]
C --&gt; I((sin))
I --&gt; J[π/2]
</div>

<p>接下来从下向上递归计算。先将$\left(\dfrac\pi2\right)^2$替换为$\dfrac{\pi^2}{4}$，将$\sin\left(\dfrac\pi2\right)$替换为$1$</p>

<div class="mermaid">
graph TD
A((+)) --&gt; B((*))
A --&gt; C((*))
B --&gt; D[3]
B --&gt; E[π^2/4]
C --&gt; H[2]
C --&gt; I[1]
</div>

<p>继续重复上述操作：</p>

<div class="mermaid">
graph TD
A((+)) --&gt; B[3π^2/4]
A --&gt; C[2]
</div>

<p>最终得到答案：$\dfrac{3\pi^2}{4}+2$</p>

<h2 id="树上操作求导">树上操作&amp;求导</h2>

<p>我们暂且使用：</p>

<pre><code class="language-java">class Node {
    private String operator;
    private Node left;
    private Node right;
    Node(char operator, Node left, Node right) {
        this.operator = operator;
        this.left = left;
        this.right = right;
    }
}
</code></pre>

<p>来表示一个表达式树的非叶结点</p>

<h3 id="加减法">加减法</h3>

<p>我们不妨从最简单的加法运算开始考虑</p>

<p>当某个结点是<code>+</code>运算时，我们不妨设左右两端的表达式分别为$f(x)$和$g(x)$，那么这个结点就表示了函数$h(x)=f(x)+g(x)$。</p>

<pre><code>    +
   / \
f(x) g(x)
</code></pre>

<p><em>（省流大师</em></p>

<p>那么，根据导数的运算律，我们可以得到：</p>

<div class="kdmath">$$
h'(x)=(f+g)'(x)=f'(x)+g'(x)
$$</div>

<p>也就是说，先分别计算这棵表达式树的左右子树的导数，接着将它们套在一个<code>+</code>结点上，就是这个表达式树的导数</p>

<pre><code>                 +               +
derivative {    / \    } =     /   \
             f(x) g(x)     f'(x)  g'(x)
</code></pre>

<p>写成代码的形式，就是：</p>

<pre><code class="language-java">if(root.operator == "+") {
    return new Node(
        "+",
        derivative(root.left),
        derivative(root.right)
    );
}
</code></pre>

<p>对于减法，也是同理：</p>

<pre><code>                 -               -
derivative {    / \    } =     /   \
             f(x) g(x)     f'(x)  g'(x)
</code></pre>

<pre><code class="language-java">if(root.operator == "-") {
    return new Node(
        "-",
        derivative(root.left),
        derivative(root.right)
    );
}
</code></pre>

<h3 id="乘法除法">乘法&amp;除法</h3>

<p>乘法运算则略微复杂一些。如果$h(x)=f(x)g(x)$，根据导数运算律。有：</p>

<div class="kdmath">$$
h'(x)=f(x)g'(x)+g(x)f'(x)
$$</div>

<p>也就是：</p>

<pre><code>                                   +
                 *              /     \
derivative {    / \    } =    *         *
             f(x) g(x)      /   \     /   \
                         f(x) g'(x) g(x) f'(x)
</code></pre>

<p>写成代码：</p>

<pre><code class="language-java">if(root.operator == "*") {
    return new Node(
        "-",
        new Node(
            "*",
            root.left,
            derivative(root.right)
        ),
        new Node(
            "*",
            root.right,
            derivative(root.left)
        )
    );
}
</code></pre>

<p>除法则更复杂一些：</p>

<div class="kdmath">$$
\left(\dfrac{f(x)}{g(x)}\right)'=\dfrac{f'(x)g(x)-f(x)g'(x)}{g(x)^2}
$$</div>

<p><del>表达式树实在懒得画了</del></p>

<p>也就是：</p>

<pre><code class="language-java">if(root.operator == "/") {
    return new Node(
        "/",
        new Node(
            "-",
            new Node(
                "*"
                root.right,
                derivative(root.left)
            ),
            new Node(
                "*",
                root.left,
                derivative(root.right)
            )
        ),
        new Node(
            "^",
            root.right,
            new NumberNode(2)
        )
    );
}
</code></pre>

<h3 id="乘方">乘方</h3>
<p>到了乘方这里，事情就有点难办了</p>

<p>我们知道指数函数的导数公式$(a^x)’=a^x\ln a$，也知道幂函数的导数公式$(x^a)’=ax^{a-1}$，但是现在问题是：未知数可能同时出现在底数和指数上</p>

<p>换句话说，我们想要求的是：</p>

<div class="kdmath">$$
\left(f(x)^{g(x)}\right)'
$$</div>

<pre><code>                 ^
derivative {    / \    } = ?
             f(x) g(x)
</code></pre>

<p>这里我们要用到一点小技巧</p>

<p>首先令</p>

<div class="kdmath">$$
y=f(x)^{g(x)}
$$</div>

<p>接着，两边同时求对数：</p>

<div class="kdmath">$$
\ln y=\ln f(x)^{g(x)}=g(x)\ln f(x)
$$</div>

<p>接下来，两边对$x$求导，得到：</p>

<div class="kdmath">$$
\frac{\mathrm d\ln y}{\mathrm dx}=\frac{\mathrm d(g(x)\ln f(x))}{\mathrm dx}
$$</div>

<p>对等式左侧使用链式求导法则：</p>

<div class="kdmath">$$
\frac{\mathrm d\ln y}{\mathrm dx}=\frac{\mathrm d\ln y}{\mathrm dy}\cdot\frac{\mathrm dy}{\mathrm dx}=\frac 1y\cdot\frac{\mathrm dy}{\mathrm dx}
$$</div>

<p>同时对等式右侧使用导数的乘法法则：</p>

<div class="kdmath">$$
\begin{align*}
\frac{\mathrm d(g(x)\ln f(x))}{\mathrm dx} &= g(x)\frac{\mathrm d\ln f(x)}{\mathrm df(x)}\frac{\mathrm df(x)}{\mathrm dx}+\ln f(x)\cdot\frac{\mathrm dg(x)}{\mathrm dx} \\
& =\frac{g(x)}{f(x)}f'(x)+g'(x)\ln f(x)
\end{align*}
$$</div>

<p>最终我们得到：</p>

<div class="kdmath">$$
\frac 1y\cdot y'=\frac{g(x)}{f(x)}f'(x)+g'(x)\ln f(x)
$$</div>

<p>$y’$即为所求，因此将等式左侧的$\frac1y$乘到右侧，并将$y$替换为$f(x)^{g(x)}$，我们得到：</p>

<div class="kdmath">$$
y'=\left(f(x)^{g(x)}\right)'=f(x)^{g(x)}\left(\frac{g(x)}{f(x)}f'(x)+g'(x)\ln f(x)\right)
$$</div>

<p>这就是两个表达式乘方的导数</p>

<p>由于这玩意实在太长，它的代码形式和表达式树形式我就不列出来了。大家只需要知道这玩意能算出来就行了</p>

<h3 id="叶结点的处理">叶结点的处理</h3>

<p>当我们运算到叶结点（即常数和变量）时，就可以直接按照如下方法处理：</p>

<p><span class="kdmath">$text{返回值}=\begin{cases}1, \text{结点值}=\text{求导变量}\\0, \text{结点值}\neq\text{求导变量}\end{cases}$</span></p>

<p>对$x$求导时，只有$x’$会返回$1$。其余情况，包括常数的导数，和多元函数中其他变量（比如$y, z$）对$x$的导数，都会返回$0$</p>

<h2 id="优化">优化</h2>
<p>我们不妨随便找一个函数进行一下运算，比如：</p>

<div class="kdmath">$$
f(x)=x^2
$$</div>

<pre><code>  ^
 / \
x   2
</code></pre>

<p>代入之前得到的指数求导表达式：</p>

<div class="kdmath">$$
(x^2)'=x^2(2'\cdot\ln x+\dfrac2x\cdot x')
$$</div>

<p>建立的表达式树如下：</p>

<pre><code>        ×
    /       \
  ^           +
 / \       /     \
x   2    ×         *
       /   \      / \
    (2)'   ln    ÷   x'
           |    / \
           x   2   x
</code></pre>

<p>接着根据叶结点的处理规则，将$2’$替换成$0$，将$x’$替换成$1$，得到了表达式树：</p>

<pre><code>        ×
    /       \
  ^           +
 / \       /     \
x   2    ×         *
       /   \      / \
      0    ln    ÷   1
           |    / \
           x   2   x
</code></pre>

<p>可以看到，表达式树中有许多诸如<code>×0</code>，<code>×1</code>，<code>÷1</code>之类的冗余表达。为了去除这些冗余，我们需要对表达式树进行优化</p>

<h3 id="初级优化">初级优化</h3>
<p>结点的所有子结点均为常数时，直接合并成单个常数结点，例如$2+3$直接合并为$5$</p>
<ul>
  <li>加法：$a+0=0+a=a$</li>
  <li>减法：$a-0=a$, $0-a=-a$, $a-a=0$</li>
  <li>乘法：$a\times0=0$, $a\times1=a$</li>
  <li>除法：$a/0=\text{NaN}$, $a/1=a$, $0/a=0$, $a/a=1$</li>
  <li>乘方：$a^0=1$, $a^1=a$, $0^a=0$, $1^a=1$</li>
  <li>其它：$\ln1=0$, $\sin\pi=0$等</li>
</ul>

<h3 id="中级优化">中级优化</h3>

<p>涉及到某个结点和它的一级子结点</p>

<ul>
  <li>加减法：$a+(-b)=a-b$</li>
  <li>乘除法：$a\times(1/b)=a/b$</li>
  <li>乘方：$(a^n)\cdot a=a^{n+1}$, $(a^n)/a=a^{n-1}$</li>
  <li>对数：$a^{\log_ab}=b$…</li>
</ul>

<h3 id="高级优化">高级优化</h3>

<p>这些优化本身不一定能够让式子变得更加简洁，它要求机器能够判断展开后表达式是否能够进一步化简</p>

<ul>
  <li>乘法分配律：$(a+b)c=ac+bc$</li>
  <li>乘方运算律：$a^{b+c}=a^b\cdot a^c$</li>
  <li>对数运算律：$\log(ab)=\log a+\log b$</li>
</ul>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="math" /><category term="calculus" /><category term="algorithm" /><summary type="html"><![CDATA[求导是一种算符，输入一个表达式，输出另一个表达式]]></summary></entry><entry><title type="html">位运算的极致——快速平方根倒数算法</title><link href="mqcreaple.github.io/blog/2021/08/27/q-rsqrt-alg.html" rel="alternate" type="text/html" title="位运算的极致——快速平方根倒数算法" /><published>2021-08-27T00:00:00-04:00</published><updated>2021-08-27T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2021/08/27/q-rsqrt-alg</id><content type="html" xml:base="mqcreaple.github.io/blog/2021/08/27/q-rsqrt-alg.html"><![CDATA[<p>快速平方根倒数算法，最早见于1999年的3D游戏Quake III Arena的源代码中。该算法一经公布，立刻因它的巧妙而被广为流传</p>

<p>在当时，计算机的算力和算法还没有现在这样厉害，浮点数乘除法的计算代价都很高，更不要说平方根了。</p>

<p>另一方面，3D物理引擎几乎要求你每时每刻都要计算各种平方根。比如，计算力矢量在某个方向上的分量，需要计算$\hat v=\dfrac{\vec v}{\mid\vec v\mid}$，就会用到平方根倒数</p>

<p>温馨提示：请先阅读文章的最后一段，接着再从头开始阅读</p>

<h2 id="代码">代码</h2>

<p>这是一般人写出来的：</p>

<pre><code class="language-c">float rsqrt(float x) {
    return 1 / sqrt(x);
}
</code></pre>

<p>看起来人畜无害，不是吗？</p>

<p>但是注意，在当时，sqrt函数使用的算法本身就很慢，导致使用上面的函数计算平方根倒数效率极低</p>

<p>而下面这个，是Quake使用的快速平方根倒数算法：</p>

<pre><code class="language-c">float q_rsqrt(float x) {
    long i;
    float x2, y;
    const float threehalves = 1.5F;

    x2 = x * 0.5F;
    y = x;
    i = *(long*) &amp;y;
    i = 0x5f3759df - (i &gt;&gt; 1);
    y = *(float*) &amp;i;
    y = y * (threehalves - (x2 * y * y));
    // y = y * (threehalves - (x2 * y * y));

    return y;
}
</code></pre>

<p>看完是不是一脸问号？没关系，任何人看完都会一脸问号，因为这个算法用到了很多奇怪的知识</p>

<p>前置知识</p>

<ul>
  <li>知道C和C++中的指针</li>
  <li>知道电脑使用二进制存储信息</li>
  <li>知道什么是导数</li>
</ul>

<p>（下方高能预警）</p>

<h2 id="1-浮点数的计算机表示">#1 浮点数的计算机表示</h2>

<p>假设现在你有一个二进制小数，可是计算机只认识01组成的二进制串，并不认识小数，你该怎么办呢？</p>

<pre><code>_ _ _ _ _ _ _ _   _ _ _ _ _ _ _ _   _ _ _ _ _ _ _ _   _ _ _ _ _ _ _ _
</code></pre>

<p>容易想到，我只要在这个二进制串的某一个地方点一个小数点，小数点左边的作为整数位，右边的作为小数位，问题就解决了</p>

<pre><code>_ _ _ _ _ _ _ _   _ _ _ _ _ _ _ _  .  _ _ _ _ _ _ _ _   _ _ _ _ _ _ _ _
</code></pre>

<p>比如，二进制小数$(101101.01101)_2$，用我们刚刚的方法，就可以写成：</p>

<pre><code>0 0 0 0 0 0 0 0   0 0 1 0 1 1 0 1  .  0 1 1 0 1 0 0 0   0 0 0 0 0 0 0 0
</code></pre>

<p>小数的加减法也很简单，因为小数点永远固定，只需要忽略掉小数点，将他们全都当作二进制整数整数进行加减即可</p>

<p>这就是<strong>定点数</strong>，假想的小数点在某一个固定位置不会移动</p>

<p>与之对应的，则是<strong>浮点数</strong>，这个名词在学习C语言时应该听了无数遍了。 浮点数的字面意思是：<strong>小数点能够移动</strong></p>

<p>可能这样不太直观，我们先回想一下<strong>科学计数法</strong>：一个数可以被分解成一个$1$到$10$之间的小数和某个$10$的次幂之积。比如：</p>

<div class="kdmath">$$
34567.89=3.456789\times 10^{4}
$$</div>

<p>我们只需要写下这个$1$到$10$之间的有效数字，以及数的次幂（或者说是小数点的位置），即可唯一确定这个数</p>

<p>注意到，有效数字一定在$1$到$10$之间，也就是说它小数点左边必须有且只有一位数字</p>

<p>对于二进制数，也可以进行类比，只不过底数不再是10，而是2：</p>

<div class="kdmath">$$
(101101.01101)_2=(1.0110101101)_2\times 2^{(101)_2}
$$</div>

<p>那么，另一个思路来了：我们可以直接存储<strong>有效数字</strong>和<strong>小数点位置</strong>。这就是浮点数的基本思路</p>

<p>当然，不难注意到，有效数字的开头一定不能是$0$，否则一定可以写成另一个数字乘上$2$的负数次方。 例如：</p>

<div class="kdmath">$$
(0.01011)_2=(1.011)_2\times 2^{(-10)_2}
$$</div>

<p>而二进制中，除了$0$，那么必然是$1$。也就是说，<strong>二进制有效数字的第一位必须是1</strong>。所以说我们可以不用存储有效数字的首位，只存储小数点后的数字，计算的时候在开头补上$1$即可。</p>

<p>最后，为了能够表示负数，需要单独拿出来一位二进制作为<strong>符号位</strong>（0为正，1为负）。我们得到了浮点数的IEEE754规则：</p>

<pre><code>S   E E E E E E E E   M M M M M M M M M M M M M M M M M M M M M
</code></pre>

<p>第1位是符号位$S$，0表示正数，1表示负数。</p>

<p>第2到9位是指数位$E$，$E$的范围是$0$到$255$，会自动减去$127$，否则无法表示负数指数，也就是说它的实际值应该是$-127$到$128$</p>

<p>第10到32位是有效数字位$M$，共23位，运算时需要在在前面脑补一位$1$和小数点</p>

<p>也就是说，这一串二进制所表示的浮点数实际值等于：</p>

<div class="kdmath">$$
(-1)^S\times 2^{E-127}\times (1+\frac{M}{2^{23}})
$$</div>

<h2 id="2-算法的第一部分">#2 算法的第一部分</h2>

<p>说完了预备知识之后，接下来，进入平方根倒数的求解过程</p>

<p>显然负数不可能有平方根，因此我们可以默认输入的$x$必须是正数，也就是符号位$S$为0</p>

<p>如果平方根不好求的话，我们不妨先算一下$x$的对数</p>

<p>你也许会说，难道对数不应该更难计算吗？没关系，请看下面：</p>

<div class="kdmath">$$
\begin{align*}
x & = 2^{E-127}\times (1+\frac{M}{2^{23}}) \\
\log_2 x & = \log_2(1+\frac{M}{2^{23}}) + \log_2\left(2^{E-127}\right) \\
& = \log_2(1 + \frac{M}{2^{23}}) + E - 127
\end{align*}
$$</div>

<p>现在式子还是有点复杂，不妨对它取一个近似：当$a\in[0,1]$时，$\log(1+a)$可以近似成aa加上某个常数$\sigma$</p>

<div class="kdmath">$$
\log(1+a)\approx a+\sigma
$$</div>

<p><img src="/img/q-rsqrt-0.jpg" alt="q-rsqrt-0" /></p>

<p>绿色曲线为$\log_2(1+x)$，黄色直线为$x+\sigma$。如果想让误差最小，那么$\sigma$应该取大约$0.043$，通过微积分可以算出准确值，这里就不写了</p>

<p>有了这个知识，原式可以近似成：</p>

<div class="kdmath">$$
\log_2 x \approx \frac{M}{2^{23}}+\sigma+E-127
$$</div>

<div class="kdmath">$$
\log_2 x=\frac 1{2^{23}}(M+E\cdot 2^{23}) - (127 - \sigma)
$$</div>

<p>为什么要这样整理呢？我们不妨考虑另一件事：如果我们<em>强行将这个浮点数的二进制表达解读成整数</em>，会得到什么呢？</p>

<pre><code>0   E E E E E E E E M M M M M M M M M M M M M M M M M M M M M
</code></pre>

<p>第一位是符号位，而后面31位是数字位，最终我们得到了一个整数：</p>

<div class="kdmath">$$
\bar x=\overline{EM}=E\cdot 2^{23}+M
$$</div>

<p>暂且将这个数称为浮点数的整数值。不难看出刚刚推导$\log_2 x$时就推出了一模一样的表达式！接着将$\bar x$代回原式，得到：</p>

<div class="kdmath">$$
\log_2x\approx\frac{\bar x}{2^{23}}-(127-\sigma)
$$</div>

<p>现在，我们知道了：<strong>浮点数的对数，约等于它的整数值减去某一个常数</strong></p>

<p>这样我们就能理解之前代码中的这个步骤了：</p>

<pre><code class="language-c">i = *(long*) &amp;y;
</code></pre>

<p>这其实就是在<em>计算浮点数的整数值</em>！ 注意，直接写<code>i = (long) y;</code>是错的，因为这样会算出来浮点数下取整，而不是刚刚提到的<em>整数值</em></p>

<p>那么有了这个结论，求出平方根倒数就很简单了：</p>

<p><span class="kdmath">$\log_2 y=\log_2(\frac1{\sqrt{x}})=-\frac12\log_2(x)\approx\frac 12(127-\sigma)-\frac 12\frac{\bar x}{2^{23}}$</span>​</p>

<p>那么$y=1/\sqrt{x}$的整数值为：</p>

<div class="kdmath">$$
\begin{align*}
\bar y &\approx 2^{23}\log_2 y + 2^{23}(127-\sigma) \\
& = (2^{22} + 2^{23})(127 - \sigma) - \frac{\bar x}{2} \\
& \approx \text{0x5F3759DF} - \frac{\bar x}{2}
\end{align*}
$$</div>

<p>其中<code>0x5F3759DF</code>就是大名鼎鼎的“魔法值”。最后只需要将$\bar y$再强行转换成浮点数即可</p>

<p>以上就是算法的第一部分</p>

<p>当然，这里还有另一个技巧：<code>i &gt;&gt; 1</code>表示将整数$i$整个向右移动1个二进制位，也就是将$i$除以$2$</p>

<pre><code>i    = 00011011 01101100      &gt;&gt;&gt; right shift 1 digit
i&gt;&gt;1 = 00001101 10110110
</code></pre>

<p>综上所述，代码：</p>

<pre><code class="language-c">i = *(long*) &amp;y;
i = 0x5F3759DF - (i &gt;&gt; 1);
y = *(float*) &amp;i;
</code></pre>

<blockquote>
  <p>你能试试求出64位浮点数的“魔法值”吗？</p>
</blockquote>

<h2 id="3-代码的第二部分">#3 代码的第二部分</h2>

<p>注意到上面的所有推导，使用的几乎全都是<strong>约等于号</strong>，而不是等于号，因此计算出来的这个数字仍然有一定的误差。后续，我们接着使用牛顿迭代法求出精确解。</p>

<p>那<strong>牛顿迭代法</strong>又是什么？</p>

<p>假设现在我们有一个函数$f$，目标是求出它的根（即所有$x_0$使得$f(x_0)=0$），而我们只知道一个函数上的点$A=(x, f(x))$，怎么办？</p>

<p><img src="/img/q-rsqrt-1.jpg" alt="q-rsqrt-1" /></p>

<p>现在，我们作一条$A$点上的切线，切线与横轴的交点作为第一轮迭代的结果</p>

<p><img src="/img/q-rsqrt-2.jpg" alt="q-rsqrt-2" /></p>

<p>可以看到迭代后的点离函数的根已经近了很多</p>

<p><img src="/img/q-rsqrt-3.jpg" alt="q-rsqrt-3" /></p>

<p>我们还可以将一轮迭代的结果作为新的起点，进行第二轮迭代，接着第三轮、第四轮、……，最终就可以无限接近函数的根，并且迭代的收敛速度非常快</p>

<p>那么对于“求解平方根倒数”的这个例子，我们可以构造一个函数：</p>

<div class="kdmath">$$
f(y)=\frac 1{y^2}-x
$$</div>

<p>令$x$为一个常数，而$y$为变量，不难发现这个函数的根就是$y=1/\sqrt{x}$，那么我们的任务就是求解这个函数的根</p>

<p>那么，从$y_0$开始，采用上面的方法迭代，即</p>

<div class="kdmath">$$
y_{n+1}=y_n-\dfrac{f(y_n)}{f'(y_n)}
$$</div>

<p>代入$f(y)=\dfrac1{y^2}-x$，得到：</p>

<div class="kdmath">$$
y_{n+1}=\dfrac{y_n(3-xy_n^2)}{2}=y_n\left(\dfrac32-\dfrac12xy_n^2\right)
$$</div>

<p>这也就是代码最下方那个奇怪的表达式的含义：</p>

<pre><code class="language-c">y = y * (threehalves - (x2 * y * y));
</code></pre>

<p>经过一轮迭代，已经差不多能将误差控制在小数点后4位左右了，如果想要更加精确，也可以接着进行2、3、4轮迭代</p>

<p>以上就是算法的全过程，最后再贴一遍完整代码：</p>

<pre><code class="language-c">float q_rsqrt(float x) {
    long i;
    float x2, y;
    const float threehalves = 1.5F;

    x2 = x * 0.5F;
    y = x;
    i = *(long*) &amp;y;
    i = 0x5f3759df - (i &gt;&gt; 1);
    y = *(float*) &amp;i;
    y = y * (threehalves - (x2 * y * y));
    // y = y * (threehalves - (x2 * y * y));

    return y;
}
</code></pre>

<h2 id="这个算法有什么意义">这个算法有什么意义？</h2>
<p>如果你认真看完了上面的全过程，我要遗憾的告诉你：<strong>你可能永远也用不上它</strong></p>

<p>现在早已不是1999年了，硬件的更新和算法的改进让<strong>任何编程语言的内置函数都无法轻易被超越</strong></p>

<p>如果你用C语言或者C++进行测试的话，你会发现库函数<code>sqrt(x)</code>的速度要远远超过上面的算法</p>

<p>但是，把这个算法当作一个精致的艺术品反复观赏，也是一件挺有意思的事情，你也可以从里面学到不少</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="C++" /><category term="algorithm" /><summary type="html"><![CDATA[快速平方根倒数算法，最早见于1999年的3D游戏Quake III Arena的源代码中。该算法一经公布，立刻因它的巧妙而被广为流传]]></summary></entry><entry><title type="html">盘点亿些Julia人性化的设计</title><link href="mqcreaple.github.io/blog/2021/08/11/julia-yyds.html" rel="alternate" type="text/html" title="盘点亿些Julia人性化的设计" /><published>2021-08-11T00:00:00-04:00</published><updated>2021-08-11T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2021/08/11/julia-yyds</id><content type="html" xml:base="mqcreaple.github.io/blog/2021/08/11/julia-yyds.html"><![CDATA[<h2 id="symbols">Symbols</h2>

<h3 id="1-greek-letters">1. Greek Letters</h3>

<p>Python:</p>

<pre><code class="language-python">alpha = 1
beta = 2
gamma = 3
</code></pre>

<p>Julia:</p>

<pre><code class="language-julia">α = 1      # type "\alpha" and press [tab]
β = 2
γ = 3
</code></pre>

<h3 id="2-constants">2. constants</h3>

<p>Python:</p>

<pre><code class="language-python">import math
print(math.pi)
print(math.e)
</code></pre>

<p>Julia:</p>

<pre><code class="language-julia">println(π)     # "\pi"
println(ℯ)     # "\euler"
</code></pre>

<h3 id="3-operators">3. Operators</h3>

<p>Python:</p>

<pre><code class="language-python">3*x**2+2*x+1
sqrt(x)
</code></pre>

<p>Julia:</p>

<pre><code class="language-julia">3x^2+2x+1
√x  # same as sqrt(x)
</code></pre>

<h2 id="arrays--vectors">Arrays | Vectors</h2>

<h3 id="1-loop">1. loop</h3>

<p>Python:</p>

<pre><code class="language-python">import numpy as np
arr = np.array([1, 2, 3, 4, 5])
for a in arr:
    print(a)
</code></pre>

<p>Julia:</p>

<pre><code class="language-julia">arr = [1, 2, 3, 4, 5]
for a ∈ arr       # a "\in" arr
    println(a)
end
</code></pre>

<h3 id="2-vector-operation">2. vector operation</h3>

<p>Python:</p>

<pre><code class="language-python">import numpy as np
np.add([1, 2, 3], 1)
np.add([1, 2, 3], [4, 5, 6])
np.multiply([1, 2, 3], 2)
np.multiply([1, 2], [3, 4])
def f(x):
    return 2 * x + 1
map(f, [1, 2, 3, 4])
</code></pre>

<p>Julia:</p>

<pre><code class="language-julia">[1, 2, 3] .+ 1
[1, 2, 3] + [4, 5, 6]
[1, 2, 3] * 2
[1, 2] .* [3, 4]
f(x) = 2x + 1
f.([1, 2, 3, 4])
</code></pre>

<h3 id="3-matrix">3. Matrix</h3>

<p>Python:</p>

<pre><code class="language-python">import numpy as np
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])
C = A.dot(B)
D = A.transpose()
</code></pre>

<p>Julia:</p>

<pre><code class="language-julia">A = [1 2 ; 3 4]
B = [5 6 ; 7 8]
C = A * B
D = A'
</code></pre>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="julia" /><category term="python" /><summary type="html"><![CDATA[Symbols]]></summary></entry></feed>