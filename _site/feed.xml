<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="mqcreaple.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="mqcreaple.github.io/" rel="alternate" type="text/html" /><updated>2022-10-15T14:59:36-04:00</updated><id>mqcreaple.github.io/feed.xml</id><title type="html">My Blog | MqCreaple</title><subtitle>pay more attention to the beauty of formulas!</subtitle><author><name>MqCreaple</name></author><entry><title type="html">狭义相对论光线追踪 原理解析 1</title><link href="mqcreaple.github.io/blog/2022/10/14/relativistic-renderer-0.html" rel="alternate" type="text/html" title="狭义相对论光线追踪 原理解析 1" /><published>2022-10-14T00:00:00-04:00</published><updated>2022-10-14T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/10/14/relativistic-renderer-0</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/10/14/relativistic-renderer-0.html"><![CDATA[<p>前置知识：狭义相对论。</p>

<p>先温习一遍课本里的洛伦兹变换(Lorentz transformation)：如果参考系$S’$相对于$S$的速度为$u$，沿着$x$轴正方向，那么事件$(t, x, y, z)$在$S’$参考系中测量的结果是：</p>

<div class="kdmath">$$
\begin{cases}
t'=\gamma(t-\frac{u}{c^2}x) \\
x'=\gamma(x-ut) \\
y'=y \\
z'=z
\end{cases}
$$</div>

<p>其中$c$为光速，并且</p>

<div class="kdmath">$$
\gamma=\frac{1}{\sqrt{1-\frac{u^2}{c^2}}}
$$</div>

<h2 id="四维矢量和闵可夫斯基空间">四维矢量和闵可夫斯基空间</h2>

<p>洛伦兹变换有一大性质：如果两个事件$\mathbf r_1$和$\mathbf r_2$，那么不论在哪个惯性参考系中看，这个物理量：</p>

<div class="kdmath">$$
s^2=-(c\Delta t)^2+\Delta x^2+\Delta y^2+\Delta z^2
$$</div>

<p>是永远不变的。它被称为<strong>闵可夫斯基度规(Minkowski metric)</strong>，或者<strong>闵氏度规</strong>。</p>

<p>这启发了我们，可以定义一个四维矢量来表示事件。为了保证单位一致，第一维是光速乘上时间，后三维是空间。像这样：</p>

<div class="kdmath">$$
\mathbf r=(ct, x, y, z)=(ct, \vec{r})
$$</div>

<p><em>（为了方便区分，本文中所有四维向量均用粗体表示，三维向量均用箭头表示）</em></p>

<p>然后向量的模长公式不再是平方求和后再相加，而是：</p>

<div class="kdmath">$$
||\mathbf r||=\sqrt{-(ct)^2+x^2+y^2+z^2}
$$</div>

<p>这样的话，两个事件$\mathbf r_1$和$\mathbf r_2$之间的<strong>距离</strong>（或者说：闵氏度规）就是：</p>

<div class="kdmath">$$
s=||\mathbf r_2-\mathbf r_1||
$$</div>

<p>你可能会觉得为了凑出这个表达式而强行修改向量模长定义的行为很不好。但是，我们可以把它看作是一种和我们所处的空间（即：欧几里得空间/欧氏空间）完全不同的<strong>几何</strong>，也就是<strong>闵可夫斯基几何</strong>/<strong>闵氏几何</strong>。毕竟，没有规定说我们的宇宙一定遵守欧氏几何这种符合人类直觉的规律。</p>

<p>所有满足这个奇怪的模长公式的向量构成了一个向量空间，即<strong>闵可夫斯基空间</strong>，或者也可以叫<strong>闵可夫斯基时空</strong>。在闵氏空间里，向量的第一维和后三维的地位并不相同。</p>

<p>闵氏空间里，向量点乘（内积）的定义也被修改了：向量$\mathbf u$和$\mathbf v$的点乘是：</p>

<div class="kdmath">$$
\mathbf u\cdot\mathbf v=-u_tv_t+u_xv_x+u_yv_y+u_zv_z
$$</div>

<p>而洛伦兹变换就是一个4×4的矩阵：</p>

<div class="kdmath">$$
\Lambda=\begin{bmatrix}
\gamma & -\frac{u}{c}\gamma & 0 & 0 \\
-\frac{u}{c}\gamma & \gamma & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$</div>

<p>将$S$系中的事件$\mathbf r$转到$S’$系，就相当于用矩阵$\Lambda$乘上$\mathbf r$：</p>

<div class="kdmath">$$
\mathbf r'=\Lambda\mathbf r
$$</div>

<h2 id="任意方向的洛伦兹变换">任意方向的洛伦兹变换</h2>

<p>刚刚的讨论里，相对速度$u$都是沿着$x$轴正方向的。但是如果$u$不是呢？</p>

<p>可以这样想：把一个事件$\mathbf r$的空间分量$\vec r$分解成平行于速度分量$\vec r_\parallel$和垂直于速度的分量$\vec r_\perp$。</p>

<div class="kdmath">$$
\vec r_\parallel=(\vec r\cdot \vec n)\vec n=\left(\vec r\cdot\frac{\vec u}{||\vec u||}\right)\frac{\vec u}{||\vec u||}
$$</div>

<div class="kdmath">$$
\vec r_\perp=\vec r-\vec r_\parallel
$$</div>

<p>其中$\vec n=\frac{\vec u}{\mid\mid\vec u\mid\mid}$，是速度$\vec u$方向上的单位向量。</p>

<p>经过变换之后，$\vec r_\perp$分量不变，而$\vec r_\parallel$会变成$\gamma(\vec r_\parallel-\vec ut)$。</p>

<div class="kdmath">$$
\begin{align*}
\vec r' &=\vec r_\perp+\gamma(\vec r_\parallel-\vec ut) \\
&= (\vec r-(\vec r\cdot\vec n)\vec n) + \gamma((\vec r\cdot \vec n)\vec n-\vec ut) \\
&= \vec r + (\gamma-1)(\vec r\cdot\vec n)\vec n-\gamma\vec ut
\end{align*}
$$</div>

<p>而时间变换则简单一些：</p>

<div class="kdmath">$$
\begin{align*}
t'&=\gamma(t-\frac{u}{c^2}r_\parallel) \\
&= \gamma(t-\frac{\vec u}{c^2}\cdot \vec r)
\end{align*}
$$</div>

<p>将上面的变换公式写成矩阵，就是：</p>

<div class="kdmath">$$
\begin{bmatrix}ct'\\x'\\y'\\z'\end{bmatrix}=
\begin{bmatrix}
\gamma & -\gamma\frac{u_x}{c} & -\gamma\frac{u_y}{c} & -\gamma\frac{u_z}{c} \\
-\gamma\frac{u_x}{c} & 1+(\gamma-1)n_x^2 & (\gamma-1)n_xn_y & (\gamma-1)n_xn_z \\
-\gamma\frac{u_y}{c} & (\gamma-1)n_yn_x & 1+(\gamma-1)n_y^2 & (\gamma-1)n_yn_z \\
-\gamma\frac{u_z}{c} & (\gamma-1)n_zn_x & (\gamma-1)n_zn_y & 1+(\gamma-1)n_z^2
\end{bmatrix}
\begin{bmatrix}ct\\x\\y\\z\end{bmatrix}
$$</div>

<p>也就是说，速度$\vec u$方向任意的洛伦兹变换矩阵就是：</p>

<div class="kdmath">$$
\Lambda(\vec u)=\begin{bmatrix}
\gamma & -\gamma\frac{u_x}{c} & -\gamma\frac{u_y}{c} & -\gamma\frac{u_z}{c} \\
-\gamma\frac{u_x}{c} & 1+(\gamma-1)n_x^2 & (\gamma-1)n_xn_y & (\gamma-1)n_xn_z \\
-\gamma\frac{u_y}{c} & (\gamma-1)n_yn_x & 1+(\gamma-1)n_y^2 & (\gamma-1)n_yn_z \\
-\gamma\frac{u_z}{c} & (\gamma-1)n_zn_x & (\gamma-1)n_zn_y & 1+(\gamma-1)n_z^2
\end{bmatrix}
$$</div>

<p>其中</p>

<div class="kdmath">$$
\gamma=\frac{1}{\sqrt{1-\frac{||\vec u||^2}{c^2}}}
$$</div>

<p>可以检验，当$\vec u$的大小为$u$而方向指向$x$轴正半轴时，$\Lambda(\vec u)$和之前给出的矩阵相等。</p>

<h2 id="速度变换">速度变换</h2>

<p>任何一个物体的运动都可以表示成闵氏时空中的一条曲线。在$S$系中，物体的速度是：</p>

<div class="kdmath">$$
\vec v=\frac{\mathrm d\vec r}{\mathrm dt}
$$</div>

<p>而$S’$系中，同一个物体的速度是：</p>

<div class="kdmath">$$
\vec v'=\frac{\mathrm d\vec r'}{\mathrm dt'}
$$</div>

<p>为了用$\vec v$表示$\vec v’$，可以先用一个链式法则：</p>

<div class="kdmath">$$
\begin{align*}
\vec v' &= \frac{\mathrm d\vec r'}{\mathrm dt'} \\
&= \frac{\partial\vec r'}{\partial t}\frac{\mathrm dt}{\mathrm dt'}+\frac{\partial\vec r'}{\partial x}\frac{\mathrm dx}{\mathrm dt'}+\frac{\partial\vec r'}{\partial y}\frac{\mathrm dy}{\mathrm dt}+\frac{\partial\vec r'}{\partial z}\frac{\mathrm dz}{\mathrm dt} \\
&= \sum_{i=1}^4\frac{\partial\vec r'}{\partial\mathbf r_i}\frac{\mathrm d\mathbf r_i}{\mathbf dt'}
\end{align*}
$$</div>

<p>其中$\mathbf r_i$为$\mathbf r$的第$i$个分量。偏导数$\frac{\partial\vec r’}{\partial\mathbf r_i}$很好求，接下来只需要求出全导数$\frac{\mathrm d\mathbf r_i}{\mathrm dt’}$即可。</p>

<p>这里我们还可以用一个链式法则：</p>

<div class="kdmath">$$
\begin{align*}
\frac{\mathrm d\mathbf r_i}{\mathrm dt'} &= \left(\frac{\mathrm dt'}{\mathrm d\mathbf r_i}\right)^{-1} \\
&= \left(\sum_{j=1}^4\frac{\partial t'}{\partial\mathbf r_j}\frac{\mathrm d\mathbf r_j}{\mathrm d\mathbf r_i}\right)^{-1}
\end{align*}
$$</div>

<p>不难想到，</p>

<div class="kdmath">$$
\frac{\mathrm dx}{\mathrm dt}=v_x,\ \frac{\mathrm dy}{\mathrm dt}=v_y,\ \frac{\mathrm dz}{\mathrm dt}=v_z
$$</div>

<div class="kdmath">$$
\frac{\mathrm dx}{\mathrm dy}=\frac{v_x}{v_y},\ \frac{\mathrm dy}{\mathrm dz}=\frac{v_y}{v_z},\ \frac{\mathrm dz}{\mathrm dx}=\frac{v_z}{v_x}
$$</div>

<p>也就是说，任何形如$\frac{\mathrm d\mathbf r_j}{\mathrm d\mathbf r_i}$的表达式，都可以表示成速度分量的比值。然后把这些东西再带回原式，就可以算出来了。</p>

<p>由于过程太长，我就不全打出来了。以下是答案：</p>

<div class="kdmath">$$
\vec v'=\frac{1}{1-\frac{\vec u\cdot\vec v}{c^2}}\left(\frac{\vec v}{\gamma}-\vec u+\frac 1{c^2}\frac{\gamma}{\gamma+1}(\vec u\cdot\vec v)\vec u\right)
$$</div>

<p>遗憾的是，速度变换并不是线性变换，所以没办法写成矩阵形式。</p>

<h2 id="光相差relativistic-abberation">光相差（Relativistic Abberation）</h2>

<p>我们可以把光线当成是运动速度为光速的物体，那么同样可以对其进行速度变换。</p>

<p>代入前面的速度变换公式，不难检验，若在$S$系中速度$v$大小为光速，那么经过速度变换之后，$S’$系中$v’$也是光速。这又被称为：<strong>光速不变原则</strong>，光速运动的物体无论在哪个参考系中都是光速运动的。</p>

<p>但是需要注意，在两个参考系中，光的方向会发生变化。</p>

<p>如果在静止的参考系里，从一个点在各个方向上均匀发出光线：</p>

<p><img src="/img/rel-plot-1.png" alt="" /></p>

<p>那么在一个朝右运动的参考系里，光线的方向不再均匀，而是向运动的反方向聚集：</p>

<p><img src="/img/rel-plot-2.png" alt="" /></p>

<p>类似地，在一个接收光线的观察者看来，如果它在以接近光速运动，会有更多光线朝着它面前打过来，而它背后的光线就会减弱。</p>

<p>这个光线角度在运动参考系中发生偏转的现象就被称为：狭义相对论光相差。</p>

<blockquote>
  <p>鉴于本文作者比较菜，如果您在阅读时发现了任何错误，欢迎在<a href="/">主页</a>评论区指出！</p>
</blockquote>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="physics" /><category term="special-relativity" /><category term="computer-graphics" /><summary type="html"><![CDATA[前置知识：狭义相对论。]]></summary></entry><entry><title type="html">封装一棵线段树</title><link href="mqcreaple.github.io/blog/2022/10/02/segment-tree-class.html" rel="alternate" type="text/html" title="封装一棵线段树" /><published>2022-10-02T00:00:00-04:00</published><updated>2022-10-02T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/10/02/segment-tree-class</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/10/02/segment-tree-class.html"><![CDATA[<p>最近得了个“小感冒”，实在懒得去做题，然后就在其他人的博客里瞎逛。无意间发现了zxp大佬之前写过的<a href="https://zxp2019.github.io/blog/article/segment-tree-class/"><em>封装一棵线段树</em></a>，然后就想把这里的代码稍微改得更像C++标准库一点。</p>

<h2 id="基本结构">基本结构</h2>

<p>首先肯定是不能用数组来写线段树了，而应当用一个更高级的工具：<strong>指针</strong>。</p>

<p>我们在线段树结点的struct里放这些东西：</p>

<pre><code class="language-cpp">struct Node {
    int leftBound;  // inclusive
    int rightBound; // exclusive
    Node *leftChild;
    Node *rightChild;
    T sum;
    T lazy;
    Node(int leftBound, int rightBound)
        : leftBound(leftBound), rightBound(rightBound), leftChild(nullptr), rightChild(nullptr), sum(0), lazy(0) {}
};
</code></pre>

<p><em>（为了对应大部分C++标准库的规则，这里的左边界是包含的，而右边界则不包含，相当于这个结点覆盖的是区间上<code>[left, right)</code>的部分）</em></p>

<p>然后在每个线段树类里面记录一下线段树的根结点<code>root</code>即可：</p>

<pre><code class="language-cpp">class QuickArray {
public:
private:
    struct Node {
        // Omitted
    };
    Node *root;
};
</code></pre>

<p>然后就是其他操作了：</p>

<h2 id="线段树的操作">线段树的操作</h2>

<h3 id="创建线段树">创建线段树</h3>

<p>这里我直接把它放在了线段树类<code>QuickArray</code>的构造函数里。代码是这样的：</p>

<pre><code class="language-cpp">class QuickArray {
public:
    QuickArray(int left, int right): root(buildTree(left, right)) {}
};
</code></pre>

<p>而这里的<code>buildTree</code>是一个私有的辅助函数，专门用来构造线段树：</p>

<pre><code class="language-cpp">private:
    static Node *buildTree(int left, int right) {
        Node *cur = new Node(left, right);        // create a new node in memory
        if(right - left &lt;= 1) {
            return cur;                           // current node is leaf, directly return from function
        }
        int mid = (left + right) / 2;
        cur-&gt;leftChild = buildTree(left, mid);    // build left tree
        cur-&gt;rightChild = buildTree(mid, right);  // build right tree
        return cur;
    }
</code></pre>

<h3 id="更新区间">更新区间</h3>

<p>更新区间的操作就是线段树板子了，直接贴上去就好：</p>

<pre><code class="language-cpp">public:
    void add(int left, int right, T value) {
        if(left &lt; right) {
            // to prevent illegal update
            nodeAdd(root, left, right, value);
        }
    }
private:
    static void nodeAdd(Node *n, IndexT left, IndexT right, T value) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return;
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            n-&gt;lazy += value;
            pushDown(n);
            return;
        }
        nodeAdd(n-&gt;leftChild, left, right, value);
        nodeAdd(n-&gt;rightChild, left, right, value);
        n-&gt;sum = n-&gt;leftChild-&gt;sum + n-&gt;rightChild-&gt;sum;
    }
</code></pre>

<h3 id="区间查询">区间查询</h3>

<p>还是板子。先写一个<code>pushDown</code>：</p>

<pre><code class="language-cpp">private:
    static void pushDown(Node *n) {
        if(n-&gt;leftChild != nullptr &amp;&amp; n-&gt;rightChild != nullptr) {
            n-&gt;leftChild-&gt;lazy += n-&gt;lazy;
            n-&gt;rightChild-&gt;lazy += n-&gt;lazy;
            n-&gt;sum += n-&gt;lazy * (n-&gt;rightBound - n-&gt;leftBound);
        } else {
            n-&gt;sum += n-&gt;lazy;
        }
        n-&gt;lazy = 0;
    }
</code></pre>

<p>然后就是区间查询的代码：</p>

<pre><code class="language-cpp">public:
    T sum(int left, int right) const {
        if(left &lt; right) {
            return nodeSum(root, left, right);
        }
        throw "Invalid query!";
    }
private:
    static T nodeSum(Node *n, IndexT left, IndexT right) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return T(0);
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            return n-&gt;sum;
        }
        return nodeSum(n-&gt;leftChild, left, right) + nodeSum(n-&gt;rightChild, left, right);
    }
</code></pre>

<h3 id="其他">其他</h3>

<p>再加一些可能用得上的函数，比如查询区间的左端和右端：</p>

<pre><code class="language-cpp">public:
    int leftBound() const {
        return root-&gt;leftBound;
    }
    int rightBound() const {
        return root-&gt;rightBound;
    }
</code></pre>

<p>完成！</p>

<h2 id="第一版代码">第一版代码</h2>

<pre><code class="language-cpp">#pragma once

template&lt;typename T&gt;
class QuickArray {
public:
    typedef int IndexT;
    /**
     * @brief Construct a QuickArray from left and right bound
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     */
    QuickArray(IndexT left, IndexT right): root(buildTree(left, right)) {}

    /**
     * @brief Construct a new QuickArray from a given array
     * @param array array with initial elements
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     */
    QuickArray(T *array, IndexT left, IndexT right): root(buildTree(array, left, right)) {}

    /**
     * @brief Add a given number to every term in range [left, right)
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     * @param amount amount to add
     */
    void add(IndexT left, IndexT right, T value) {
        if(left &lt; right) {
            nodeAdd(root, left, right, value);
        }
    }

    /**
     * @brief Find the sum of all terms in range [left, right)
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     * @return T sum
     */
    T sum(IndexT left, IndexT right) const {
        if(left &lt; right) {
            return nodeSum(root, left, right);
        }
        throw "Invalid query!";
    }

    /**
     * @brief Get the array's left bound
     * @return IndexT left bound (inclusive)
     */
    IndexT leftBound() const {
        return root-&gt;leftBound;
    }

    /**
     * @brief Get the array's right bound
     * @return IndexT right bound (exclusive)
     */
    IndexT rightBound() const {
        return root-&gt;rightBound;
    }

    ~QuickArray() {
        removeNodes(root);
    }
private:
    struct Node {
        IndexT leftBound;  // inclusive
        IndexT rightBound; // exclusive
        Node *leftChild;
        Node *rightChild;
        T sum;
        T lazy;
        Node(int leftBound, int rightBound)
            : leftBound(leftBound), rightBound(rightBound), leftChild(nullptr), rightChild(nullptr), sum(0), lazy(0) {}
    };
    Node *root;

    static Node *buildTree(IndexT left, IndexT right) {
        Node *cur = new Node(left, right);        // create a new node in memory
        if(right - left &lt;= 1) {
            return cur;                           // current node is leaf, directly return from function
        }
        IndexT mid = (left + right) / 2;
        cur-&gt;leftChild = buildTree(left, mid);    // build left tree
        cur-&gt;rightChild = buildTree(mid, right);  // build right tree
        return cur;
    }

    static Node *buildTree(T *array, IndexT left, IndexT right) {
        Node *cur = new Node(left, right);
        if(right - left &lt;= 1) {
            cur-&gt;sum = array[left];
            return cur;
        }
        IndexT mid = (left + right) / 2;
        cur-&gt;leftChild = buildTree(array, left, mid);
        cur-&gt;rightChild = buildTree(array, mid, right);
        cur-&gt;sum = cur-&gt;leftChild-&gt;sum + cur-&gt;rightChild-&gt;sum;
        return cur;
    }

    static void pushDown(Node *n) {
        if(n-&gt;leftChild != nullptr &amp;&amp; n-&gt;rightChild != nullptr) {
            n-&gt;leftChild-&gt;lazy += n-&gt;lazy;
            n-&gt;rightChild-&gt;lazy += n-&gt;lazy;
            n-&gt;sum += n-&gt;lazy * (n-&gt;rightBound - n-&gt;leftBound);
        } else {
            n-&gt;sum += n-&gt;lazy;
        }
        n-&gt;lazy = 0;
    }

    static void nodeAdd(Node *n, IndexT left, IndexT right, T value) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return;
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            n-&gt;lazy += value;
            pushDown(n);
            return;
        }
        nodeAdd(n-&gt;leftChild, left, right, value);
        nodeAdd(n-&gt;rightChild, left, right, value);
        n-&gt;sum = n-&gt;leftChild-&gt;sum + n-&gt;rightChild-&gt;sum;
    }

    static T nodeSum(Node *n, IndexT left, IndexT right) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return T(0);
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            return n-&gt;sum;
        }
        return nodeSum(n-&gt;leftChild, left, right) + nodeSum(n-&gt;rightChild, left, right);
    }

    static void removeNodes(Node *n) {
        if(n == nullptr) {
            return;
        }
        removeNodes(n-&gt;leftChild);
        removeNodes(n-&gt;rightChild);
        delete n;
    }
};
</code></pre>

<h2 id="改进">改进</h2>

<p>我们用C++新特性：智能指针，来代替上文中的<code>Node*</code>。这增加了程序的安全性。</p>

<p>由于我们不需要复制结点指针，所有指针一律改成<code>unique_ptr</code>即可：</p>

<blockquote>
  <p><code>unique_ptr</code>是一个类，用来模拟一个指针。</p>

  <p>如果<code>unique_ptr</code>指向一个堆中的对象，那么当它的作用域结束之后，<code>unique_ptr</code>的析构函数会自动释放该对象的内存，不用手动<code>delete</code>。</p>

  <p><code>unique_ptr</code>不允许复制，这样保证了不会有两个指针指向同一块内存而导致将该内存释放多次。</p>
</blockquote>

<p>（如果你学过Rust，可能会对<code>unique_ptr</code>感到很熟悉）</p>

<p>以下为改成<code>unique_ptr</code>的代码：</p>

<pre><code class="language-cpp">#pragma once

#include &lt;memory&gt;
using std::unique_ptr;

template&lt;typename T&gt;
class QuickArray {
public:
    typedef int IndexT;
    /**
     * @brief Construct a QuickArray from left and right bound
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     */
    QuickArray(IndexT left, IndexT right) {
        buildTree(root, left, right);
    }

    /**
     * @brief Construct a new QuickArray from a given array
     * @param array array with initial elements
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     */
    QuickArray(T *array, IndexT left, IndexT right) {
        buildTree(root, array, left, right);
    }

    /**
     * @brief Add a given number to every term in range [left, right)
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     * @param amount amount to add
     */
    void add(IndexT left, IndexT right, T value) {
        if(left &lt; right) {
            nodeAdd(root, left, right, value);
        }
    }

    /**
     * @brief Find the sum of all terms in range [left, right)
     * @param left left bound (inclusive)
     * @param right right bound (exclusive)
     * @return T sum
     */
    T sum(IndexT left, IndexT right) const {
        if(left &lt; right) {
            return nodeSum(root, left, right);
        }
        throw "Invalid query!";
    }

    /**
     * @brief Get the array's left bound
     * @return IndexT left bound (inclusive)
     */
    IndexT leftBound() const {
        return root-&gt;leftBound;
    }

    /**
     * @brief Get the array's right bound
     * @return IndexT right bound (exclusive)
     */
    IndexT rightBound() const {
        return root-&gt;rightBound;
    }
private:
    struct Node {
        IndexT leftBound;  // inclusive
        IndexT rightBound; // exclusive
        unique_ptr&lt;Node&gt; leftChild;
        unique_ptr&lt;Node&gt; rightChild;
        T sum;
        T lazy;
        Node(int leftBound, int rightBound)
            : leftBound(leftBound), rightBound(rightBound), leftChild(), rightChild(), sum(0), lazy(0) {}
    };
    unique_ptr&lt;Node&gt; root;

    static void buildTree(unique_ptr&lt;Node&gt; &amp;cur, IndexT left, IndexT right) {
        cur = std::make_unique&lt;Node&gt;(left, right);  // equivalent to `cur = new Node(left, right)` in C pointer
        if(right - left &lt;= 1) {
            return;
        }
        IndexT mid = (left + right) / 2;
        buildTree(cur-&gt;leftChild, left, mid);
        buildTree(cur-&gt;rightChild, mid, right);
    }

    static void buildTree(unique_ptr&lt;Node&gt; &amp;cur, T *array, IndexT left, IndexT right) {
        cur = std::make_unique&lt;Node&gt;(left, right);
        if(right - left &lt;= 1) {
            cur-&gt;sum = array[left];
            return;
        }
        IndexT mid = (left + right) / 2;
        buildTree(cur-&gt;leftChild, array, left, mid);
        buildTree(cur-&gt;rightChild, array, mid, right);
        cur-&gt;sum = cur-&gt;leftChild-&gt;sum + cur-&gt;rightChild-&gt;sum;
    }

    static void pushDown(const unique_ptr&lt;Node&gt; &amp;n) {
        if(n-&gt;leftChild != nullptr &amp;&amp; n-&gt;rightChild != nullptr) {
            n-&gt;leftChild-&gt;lazy += n-&gt;lazy;
            n-&gt;rightChild-&gt;lazy += n-&gt;lazy;
            n-&gt;sum += n-&gt;lazy * (n-&gt;rightBound - n-&gt;leftBound);
        } else {
            n-&gt;sum += n-&gt;lazy;
        }
        n-&gt;lazy = 0;
    }

    static void nodeAdd(const unique_ptr&lt;Node&gt; &amp;n, IndexT left, IndexT right, T value) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return;
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            n-&gt;lazy += value;
            pushDown(n);
            return;
        }
        nodeAdd(n-&gt;leftChild, left, right, value);
        nodeAdd(n-&gt;rightChild, left, right, value);
        n-&gt;sum = n-&gt;leftChild-&gt;sum + n-&gt;rightChild-&gt;sum;
    }

    static T nodeSum(const unique_ptr&lt;Node&gt; &amp;n, IndexT left, IndexT right) {
        pushDown(n);
        if(n-&gt;leftBound &gt;= right || n-&gt;rightBound &lt;= left) {
            return T(0);
        }
        if(n-&gt;leftBound &gt;= left &amp;&amp; n-&gt;rightBound &lt;= right) {
            return n-&gt;sum;
        }
        return nodeSum(n-&gt;leftChild, left, right) + nodeSum(n-&gt;rightChild, left, right);
    }
};
</code></pre>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="algorithm" /><summary type="html"><![CDATA[最近得了个“小感冒”，实在懒得去做题，然后就在其他人的博客里瞎逛。无意间发现了zxp大佬之前写过的封装一棵线段树，然后就想把这里的代码稍微改得更像C++标准库一点。]]></summary></entry><entry><title type="html">【整活】所有算法都是O(1)的</title><link href="mqcreaple.github.io/blog/2022/09/06/time-compl.html" rel="alternate" type="text/html" title="【整活】所有算法都是O(1)的" /><published>2022-09-06T00:00:00-04:00</published><updated>2022-09-06T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/09/06/time-compl</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/09/06/time-compl.html"><![CDATA[<p><em>注：本文全部内容为<strong>一本正经的胡说八道</strong>，请勿相信</em></p>

<h2 id="示范快速排序算法">示范：快速排序算法</h2>

<p><strong>第一步：复制粘贴一份代码</strong></p>

<pre><code class="language-cpp">void qsort(int *a, int l, int r)
{
    int pivot = a[(l+r)/2];
    int i = l, j = r;
    do {
        while(a[i] &lt; pivot) i++;
        while(a[j] &gt; pivot) j--;
        if(i&lt;=j) {
            swap(a[i], a[j]);
            i++;
            j--;
        }
    } while(i &lt;= j);
    if(l &lt; j) qsort(a, l, j);
    if(i &lt; r) qsort(a, i, r);
}
int main() {
    const int N = 100001;
    int n;
    int a[N];
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
    }
    qsort(a, 0, n-1);            // sort the array
    for(int i = 0; i &lt; n; i++) {
        cout &lt;&lt; a[i] &lt;&lt; " ";
    }
}
</code></pre>

<p>然后我们很失望，因为这个算法是$O(N\log N)$的。</p>

<p><strong>第二步：观察数据范围</strong></p>

<p><img src="/img/time-compl-0.png" alt="time-compl-0" /></p>

<p>我们发现，$N$不超过$10^5$，接下来就有办法了。</p>

<p><strong>第三步：补齐数组</strong></p>

<p>在我们的代码里面更改下面几处：</p>

<pre><code class="language-diff">int main() {
    const int N = 100001;
    int n;
    int a[N];
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
    }
+   for(int i = n; i &lt; N; i++) {
+       a[i] = INT32_MAX;       // fill the rest of array with INT32_MAX
+   }
-   sort(a, 0, n-1);            // sort the array
+   sort(a, 0, N-1);            // sort the whole array
    for(int i = 0; i &lt; n; i++) {
        cout &lt;&lt; a[i] &lt;&lt; " ";
    }
}
</code></pre>

<p>然后你就惊奇地发现，不管你输入的数组是多大，这个算法都会排序$1$到$N$之间的所有数，它所需要的执行时间都是一样的。换句话说：<strong>这个算法是$O(1)$的</strong>。</p>

<p><strong>第四步：为自己献上热烈的掌声</strong></p>

<p>至此，你成功地将一个$O(N\log N)$的算法变成了$O(1)$的算法。</p>

<h2 id="练习">练习</h2>

<ol>
  <li>$O(1)$计算快速幂</li>
  <li>$O(1)$解决图的最短路问题</li>
  <li>$O(1)$解决A+B problem</li>
</ol>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="algorithm" /><category term="time-complexity" /><category term="jokes" /><summary type="html"><![CDATA[注：本文全部内容为一本正经的胡说八道，请勿相信]]></summary></entry><entry><title type="html">Y combinator和递归</title><link href="mqcreaple.github.io/blog/2022/09/02/y-combinator.html" rel="alternate" type="text/html" title="Y combinator和递归" /><published>2022-09-02T00:00:00-04:00</published><updated>2022-09-02T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/09/02/y-combinator</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/09/02/y-combinator.html"><![CDATA[<link rel="stylesheet" href="/app/lambda-playground/lambda-playground.css" />

<script src="/app/lambda-playground/lambda-playground.js" onload="autoRender()"></script>

<p><strong>温馨提示：如果你不了解λ演算，请阅读<a href="/blog/2022/08/27/lambda.html">上一篇博客</a>以获得最佳食用体验</strong></p>

<p><em>注：本文的λ表达式中所有出现的下划线<code>_</code>，都表示“这个值我懒得算且不关心”</em></p>

<h2 id="y组合子">Y组合子</h2>

<p>其实，并不是所有的λ表达式都可以化简。比如说，一个经典的构造就是：</p>

<pre><code class="language-plaintext">Ω := ((λx. (x x)) (λx. (x x)))
</code></pre>

<p class="lambda-r">[ [ "λx", [ "x", "x" ] ], [ "λx", [ "x", "x" ] ] ]</p>

<p>这个表达式很有意思。当你把后面的表达式代入前面的<code>x</code>中时，你又会得到和原来一摸一样的表达式，你永远也无法化简它。也就是，它是<strong>不可求值</strong>的。</p>

<p>而我们对这个表达式简单地变一下，就得到了另一个表达式：</p>

<pre><code class="language-plaintext">((λx. f (x x)) (λx. f (x x)))
</code></pre>

<p class="lambda-r">[ [ "λx", [ "f", [ "x", "x" ] ] ], [ "λx", [ "f", [ "x", "x" ] ] ] ]</p>

<p>当你把后一项代入前一项时，它不仅得到了原来的表达式，而且还在外面多套上了一层函数<code>f</code>。再进行一次替换操作，函数外面又多了一层<code>f</code>，你可以一直这样无穷无尽地迭代下去。</p>

<p>稍稍将外面这个函数改一下，就得到了著名的<strong>Y组合子(Y combinator)</strong>：</p>

<pre><code class="language-lisp">Y := λf. ((λx. f (x x)) (λx. f (x x)))
</code></pre>

<p>Y组合子的一大性质就是：</p>

<pre><code class="language-lisp">(Y f) = (f (Y f))
</code></pre>

<p>由于它和函数的不动点$x=f(x)$长得很像，所以Y组合子也叫<strong>不动点组合子(fixed point combinator)</strong>。</p>

<p><em>注：Y组合子并不是唯一的不动点组合子。比如由Alan Turing给出的Θ组合子</em></p>

<pre><code class="language-lisp">Θ := ((λx. λy. y (x x y)) (λx. λy. y (x x y)))
</code></pre>

<p><em>它同样满足不动点组合子的性质：</em></p>

<pre><code class="language-lisp">(Θ f) = (f (Θ f))
</code></pre>

<p>根据不动点组合子的性质，任何不动点组合子<code>fix</code>都有：</p>

<pre><code class="language-lisp">(fix f) = (f (fix f))
        = (f (f (fix f)))
        = (f (f (f (fix f))))
        = ...
        = (n f (fix f))
</code></pre>

<p>其中<code>n</code>为任意有限的自然数。这个式子我们在之后还会用到。如果你忘记了自然数的Church计数法，可以回到<a href="/blog/2022/08/27/lambda.html">上一篇博客</a>。</p>

<h2 id="函数递归">函数递归</h2>

<p>Y组合子的一大用途，就是在λ代数中表示“递归”。</p>

<p>例如，你可能会这样写一个求阶乘的函数：</p>

<pre><code class="language-plaintext">fac = λx. (if (x==0)
                (1)
                (x*(fac (x-1))))
</code></pre>

<p>（为了方便起见，这里我就不写成前缀表达式了）</p>

<blockquote>
  <p>注：<code>if</code>语句</p>

  <p><code>(if b x y)</code>的定义是：如果<code>b</code>为真，返回<code>x</code>，否则返回<code>y</code>。</p>

  <p>根据我们对布尔值<code>T</code>和<code>F</code>的定义：</p>

  <pre><code class="language-plaintext">T := λa. λb. a
F := λa. λb. b
</code></pre>

  <p>语句<code>(if b x y)</code>可以看作是<code>(b x y)</code>的另一种写法</p>
</blockquote>

<p>可惜的是，λ演算里并没有递归的语法。但是有了Y组合子，我们也可以实现类似递归的效果。</p>

<p>首先我们重写一下刚刚的<code>fac</code>函数：</p>

<pre><code class="language-plaintext">fac = λf. λx. (if (x==0)
                    (1)
                    (x*(f (x-1))))
</code></pre>

<p>现在<code>fac</code>变成了接受一个函数<code>f</code>和参数<code>x</code>的函数。那么接下来：</p>

<pre><code class="language-lisp">(Y fac 5)
</code></pre>

<p>就可以正确地返回我们想要的结果。证明如下：</p>

<pre><code class="language-plaintext">(Y fac 5) = ((fac (Y fac)) 5)                       ; 利用(Y f)=(f (Y f))
          = (if (5==0) (1) (5*((Y fac) (5-1))))     ; 将5代入x，(Y fac)代入f
          = 5*((Y fac) 4)                           ; 展开if
          = 5*(fac (Y fac) 4)                       ; 还是(Y f)=(f (Y f))
          = 5*(if (4==0) (1) (4*((Y fac) (4-1))))   ; 继续展开
          = 5*4*((Y fac) 3)
          = ...
          = 5*4*3*2*1*((Y fac) 0)
          = 5*4*3*2*1*(fac (Y fac) 0)
          = 5*4*3*2*1*(if (0==0) (1) (0*((Y fac) (0-1))))
          = 5*4*3*2*1*1
          = 5!
</code></pre>

<p>更一般地，对于一个函数$f$：</p>

<div class="kdmath">$$
f=\lambda x_1.\ \lambda x_2.\ \lambda x_3.\ \cdots\ \lambda x_n.\ [\text{BODY}]
$$</div>

<p>而$f$的函数体中使用了递归（即：调用了自己），那么我们可以将$f$改写为$f’$使得它能够在我们的λ代数中运行：</p>

<div class="kdmath">$$
f'=\lambda g.\ \lambda x_1.\ \lambda x_2.\ \cdots\ \lambda x_n.\ [\text{BODY}][f:=g]
$$</div>

<p>后面的$[\text{BODY}][f:=g]$表示将函数体里所有出现的$f$全部替换成$g$。如果你没有理解为什么要这样做，可以仔细思考一下上面阶乘的例子。</p>

<p>进行求值的时候，只需要：</p>

<div class="kdmath">$$
((Y\ f')\ x_1\ x_2\ x_3\ \cdots\ x_n)
$$</div>

<p>就相当于计算了递归函数$f$代入参数$x_1$到$x_n$的值。</p>

<h2 id="列表和懒惰求值">列表和懒惰求值</h2>

<h3 id="列表">列表</h3>

<p>你应该还记得上篇文章的思考题里出现了一个<code>pair</code>函数。它满足：</p>

<pre><code class="language-lisp">(first (pair a b)) = a
(second (pair a b)) = b
</code></pre>

<p>一个可行的构造利用了布尔值<code>T</code>和<code>F</code>的性质：</p>

<pre><code class="language-lisp">pair := λa. λb. λt. (t a b)              ; 其中t为一个布尔值
first := λp. (p T)
second := λp. (p F)
</code></pre>

<p>在<code>pair</code>的基础上，你还可以构造出另一个数据结构：列表<code>list</code>。</p>

<pre><code class="language-lisp">(list3 a b c) := λNIL. (pair a (pair b (pair c NIL)))
(list4 a b c d) := λNIL. (pair a (pair b (pair c (pair d NIL))))
(list5 a b c d e) := λNIL. (pair a (pair b (pair c (paid d (pair e NIL)))))
</code></pre>

<p>其中<code>NIL</code>是一个占位符，用来标志列表结尾。</p>

<p>一个特殊的列表是空列表：<code>list0</code></p>

<pre><code class="language-lisp">list0 := λNIL. NIL
</code></pre>

<p>有了这些定义之后，我们就可以用递归的语法来定义列表的一些操作。比如：</p>

<h4 id="列表判空">列表判空</h4>

<p>要求：只有当传入的列表是空列表时，返回<code>T</code>，否则返回<code>F</code></p>

<pre><code class="language-lisp">null := λl. (l F (λx. λy. λz. F) T)
</code></pre>

<p>首先我们发现，除了空列表以外，其他列表都是<code>λNIL. (pair _ _)</code>的形式。将<code>pair</code>函数展开得到：<code>λNIL. λb. (b _ _)</code>。如果将函数<code>null</code>作用于这个非空列表，就会得到：</p>

<pre><code class="language-lisp">(null l) = ((λl. (l F (λx. λy. λz. F) T)) (λNIL. λb. (b _ _)))
         = ((λNIL. λb. (b _ _)) F (λx. λy. λz. F) T)
         = ((λx. λy. λz. F) _ _ T)                       ; 函数接收3个参数并返回常值F
         = F
</code></pre>

<p>而空列表则会返回：</p>

<pre><code class="language-lisp">(null list0) = ((λl. (l F (λx. λy. λz. F) T) (λNIL. NIL))
             = ((λNIL. NIL) F (λx. λy. λz. F) T)
             = (F (λx. λy. λz. F) T)
             = ((λa. λb. b) (λx. λy. λz. T) T)
             = T
</code></pre>

<h4 id="列表的第一个元素">列表的第一个元素</h4>

<pre><code class="language-lisp">car := (first (l _))
</code></pre>
<p><code>car</code>返回了列表的第一个元素，前提是列表<code>l</code>非空。</p>

<p>类似地，可以写出<code>cdr</code>，返回列表除了第一个元素以外的其他元素构成的列表：</p>

<pre><code class="language-lisp">cdr := λNIL. (second (l NIL))
</code></pre>

<p><code>car</code>和<code>cdr</code>这两个函数名可能看起来很奇怪，但这两个函数名来源于最古老的函数式编程语言：Lisp。<del>这也是Lisp的函数命名经常被吐槽的原因之一</del></p>

<h4 id="列表长度">列表长度</h4>

<p>有了<code>null</code>函数，很多列表的操作都能用递归实现了。比如列表的长度计算：</p>

<pre><code class="language-lisp">length := λl. (if (null l)
                    (0)
                    ((length (cdr l))+1))
</code></pre>

<p>注意到<code>(second l)</code>返回列表<code>l</code>从第二项到末尾的子列表，它的长度一定是原列表的长度减去1。</p>

<p>我们可以用前文所说的方法将函数转化为一个非递归函数，并用Y组合子求值。</p>

<h4 id="列表第n项">列表第<code>n</code>项</h4>

<p>假设下标从0开始。</p>

<pre><code class="language-lisp">nth := λl. λn. (if (null l)
                     (error "Index out of bound!")      ; 如果是空列表，报错
                     (if (n==0)
                          (car l)
                          (nth (cdr l) (n-1))))
</code></pre>

<p>这里利用<code>(nth l n) = (nth (cdr l) (n-1))</code>递归查找第<code>n</code>项。</p>

<h4 id="添加元素">添加元素</h4>

<pre><code class="language-lisp">append := λl. λa. λNIL. (l (pair a NIL))
</code></pre>

<p>在列表末尾追加元素<code>a</code>，相当于把列表的<code>NIL</code>替换成<code>(pair a NIL)</code>。</p>

<pre><code class="language-lisp">prepend := λl. λa. λNIL. (pair a (l NIL))
</code></pre>

<p>在列表前面添加元素<code>a</code>，相当于在原来的<code>l</code>外面套一层函数<code>(pair a)</code>。</p>

<h4 id="筛选元素">筛选元素</h4>

<p>函数<code>(filter c l)</code>返回列表<code>l</code>中所有满足条件<code>c</code>的元素构成的新列表。</p>

<pre><code class="language-lisp">filter = λc. λl.
         (if (null l)
               (list0)                                    ; 如果l是空列表，返回一个空列表
               (if (c (car l))
                     (prepend (filter (cdr l) c) (car l))
                     (filter (cdr l) c)))
</code></pre>

<p><del>如果你试着手打一下这一层套一层的括号，就能理解Lisp的痛了</del></p>

<p>例如我们有一个列表<code>l = [1, 2, 3, 4] = λNIL. (pair 1 (pair 2 (pair 3 (pair 4 NIL))))</code>，那么：</p>

<pre><code class="language-lisp">(filter (λx. x&gt;2) l)
</code></pre>

<p>就会返回列表：<code>[3, 4]</code>。而：</p>

<pre><code class="language-lisp">(filter (λx. x%2==0) l)
</code></pre>

<p>就会返回列表：<code>[2, 4]</code></p>

<h3 id="无限长列表">无限长列表</h3>

<p>既然我们定义了有限长的列表，那么是否可以定义无限长的列表？</p>

<p>不妨看一下这个递归函数：</p>

<pre><code class="language-plaintext">r := λNIL. (pair 1 (r NIL))
</code></pre>

<p>它展开后会得到一个无限重复<code>1</code>的列表：</p>

<pre><code class="language-plaintext">λNIL. (pair 1 (pair 1 (pair 1 (pair 1 (......)))))
</code></pre>

<p>稍稍更改一下，还可以得到由所有自然数构成的列表：</p>

<pre><code class="language-plaintext">s := λn. λNIL. (pair n (s n+1 NIL))
(s 0) = λNIL. (pair 0 (pair 1 (pair 2 (pair 3 (......)))))
</code></pre>

<p>接下来我们探讨一下类似这样的列表的性质：</p>

<h4 id="判空">判空</h4>

<p>以上文中的<code>r=(1, 1, 1, 1, ...)</code>为例。把递归转化成Y组合子的形式，就可以得到：</p>

<pre><code class="language-lisp">r' = λf. λNIL. (pair 1 (f NIL))
(null r) = (null (Y r'))
         = ((Y r') F (λx. λy. λz. F) T)
         = ((λNIL. pair 1 (Y r' NIL)) F (λx. λy. λz. F) T)
         = ((λx. λy. λz. F) 1 (Y r' _) T)
         = F
</code></pre>

<p>这个结果也在意料之内，因为无限长的列表肯定不是空的。类似的，你也可以证明列表<code>s</code>非空。</p>

<h4 id="第n个元素">第<code>n</code>个元素</h4>

<p>先看看<code>r=[1, 1, 1, 1, ...]</code>：</p>

<pre><code class="language-lisp">r' = λf. λNIL. (pair 1 (f NIL))
(nth r n) = (nth (Y r') n)
          = (if (null (Y r'))
                  (_)
                  (if (n==0)
                        (car (Y r'))
                        (nth (cdr (Y r')) (n-1))))
          = (if (n==0)                                 ; 根据前文的结论，(null r) = F，跳过第一个分支
                  (car (Y r'))
                  (nth (cdr (Y r')) (n-1)))
</code></pre>

<blockquote>
  <p>引理：</p>

  <pre><code class="language-lisp">(car (Y r')) = (car (r' (Y r')))
             = (car (λNIL. pair 1 (Y r' NIL)))
             = 1
</code></pre>

  <pre><code class="language-lisp">(cdr (Y r')) = (cdr (r' (Y r')))
             = (cdr (λNIl. pair 1 (Y r' NIL)))
             = λNIL. (Y r' NIL)
             = (Y r')
</code></pre>
  <p>换句话说，列表<code>(Y r')</code>的第一个元素永远是<code>1</code>，而它从第二个元素开始的子列表就是自己</p>
</blockquote>

<p>回到上面的证明：</p>

<pre><code class="language-lisp">(nth r n) = (if (n==0)
                  (1)
                  (nth r n-1))
</code></pre>

<p>由于<code>n</code>是自然数，函数重复足够多轮数之后，一定会让<code>n</code>减少到<code>0</code>，此时函数返回<code>1</code>。也就是：</p>

<pre><code class="language-lisp">(nth r n) = 1
</code></pre>

<p>接着我们再说<code>s</code>。使用类似的方法可以得到：</p>

<pre><code class="language-lisp">s' = λf. λn. λNIL. (pair n (f n+1 NIL))
(car (s n)) = (car (Y s' n)) = n
(cdr (s n)) = (cdr (Y s' n)) = (s n+1)
</code></pre>

<p>根据这两个结论，可以推出来：</p>

<pre><code class="language-lisp">(nth (s n) m) = (if (m==0)
                      (car (s n))
                      (nth (cdr (s n)) m-1))
              = (if (m==0)
                      (n)
                      (nth (s n+1) m-1))
</code></pre>

<p>根据数学归纳法，不难知道：<code>(nth (s n) m)</code>的返回值为<code>n+m</code>。特别地，<code>(nth (s 0) m)</code>就是<code>m</code>。</p>

<h3 id="懒惰求值">懒惰求值</h3>

<p>当然，无限长列表的应用远不止这些。比如，斐波那契数列：</p>

<pre><code class="language-lisp">fib = λa. λb. λNIL. (pair a (fib b a+b NIL))
(fib 1 1)       ; [1, 1, 2, 3, 5, 8, 13, ...]
</code></pre>

<p>甚至我们可以使用埃氏筛算法，写出一个装满所有质数的列表：</p>

<pre><code class="language-lisp">sieve := λl. (prepend
               (sieve (filter (λx. x%(car l)!=0) (cdr l)))  ; 去掉(cdr l)中所有(car l)的倍数
               (car l))

(sieve (s 2))           ; [2, 3, 5, 7, 11, 13, 17, ...]
</code></pre>

<p>如果你使用过haskell或者其他支持数组懒惰求值的编程语言，应该或多或少了解过这种写法。它允许你使用有限的语言来描述一个无限长的数列！</p>

<p><em>当然，懒惰求值只能表示出<strong>可计算</strong>的无限序列，例如上面说的斐波那契数列和质数数列，或者π的第n位等。这是因为，λ演算的计算能力和图灵机是等价的，任何不能用图灵机算出的数值同样也不能用λ演算算出来。</em></p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="lambda-calculus" /><category term="computation" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">用λ演算建立数学</title><link href="mqcreaple.github.io/blog/2022/08/27/lambda.html" rel="alternate" type="text/html" title="用λ演算建立数学" /><published>2022-08-27T00:00:00-04:00</published><updated>2022-08-27T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/08/27/lambda</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/08/27/lambda.html"><![CDATA[<link rel="stylesheet" href="/app/lambda-playground/lambda-playground.css" />

<script src="/app/lambda-playground/lambda-playground.js" onload="autoRender()"></script>

<p>在古早之前（大约我初一的时候），我写过一篇博客<del>遗憾的是现在它已经找不到了</del>，讲述了如何用纯集合论的方法构建自然数。学过数学分析的小朋友们相信对这个知识点已经不陌生了。</p>

<p>不过，集合论并不是唯一一种可以用来构建自然数的方法。今天，我就要介绍另一个可行的方法：<strong>λ演算</strong>。</p>

<p>当然在这之前，我先简单介绍一下λ演算：</p>

<h2 id="什么是λ演算">什么是λ演算？</h2>

<p>相信大家对函数已经不陌生了。比如下面这个函数：</p>

<div class="kdmath">$$
f(x)=2x
$$</div>

<p>它输入一个变量$x$，输出一个数，并且满足输出的数一定是输入的两倍。</p>

<p>接下来我们介绍一种新的记号，用来表示同一个函数：</p>

<div class="kdmath">$$
f=\lambda x.\ 2x
$$</div>

<p>这个表达式分为两段，第一段以λ开头，表示一个参数，第二段则是函数体。我们称这样的表达式为：<strong>λ表达式</strong>。</p>

<p>同时，我们也简单修改一下调用函数的记号：把括号写在函数前面，而不是后面</p>

<div class="kdmath">$$
\begin{align*}
(f\ 2) &= ((\lambda x.\ 2x)\ 2) \\
&= 2\cdot 2 \\
&= 4
\end{align*}
$$</div>

<p>我知道这对初学者来说看起来很别扭，但只要熟悉就好了。</p>

<p>λ表达式的求值很简单。只需要找到和传入的参数相对应的λ项，然后将函数体的所有对应项全都替换成传入的参数即可。</p>

<h3 id="多元函数">多元函数</h3>

<p>你可能会问，如果函数接受多个参数，该怎么办？比如下面这个函数：</p>

<div class="kdmath">$$
f(x, y)=x+2y
$$</div>

<p>答案很简单，只需要这样写：</p>

<div class="kdmath">$$
f=\lambda x.\ \lambda y.\ x+2y
$$</div>

<p>表达式前面有两个$\lambda$，就表示函数接受两个参数。比如：</p>

<div class="kdmath">$$
\begin{align*}
(f\ 2\ 3) &= ((\lambda x.\ \lambda y.\ x+2y)\ 2\ 3) \\
&= 2+2\cdot 3 \\
&= 8
\end{align*}
$$</div>

<p>同时，这个表达式还有一种解读方法。我们将$f$看作一个关于$x$的单值函数，但函数返回了另一个λ表达式：</p>

<div class="kdmath">$$
f=\lambda x.\ (\lambda y.\ x+2y)
$$</div>

<div class="kdmath">$$
\begin{align*}
(f\ 2) &= ((\lambda x.\ (\lambda y.\ x+2y))\ 2) \\
&= \lambda y.\ 2+2y
\end{align*}
$$</div>

<p>此时它的返回值还需要再接受一个参数，才能得到一个确定的值。</p>

<p>换句话说，我们把一个二元函数，变成了一个“返回一个一元函数”的一元函数。我们称这个步骤为函数的<strong>柯里化（Currying）</strong>。它同样适用于更多元的函数。</p>

<div class="kdmath">$$
f:U\times V\to W\quad\simeq\quad g:U\to(V\to W)
$$</div>

<blockquote>
  <p>柯里化是λ演算和函数式编程的一大难点，同时也是一大精妙之处</p>
</blockquote>

<p>进一步推广，我们还可以把常数看作是一个接受0个参数的函数，只不过没什么必要去这样做罢了。</p>

<p>当然了，常见的加减乘除之类的运算都是二元函数，因此其实在标准的λ语法中，四则运算应该这样写：</p>

<div class="kdmath">$$
a+b \Rightarrow (+\ a\ b)
$$</div>

<div class="kdmath">$$
a-b \Rightarrow (-\ a\ b)
$$</div>

<div class="kdmath">$$
a\cdot b \Rightarrow (*\ a\ b)
$$</div>

<div class="kdmath">$$
a/b \Rightarrow (/\ a\ b)
$$</div>

<p>如果你学过波兰表达式(Polish Notation)，你应该对这样的写法不陌生：<strong>这其实就是加上括号的波兰表达式！</strong></p>

<p>当然，除了四则运算，其他的二元运算都有类似的规则，例如判断运算（$\gt, \lt, =, \ne, \ge, \le$），逻辑运算（<code>AND</code>, <code>OR</code>, <code>NOT</code>）等。</p>

<blockquote>
  <p>思考题：结合上述知识，你能说说这些表达式是什么含义吗？</p>

  <div class="kdmath">$$
(*\ 3)
$$</div>

  <div class="kdmath">$$
(=\ 2)
$$</div>
</blockquote>

<h2 id="函数的函数">“函数”的函数</h2>

<p>我们发现，λ表达式并没有对参数的类型做限定。也就是说，<em>向λ表达式里传入一个函数也是完全合法的！</em></p>

<p>我们看一个例子：</p>

<div class="kdmath">$$
R=\lambda f.\ \lambda x.\ (f\ (f\ x))
$$</div>

<p>这个表达式$R$的意义就是：传入一个函数和一个值，把这个函数在值上做两遍。</p>

<p>举个例子：</p>

<div class="kdmath">$$
\begin{align*}
(R\ (\lambda x.\ x^2)\ 2) &= ((\lambda f.\ \lambda x.\ (f\ (f\ x)))\ (\lambda x.\ x^2))\ 2) \\
&= ((\lambda x.\ x^2)\ ((\lambda x.\ x^2)\ 2)) \\
&= ((\lambda x.\ x^2)\ 4) \\
&= 16
\end{align*}
$$</div>

<p>下面是一个简单的演示。点击图中的$R$将其展开，拖动函数参数到对应的λ位置来进行参数替换。</p>

<p class="lambda-r" data-repl-table="{ &quot;R&quot;: [ &quot;λf&quot;, &quot;λx&quot;, [ &quot;f&quot;, [ &quot;f&quot;, &quot;x&quot; ] ] ] }">[ "R", [ "λx", [ "^", "x", "2" ] ], "2" ]</p>

<p>当然，使用前面<em>柯里化</em>的思想，我们也可以这样看：$R$输入一个λ表达式，输出一个λ表达式，其中输出的表达式是输入的表达式重复两遍的结果。</p>

<div class="kdmath">$$
(R\ f)=\lambda x.\ (f\ (f\ x))
$$</div>

<p>同时这也告诉我们一个道理：在λ语言中，很多情况下括号是不能省略的。比如</p>

<div class="kdmath">$$
(f\ (g\ x))
$$</div>

<p>就是变量$x$先被$g$作用再被$f$作用，而</p>

<div class="kdmath">$$
(f\ g\ x)
$$</div>

<p>则是函数$g$和变量$x$同时传入$f$中。</p>

<h2 id="逻辑运算">逻辑运算</h2>

<p>相信从上面的介绍中，你已经初步掌握了λ演算。接下来我们将要玩一个小游戏：只用λ演算，不用任何额外的工具（包括逻辑运算，数值运算等一切你熟悉到不能再熟悉的东西），看看你能搭建出什么东西。</p>

<p>没有逻辑运算，就意味着我们没有定义“真”、“假”等概念。那么，我们能不能从λ演算中把这些东西定义出来呢？</p>

<p>首先我们想到，“真”和“假”是一组对立的概念，就像是硬币的两面。从这里出发，我们先写出这样的定义：</p>

<div class="kdmath">$$
T:=\lambda x.\ \lambda y.\ x
$$</div>

<div class="kdmath">$$
F:=\lambda x.\ \lambda y.\ y
$$</div>

<p>在这样的定义下，“真”就是给定两个东西取出第一个，而“假”则是给定两个东西取出第二个。注意到这两个定义中我们没有用到任何运算。</p>

<h3 id="逻辑非">逻辑非</h3>

<p>有了这两个定义，那么逻辑非（Not）就很好定义了。它的定义如下：</p>

<div class="kdmath">$$
(\lnot) := \lambda a.\ (a\ F\ T)
$$</div>

<p>不要忘记了$T$和$F$的含义：$T$表示选择第一个东西，而$F$表示选择第二个东西。也就是说，如果$a=T$，它就会选择第一个参数，也就是$F$；反之，如果$a=F$，它就会选第二个参数，就是$T$。</p>

<p>如果你没有理解这个定义，不妨看下面的演示。请你按照以下顺序操作：</p>

<ol>
  <li>点击<code>NOT</code>将其展开</li>
  <li>将后面的<code>T</code>或<code>F</code>拖动到对应位置</li>
  <li>将首位的<code>T</code>或<code>F</code>展开</li>
  <li>将后面的两个参数拖动到对应位置</li>
</ol>

<p class="lambda-r">[ "NOT", "T" ]</p>

<p class="lambda-r">[ "NOT", "F" ]</p>

<h3 id="逻辑与和逻辑或">逻辑与和逻辑或</h3>

<p>逻辑与的定义则相对复杂，因为它需要接受两个参数。</p>

<p>不难发现，计算$a\land b$时，假如$a$为真，则运算结果就等于$b$，反之如果$a$为假，则运算结果一定是假。</p>

<p>因此我们给出了逻辑与的λ定义：</p>

<div class="kdmath">$$
(\land):=\lambda a.\ \lambda b.\ (a\ b\ F)
$$</div>

<p>类似地，如果$a=T$，那么就会选择第一个参数$b$，它的返回值就取决于$b$的值；而如果$a=F$，它就一定会返回$F$。</p>

<p>同样你也可以看这里的演示：</p>

<p class="lambda-r">[ "AND", "T", "T" ]</p>

<p class="lambda-r">[ "AND", "T", "F" ]</p>

<p class="lambda-r">[ "AND", "F", "T" ]</p>

<p class="lambda-r">[ "AND", "F", "F" ]</p>

<p>类比逻辑与的定义，我们也可以写出逻辑或的定义：</p>

<div class="kdmath">$$
(\lor):=\lambda a.\ \lambda b.\ (a\ T\ b)
$$</div>

<p>以及演示：</p>

<p class="lambda-r">[ "OR", "T", "T" ]</p>

<p class="lambda-r">[ "OR", "T", "F" ]</p>

<p class="lambda-r">[ "OR", "F", "T" ]</p>

<p class="lambda-r">[ "OR", "F", "F" ]</p>

<h3 id="组合逻辑">组合逻辑</h3>

<p>有了逻辑运算的三兄弟：与、或、非，其余的一切逻辑运算都可以被表示出来了。比如：</p>

<div class="kdmath">$$
\text{xor}:=\lambda a.\ \lambda b.\ (\lor\ (\land\ a\ (\lnot\ b))\ (\land\ b\ (\lnot\ a)))
$$</div>

<p>当然也可利用λ的性质，写出一个更简洁的异或运算：</p>

<div class="kdmath">$$
\text{xor}:=\lambda a.\ \lambda b.\ (a\ (\lnot\ b)\ b)
$$</div>

<h3 id="谓词和逻辑运算">谓词和逻辑运算</h3>

<p>我们定义，如果有一个λ表达式$p$的返回值要么是$T$，要么是$F$，则$p$称为一个<strong>谓词</strong>。</p>

<p>比如，判断两个自然数相等的运算：</p>

<div class="kdmath">$$
(=\ a\ b)
$$</div>

<p>就是一个谓词。</p>

<h2 id="自然数">自然数</h2>

<p>回想一下自然数的五条公理：</p>

<ol>
  <li>$0$是自然数</li>
  <li>每一个自然数$n$都有一个后继，记为$n^+$</li>
  <li>任何两个不同的元素，它们的后继也不同
    <ul>
      <li>或者说，$(n^+)$这个函数是$\N\to \N$的单射</li>
    </ul>
  </li>
  <li>除了$0$以外每一个自然数都有一个前驱</li>
  <li>假如命题$p$满足：$p(0)$为真，且任何$p(n)$为真可以推出$p(n+1)$为真，则任何$k\in\N$都有$p(k)$为真
    <ul>
      <li>或者说，数学归纳法在$\N$上成立</li>
    </ul>
  </li>
</ol>

<p>一个可行的构造是由λ演算的提出者Alonzo Church提出的方案，我们称其为<strong>Church计数</strong>。其自然数的构造如下：</p>

<div class="kdmath">$$
\begin{align*}
0 & :=\lambda f.\ \lambda x.\ x \\
1 & :=\lambda f.\ \lambda x.\ (f\ x) \\
2 & :=\lambda f.\ \lambda x.\ (f\ (f\ x)) \\
3 & :=\lambda f.\ \lambda x.\ (f\ (f\ (f\ x)))) \\
\vdots \\
n & :=\lambda f.\ \lambda x.\ (f^{\circ n}\ x) \\
\vdots
\end{align*}
$$</div>

<p>也就是说，第$n$个自然数，就是将一个函数重复$n$遍。</p>

<p>那么自然数的后继就可以这样定义：</p>

<div class="kdmath">$$
\text{succ}:=\lambda n.\ \lambda f.\ \lambda x.\ (f\ (n\ f\ x))
$$</div>

<p>注意：你可能会以为$\text{succ}$接受三个参数，但使用它时，只用一个参数$n$，返回一个带有两个参数$f,x$的λ表达式。</p>

<p>举个例子，我们想要计算$1$的后继：</p>

<div class="kdmath">$$
\begin{align*}
(\text{succ}\ 1) &= ((\lambda n.\ \lambda f.\ \lambda x.\ (f\ (n\ f\ x)))\ 1) \\
&= \lambda f.\ \lambda x.\ (f\ (1\ f\ x)) \\
&= \lambda f.\ \lambda x.\ (f\ (f\ x))
\end{align*}
$$</div>

<p>查一下表，不难发现这个λ表达式就是自然数$2$。</p>

<p class="lambda-r">[ "SUCC", "1" ]</p>

<h3 id="加法">加法</h3>

<p>将上面后继的定义稍稍更改一下，即可得到加法的定义：</p>

<div class="kdmath">$$
(+):=\lambda m.\ \lambda n.\ \lambda f.\ \lambda x.\ (m\ f\ (n\ f\ x))
$$</div>

<p>根据定义，$(n\ f\ x)$是函数$f$在$x$上重复数字$n$遍，而$(m\ f)$又是函数$f$重复数字$m$遍。两者复合之后就是函数$f$重复了$m+n$遍。</p>

<p>这里就不手打示例公式了，大家可以在下面操作一下。</p>

<p class="lambda-r">[ "+", "1", "2" ]</p>

<p>一个等价的表达式是这样的：</p>

<div class="kdmath">$$
(+):=\lambda m.\ \lambda n.\ (m\ \text{succ}\ n)
$$</div>

<p>相当于在数$n$上使用$m$次$\text{succ}$函数。</p>

<h3 id="乘法">乘法</h3>

<p>不难想到乘法可以这样定义：</p>

<div class="kdmath">$$
(\times):=\lambda m.\ \lambda n.\ (m\ (+\ n)\ 0)
$$</div>

<p>不要忘了，$(+\ n)$是一个λ表达式，输入一个数，输出它加上$n$的结果。这个表达式的含义就是：从$0$开始，重复$m$次操作，每次给数加上$n$。那么最后得到的就是数$m\times n$。</p>

<p>但是，它还有一个更简洁的形式：</p>

<div class="kdmath">$$
(\times):=\lambda m.\ \lambda n.\ \lambda f.\ (m\ (n\ f))
$$</div>

<p>其中$(n\ f)$返回一个λ表达式，表示将函数$f$重复$n$遍，而$(m\ (n\ f))$则是进一步把$(n\ f)$重复了$m$遍。那么$f$总共就被重复了$m\times n$遍。</p>

<p>可以看一下这个演示：</p>

<p class="lambda-r">[ "*", "2", "3" ]</p>

<p class="lambda-r">[ "*", "3", "2" ]</p>

<h3 id="前驱">前驱</h3>

<p>相对于前面的运算，“求前驱”是一个相对更难的操作，因为它需要从一个表达式上面“剥掉”一层函数调用。比如：</p>

<div class="kdmath">$$
3=\lambda f.\ \lambda x.\ (f\ (f\ (f\ x)))\xrightarrow{\text{pred}} 2=\lambda f.\ \lambda x.\ (f\ (f\ x))
$$</div>

<p>我们想到，假如能够构造出一个函数$R$，使得它第一次作用在某个值$x$上得到的是它本身，而第二、三、四、…次之后，每次往$x$上面套一层$f$。那么只需要：</p>

<div class="kdmath">$$
(n\ R\ x)
$$</div>

<p>就可以得到$(f^{\circ(n-1)}\ x)$了。</p>

<p>可惜，你想得美。这种函数不可能存在，因为$R$这个函数不是一个纯函数。</p>

<p>如果我们已知：</p>

<div class="kdmath">$$
(R\ x) = x
$$</div>

<p>那么将$R$在$x$上作用两遍的结果一定也是：</p>

<div class="kdmath">$$
\begin{align*}
(R\ (R\ x)) &= (R\ x) \\
&= x
\end{align*}
$$</div>

<p>但是，你也不要小瞧了λ演算的威力。我们虽然没法构造一个这样的函数，但可以构造一个功能类似的函数：</p>

<div class="kdmath">$$
T=\lambda g.\ \lambda h.\ (h\ (g\ f))
$$</div>

<p>使用这个函数时，需要向里面传入一个常值λ表达式：$(\lambda u.\ x)$</p>

<div class="kdmath">$$
\begin{align*}
(T\ (\lambda u.\ x)) &= \lambda h.\ (h\ ((\lambda u.\ x)\ f)) \\
&= \lambda h.\ (h\ x) \\
&= \lambda u.\ (u\ x)
\end{align*}
$$</div>

<p class="lambda-r" data-repl-table="{&quot;T&quot;:[&quot;λg&quot;,&quot;λh&quot;,[&quot;h&quot;,[&quot;g&quot;,&quot;f&quot;]]]}">["T", ["λu", "x"]]</p>

<p>如果再把$T$作用到刚刚算得的结果上，就是：</p>

<div class="kdmath">$$
\begin{align*}
(T\ (T\ (\lambda u.\ x))) &= (T\ (\lambda u.\ (u\ x))) \\
&= \lambda h.\ (h\ ((\lambda u.\ (u\ x))\ f)) \\
&= \lambda h.\ (h\ (f\ x)) \\
&= \lambda u.\ (u\ (f\ x))
\end{align*}
$$</div>

<p class="lambda-r" data-repl-table="{&quot;T&quot;:[&quot;λg&quot;,&quot;λh&quot;,[&quot;h&quot;,[&quot;g&quot;,&quot;f&quot;]]]}">["T", ["λu", ["u", "x"]]]</p>

<p>进一步的，如果作用三次$T$，就会得到：</p>

<div class="kdmath">$$
\lambda u.\ (u\ (f\ (f\ x)))
$$</div>

<p class="lambda-r" data-repl-table="{&quot;T&quot;:[&quot;λg&quot;,&quot;λh&quot;,[&quot;h&quot;,[&quot;g&quot;,&quot;f&quot;]]]}">["T", ["λu", ["u", ["f", "x"]]]]</p>

<p>通过归纳法不难得到，在$(\lambda u.\ x)$上作用$n$次$T$，得到的结果就是：</p>

<div class="kdmath">$$
\lambda u.\ (u\ (f^{\circ(n-1)}\ x))
$$</div>

<p>注意到我们在这个表达式里发现了一个$(f^{\circ(n-1)}\ x)$，这就是要求的值！最后一步就是消去函数$u$，一个简单的方法就是将$u$代入单位函数$\text{id}=\lambda v.\ v$即可。</p>

<div class="kdmath">$$
\begin{align*}
&(\lambda u.\ (u\ (f^{\circ(n-1)}\ x))\ (\lambda v.\ v)) \\
=& ((\lambda v.\ v)\ (f^{\circ(n-1)}\ x)) \\
=& (f^{\circ(n-1)}\ x)
\end{align*}
$$</div>

<p>综合上述结果，我们得到了前驱$\text{pred}$的λ表达式，若传入的$n\gt 0$，那么它返回$n-1$，否则返回$0$：</p>

<div class="kdmath">$$
\text{pred}:=\lambda n.\ \lambda f.\ \lambda x.\ ((n\ T\ (\lambda u.\ x))\ \text{id})
$$</div>

<p class="lambda-r">[ "PRED", "0" ]</p>

<p class="lambda-r">[ "PRED", "1" ]</p>

<p class="lambda-r">[ "PRED", "2" ]</p>

<h3 id="减法">减法</h3>

<p>有了前驱运算，减法就不难定义了：</p>

<div class="kdmath">$$
(-):=\lambda m.\ \lambda n.\ (n\ \text{pred}\ m)
$$</div>

<p>当然，由于自然数没有负数，假如被减数$m$小于$n$，减法运算的结果就是$0$。</p>

<h3 id="判断">判断</h3>

<p>我们可以定义一个函数来判断某个数是不是$0$：</p>

<div class="kdmath">$$
\text{iszero}:=\lambda n.\ (n\ (\lambda u.\ F)\ T)
$$</div>

<p>函数$(\lambda u.\ F)$是一个永远返回$F$的常值函数。所以，只要$n\gt0$，$(\text{iszero}\ n)$就会返回$F$。</p>

<p>再加上之前定义的减法，我们就可以定义“大于等于”函数：</p>

<div class="kdmath">$$
(\ge):=\lambda m.\ \lambda n.\ (\text{iszero}\ (-\ n\ m))
$$</div>

<p>再根据大于等于来定义自然数的相等：</p>

<div class="kdmath">$$
(=):=\lambda m.\ \lambda n.\ (\land\ (\ge\ m\ n)\ (\ge\ n\ m))
$$</div>

<h2 id="思考题">思考题</h2>

<p>你能使用λ演算来定义一个类似C++中<code>std::pair</code>的数据结构吗？</p>

<blockquote>
  <p>要求：使用函数</p>

  <div class="kdmath">$$
(\text{pair}\ a\ b)
$$</div>

  <p>来构造一个对象，并使用$(\text{first}\ p)$和$(\text{second}\ p)$来获取一个pair的第一和第二个值。</p>
</blockquote>

<p>你能在这个结构的基础上，用λ演算来定义所有的<strong>整数</strong>及其相应的数值和逻辑运算吗？</p>

<h2 id="参考资料">参考资料</h2>

<p>[1] “Lambda Calculus.” <em>Wikipedia</em>, <a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>. Accessed 26 Aug. 2022.</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="lambda-calculus" /><category term="computation" /><summary type="html"><![CDATA[在古早之前（大约我初一的时候），我写过一篇博客遗憾的是现在它已经找不到了，讲述了如何用纯集合论的方法构建自然数。学过数学分析的小朋友们相信对这个知识点已经不陌生了。 不过，集合论并不是唯一一种可以用来构建自然数的方法。今天，我就要介绍另一个可行的方法：λ演算。 当然在这之前，我先简单介绍一下λ演算： 什么是λ演算？ 相信大家对函数已经不陌生了。比如下面这个函数： $$ f(x)=2x $$ 它输入一个变量$x$，输出一个数，并且满足输出的数一定是输入的两倍。 接下来我们介绍一种新的记号，用来表示同一个函数： $$ f=\lambda x.\ 2x $$ 这个表达式分为两段，第一段以λ开头，表示一个参数，第二段则是函数体。我们称这样的表达式为：λ表达式。 同时，我们也简单修改一下调用函数的记号：把括号写在函数前面，而不是后面 $$ \begin{align*} (f\ 2) &= ((\lambda x.\ 2x)\ 2) \\ &= 2\cdot 2 \\ &= 4 \end{align*} $$ 我知道这对初学者来说看起来很别扭，但只要熟悉就好了。 λ表达式的求值很简单。只需要找到和传入的参数相对应的λ项，然后将函数体的所有对应项全都替换成传入的参数即可。 多元函数 你可能会问，如果函数接受多个参数，该怎么办？比如下面这个函数： $$ f(x, y)=x+2y $$ 答案很简单，只需要这样写： $$ f=\lambda x.\ \lambda y.\ x+2y $$ 表达式前面有两个$\lambda$，就表示函数接受两个参数。比如： $$ \begin{align*} (f\ 2\ 3) &= ((\lambda x.\ \lambda y.\ x+2y)\ 2\ 3) \\ &= 2+2\cdot 3 \\ &= 8 \end{align*} $$ 同时，这个表达式还有一种解读方法。我们将$f$看作一个关于$x$的单值函数，但函数返回了另一个λ表达式： $$ f=\lambda x.\ (\lambda y.\ x+2y) $$ $$ \begin{align*} (f\ 2) &= ((\lambda x.\ (\lambda y.\ x+2y))\ 2) \\ &= \lambda y.\ 2+2y \end{align*} $$ 此时它的返回值还需要再接受一个参数，才能得到一个确定的值。 换句话说，我们把一个二元函数，变成了一个“返回一个一元函数”的一元函数。我们称这个步骤为函数的柯里化（Currying）。它同样适用于更多元的函数。 $$ f:U\times V\to W\quad\simeq\quad g:U\to(V\to W) $$ 柯里化是λ演算和函数式编程的一大难点，同时也是一大精妙之处 进一步推广，我们还可以把常数看作是一个接受0个参数的函数，只不过没什么必要去这样做罢了。 当然了，常见的加减乘除之类的运算都是二元函数，因此其实在标准的λ语法中，四则运算应该这样写： $$ a+b \Rightarrow (+\ a\ b) $$ $$ a-b \Rightarrow (-\ a\ b) $$ $$ a\cdot b \Rightarrow (*\ a\ b) $$ $$ a/b \Rightarrow (/\ a\ b) $$ 如果你学过波兰表达式(Polish Notation)，你应该对这样的写法不陌生：这其实就是加上括号的波兰表达式！ 当然，除了四则运算，其他的二元运算都有类似的规则，例如判断运算（$\gt, \lt, =, \ne, \ge, \le$），逻辑运算（AND, OR, NOT）等。 思考题：结合上述知识，你能说说这些表达式是什么含义吗？ $$ (*\ 3) $$ $$ (=\ 2) $$ “函数”的函数 我们发现，λ表达式并没有对参数的类型做限定。也就是说，向λ表达式里传入一个函数也是完全合法的！ 我们看一个例子： $$ R=\lambda f.\ \lambda x.\ (f\ (f\ x)) $$ 这个表达式$R$的意义就是：传入一个函数和一个值，把这个函数在值上做两遍。 举个例子： $$ \begin{align*} (R\ (\lambda x.\ x^2)\ 2) &= ((\lambda f.\ \lambda x.\ (f\ (f\ x)))\ (\lambda x.\ x^2))\ 2) \\ &= ((\lambda x.\ x^2)\ ((\lambda x.\ x^2)\ 2)) \\ &= ((\lambda x.\ x^2)\ 4) \\ &= 16 \end{align*} $$ 下面是一个简单的演示。点击图中的$R$将其展开，拖动函数参数到对应的λ位置来进行参数替换。 [ "R", [ "λx", [ "^", "x", "2" ] ], "2" ] 当然，使用前面柯里化的思想，我们也可以这样看：$R$输入一个λ表达式，输出一个λ表达式，其中输出的表达式是输入的表达式重复两遍的结果。 $$ (R\ f)=\lambda x.\ (f\ (f\ x)) $$ 同时这也告诉我们一个道理：在λ语言中，很多情况下括号是不能省略的。比如 $$ (f\ (g\ x)) $$ 就是变量$x$先被$g$作用再被$f$作用，而 $$ (f\ g\ x) $$ 则是函数$g$和变量$x$同时传入$f$中。 逻辑运算 相信从上面的介绍中，你已经初步掌握了λ演算。接下来我们将要玩一个小游戏：只用λ演算，不用任何额外的工具（包括逻辑运算，数值运算等一切你熟悉到不能再熟悉的东西），看看你能搭建出什么东西。 没有逻辑运算，就意味着我们没有定义“真”、“假”等概念。那么，我们能不能从λ演算中把这些东西定义出来呢？ 首先我们想到，“真”和“假”是一组对立的概念，就像是硬币的两面。从这里出发，我们先写出这样的定义： $$ T:=\lambda x.\ \lambda y.\ x $$ $$ F:=\lambda x.\ \lambda y.\ y $$ 在这样的定义下，“真”就是给定两个东西取出第一个，而“假”则是给定两个东西取出第二个。注意到这两个定义中我们没有用到任何运算。 逻辑非 有了这两个定义，那么逻辑非（Not）就很好定义了。它的定义如下： $$ (\lnot) := \lambda a.\ (a\ F\ T) $$ 不要忘记了$T$和$F$的含义：$T$表示选择第一个东西，而$F$表示选择第二个东西。也就是说，如果$a=T$，它就会选择第一个参数，也就是$F$；反之，如果$a=F$，它就会选第二个参数，就是$T$。 如果你没有理解这个定义，不妨看下面的演示。请你按照以下顺序操作： 点击NOT将其展开 将后面的T或F拖动到对应位置 将首位的T或F展开 将后面的两个参数拖动到对应位置 [ "NOT", "T" ] [ "NOT", "F" ] 逻辑与和逻辑或 逻辑与的定义则相对复杂，因为它需要接受两个参数。 不难发现，计算$a\land b$时，假如$a$为真，则运算结果就等于$b$，反之如果$a$为假，则运算结果一定是假。 因此我们给出了逻辑与的λ定义： $$ (\land):=\lambda a.\ \lambda b.\ (a\ b\ F) $$ 类似地，如果$a=T$，那么就会选择第一个参数$b$，它的返回值就取决于$b$的值；而如果$a=F$，它就一定会返回$F$。 同样你也可以看这里的演示： [ "AND", "T", "T" ] [ "AND", "T", "F" ] [ "AND", "F", "T" ] [ "AND", "F", "F" ] 类比逻辑与的定义，我们也可以写出逻辑或的定义： $$ (\lor):=\lambda a.\ \lambda b.\ (a\ T\ b) $$ 以及演示： [ "OR", "T", "T" ] [ "OR", "T", "F" ] [ "OR", "F", "T" ] [ "OR", "F", "F" ] 组合逻辑 有了逻辑运算的三兄弟：与、或、非，其余的一切逻辑运算都可以被表示出来了。比如： $$ \text{xor}:=\lambda a.\ \lambda b.\ (\lor\ (\land\ a\ (\lnot\ b))\ (\land\ b\ (\lnot\ a))) $$ 当然也可利用λ的性质，写出一个更简洁的异或运算： $$ \text{xor}:=\lambda a.\ \lambda b.\ (a\ (\lnot\ b)\ b) $$ 谓词和逻辑运算 我们定义，如果有一个λ表达式$p$的返回值要么是$T$，要么是$F$，则$p$称为一个谓词。 比如，判断两个自然数相等的运算： $$ (=\ a\ b) $$ 就是一个谓词。 自然数 回想一下自然数的五条公理： $0$是自然数 每一个自然数$n$都有一个后继，记为$n^+$ 任何两个不同的元素，它们的后继也不同 或者说，$(n^+)$这个函数是$\N\to \N$的单射 除了$0$以外每一个自然数都有一个前驱 假如命题$p$满足：$p(0)$为真，且任何$p(n)$为真可以推出$p(n+1)$为真，则任何$k\in\N$都有$p(k)$为真 或者说，数学归纳法在$\N$上成立 一个可行的构造是由λ演算的提出者Alonzo Church提出的方案，我们称其为Church计数。其自然数的构造如下： $$ \begin{align*} 0 & :=\lambda f.\ \lambda x.\ x \\ 1 & :=\lambda f.\ \lambda x.\ (f\ x) \\ 2 & :=\lambda f.\ \lambda x.\ (f\ (f\ x)) \\ 3 & :=\lambda f.\ \lambda x.\ (f\ (f\ (f\ x)))) \\ \vdots \\ n & :=\lambda f.\ \lambda x.\ (f^{\circ n}\ x) \\ \vdots \end{align*} $$ 也就是说，第$n$个自然数，就是将一个函数重复$n$遍。 那么自然数的后继就可以这样定义： $$ \text{succ}:=\lambda n.\ \lambda f.\ \lambda x.\ (f\ (n\ f\ x)) $$ 注意：你可能会以为$\text{succ}$接受三个参数，但使用它时，只用一个参数$n$，返回一个带有两个参数$f,x$的λ表达式。 举个例子，我们想要计算$1$的后继： $$ \begin{align*} (\text{succ}\ 1) &= ((\lambda n.\ \lambda f.\ \lambda x.\ (f\ (n\ f\ x)))\ 1) \\ &= \lambda f.\ \lambda x.\ (f\ (1\ f\ x)) \\ &= \lambda f.\ \lambda x.\ (f\ (f\ x)) \end{align*} $$ 查一下表，不难发现这个λ表达式就是自然数$2$。 [ "SUCC", "1" ] 加法 将上面后继的定义稍稍更改一下，即可得到加法的定义： $$ (+):=\lambda m.\ \lambda n.\ \lambda f.\ \lambda x.\ (m\ f\ (n\ f\ x)) $$ 根据定义，$(n\ f\ x)$是函数$f$在$x$上重复数字$n$遍，而$(m\ f)$又是函数$f$重复数字$m$遍。两者复合之后就是函数$f$重复了$m+n$遍。 这里就不手打示例公式了，大家可以在下面操作一下。 [ "+", "1", "2" ] 一个等价的表达式是这样的： $$ (+):=\lambda m.\ \lambda n.\ (m\ \text{succ}\ n) $$ 相当于在数$n$上使用$m$次$\text{succ}$函数。 乘法 不难想到乘法可以这样定义： $$ (\times):=\lambda m.\ \lambda n.\ (m\ (+\ n)\ 0) $$ 不要忘了，$(+\ n)$是一个λ表达式，输入一个数，输出它加上$n$的结果。这个表达式的含义就是：从$0$开始，重复$m$次操作，每次给数加上$n$。那么最后得到的就是数$m\times n$。 但是，它还有一个更简洁的形式： $$ (\times):=\lambda m.\ \lambda n.\ \lambda f.\ (m\ (n\ f)) $$ 其中$(n\ f)$返回一个λ表达式，表示将函数$f$重复$n$遍，而$(m\ (n\ f))$则是进一步把$(n\ f)$重复了$m$遍。那么$f$总共就被重复了$m\times n$遍。 可以看一下这个演示： [ "*", "2", "3" ] [ "*", "3", "2" ] 前驱 相对于前面的运算，“求前驱”是一个相对更难的操作，因为它需要从一个表达式上面“剥掉”一层函数调用。比如： $$ 3=\lambda f.\ \lambda x.\ (f\ (f\ (f\ x)))\xrightarrow{\text{pred}} 2=\lambda f.\ \lambda x.\ (f\ (f\ x)) $$ 我们想到，假如能够构造出一个函数$R$，使得它第一次作用在某个值$x$上得到的是它本身，而第二、三、四、…次之后，每次往$x$上面套一层$f$。那么只需要： $$ (n\ R\ x) $$ 就可以得到$(f^{\circ(n-1)}\ x)$了。 可惜，你想得美。这种函数不可能存在，因为$R$这个函数不是一个纯函数。 如果我们已知： $$ (R\ x) = x $$ 那么将$R$在$x$上作用两遍的结果一定也是： $$ \begin{align*} (R\ (R\ x)) &= (R\ x) \\ &= x \end{align*} $$ 但是，你也不要小瞧了λ演算的威力。我们虽然没法构造一个这样的函数，但可以构造一个功能类似的函数： $$ T=\lambda g.\ \lambda h.\ (h\ (g\ f)) $$ 使用这个函数时，需要向里面传入一个常值λ表达式：$(\lambda u.\ x)$ $$ \begin{align*} (T\ (\lambda u.\ x)) &= \lambda h.\ (h\ ((\lambda u.\ x)\ f)) \\ &= \lambda h.\ (h\ x) \\ &= \lambda u.\ (u\ x) \end{align*} $$ ["T", ["λu", "x"]] 如果再把$T$作用到刚刚算得的结果上，就是： $$ \begin{align*} (T\ (T\ (\lambda u.\ x))) &= (T\ (\lambda u.\ (u\ x))) \\ &= \lambda h.\ (h\ ((\lambda u.\ (u\ x))\ f)) \\ &= \lambda h.\ (h\ (f\ x)) \\ &= \lambda u.\ (u\ (f\ x)) \end{align*} $$ ["T", ["λu", ["u", "x"]]] 进一步的，如果作用三次$T$，就会得到： $$ \lambda u.\ (u\ (f\ (f\ x))) $$ ["T", ["λu", ["u", ["f", "x"]]]] 通过归纳法不难得到，在$(\lambda u.\ x)$上作用$n$次$T$，得到的结果就是： $$ \lambda u.\ (u\ (f^{\circ(n-1)}\ x)) $$ 注意到我们在这个表达式里发现了一个$(f^{\circ(n-1)}\ x)$，这就是要求的值！最后一步就是消去函数$u$，一个简单的方法就是将$u$代入单位函数$\text{id}=\lambda v.\ v$即可。 $$ \begin{align*} &(\lambda u.\ (u\ (f^{\circ(n-1)}\ x))\ (\lambda v.\ v)) \\ =& ((\lambda v.\ v)\ (f^{\circ(n-1)}\ x)) \\ =& (f^{\circ(n-1)}\ x) \end{align*} $$ 综合上述结果，我们得到了前驱$\text{pred}$的λ表达式，若传入的$n\gt 0$，那么它返回$n-1$，否则返回$0$： $$ \text{pred}:=\lambda n.\ \lambda f.\ \lambda x.\ ((n\ T\ (\lambda u.\ x))\ \text{id}) $$ [ "PRED", "0" ] [ "PRED", "1" ] [ "PRED", "2" ] 减法 有了前驱运算，减法就不难定义了： $$ (-):=\lambda m.\ \lambda n.\ (n\ \text{pred}\ m) $$ 当然，由于自然数没有负数，假如被减数$m$小于$n$，减法运算的结果就是$0$。 判断 我们可以定义一个函数来判断某个数是不是$0$： $$ \text{iszero}:=\lambda n.\ (n\ (\lambda u.\ F)\ T) $$ 函数$(\lambda u.\ F)$是一个永远返回$F$的常值函数。所以，只要$n\gt0$，$(\text{iszero}\ n)$就会返回$F$。 再加上之前定义的减法，我们就可以定义“大于等于”函数： $$ (\ge):=\lambda m.\ \lambda n.\ (\text{iszero}\ (-\ n\ m)) $$ 再根据大于等于来定义自然数的相等： $$ (=):=\lambda m.\ \lambda n.\ (\land\ (\ge\ m\ n)\ (\ge\ n\ m)) $$ 思考题 你能使用λ演算来定义一个类似C++中std::pair的数据结构吗？ 要求：使用函数 $$ (\text{pair}\ a\ b) $$ 来构造一个对象，并使用$(\text{first}\ p)$和$(\text{second}\ p)$来获取一个pair的第一和第二个值。 你能在这个结构的基础上，用λ演算来定义所有的整数及其相应的数值和逻辑运算吗？ 参考资料 [1] “Lambda Calculus.” Wikipedia, https://en.wikipedia.org/wiki/Lambda_calculus. Accessed 26 Aug. 2022.]]></summary></entry><entry><title type="html">埃氏筛的复杂度计算</title><link href="mqcreaple.github.io/blog/2022/08/18/eto.html" rel="alternate" type="text/html" title="埃氏筛的复杂度计算" /><published>2022-08-18T00:00:00-04:00</published><updated>2022-08-18T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2022/08/18/eto</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/08/18/eto.html"><![CDATA[<p><strong>埃拉托斯特尼筛法（Sieve of Erastosthenis）</strong>，简称<strong>埃氏筛</strong>，是一种可以在极少时间复杂度内算出$n$以内的所有质数的算法。</p>

<h2 id="0-算法流程">#0 算法流程</h2>

<p>对于一个给定的整数$n$，从2开始执行以下操作：</p>

<ol>
  <li>将该数标记为质数</li>
  <li>将所有该数的倍数标记为“非质数”</li>
  <li>找到下一个不被标记为“非质数”的数，重复步骤1</li>
</ol>

<p>算法的逻辑很简单，代码也极其简短。以C语言为例：</p>

<pre><code class="language-c">int sieve(int n, int *ans) {
    int found = 0;         // 已经找到多少个质数
    bool p[n];             // 标记。0为质数，1为非质数
    
    memset(p, 0, n);       // 清空标记数组
    for(int i = 2; i &lt; n; i++) {
        if(p[i]) {
            // i已经被标记为非质数，跳过
            continue;
        }
        ans[found++] = i;  // i为质数，添加至答案数组中
        for(int j = 2; i * j &lt; n; j++) {
            p[i * j] = 1;      // 将所有i的倍数标记为“非质数”
        }
    }
    
    return found;
}
</code></pre>

<h2 id="1-初步分析">#1 初步分析</h2>

<p>那么这个算法的时间复杂度如何计算呢？</p>

<p>我们不妨追踪一下算法的执行过程：</p>

<ul>
  <li>首先从$2$开始，算法遍历了所有$1$到$n$中$2$的倍数，也就是进行了$\frac{n}{2}$步操作</li>
  <li>接下来找到下一个质数：$3$。算法又遍历了$1$到$n$中$3$的倍数，进行了$\frac{n}{3}$步操作</li>
  <li>再然后，跳过$4$找到下一个质数$5$，遍历了$1$到$n$中$5$的倍数，进行了$\frac{n}{5}$步操作</li>
  <li>……</li>
</ul>

<p>那么最后一共执行了多少步操作？答案是一个无穷级数之和：</p>

<div class="kdmath">$$
\frac{n}{2}+\frac{n}{3}+\frac{n}{5}+\frac{n}{7}+\frac{n}{11}+\cdots
$$</div>

<p>将$n$提出来，并将剩余项写成求和符号，就是：</p>

<div class="kdmath">$$
n\cdot\sum_{p\text{ is prime}}\frac 1{p}
$$</div>

<p>问题来了，后面这个无穷级数怎么求？</p>

<h2 id="2-何为时间复杂度">#2 何为时间复杂度？</h2>

<p>可能大部分人会以为这是一个困难的数论问题，但是不要忘了，计算时间复杂度的时候，只需要考虑<strong>数据趋近无穷的趋势</strong>，而<strong>不用考虑具体数值</strong>。</p>

<p>那么如何定义“趋势”？我们不妨借鉴一下小学二年级的高数知识：</p>

<blockquote>
  <p>如果两个趋近无穷的数列$a_n$和$b_n$满足</p>

  <div class="kdmath">$$
\lim_{n\to\infty}\frac{a_n}{b_n}=c
$$</div>

  <p>其中$c$为一个常数且不为$0$，那么这两个数列称为<strong>同阶无穷大</strong>，记作$a_n \sim b_n$。</p>
</blockquote>

<p>根据同阶无穷大定义时间复杂度的大$O$记号了：</p>

<blockquote>
  <p>对于某个算法，如果它只有一个输入$N$，那么将$N$依次代入从$1$开始的所有自然数，记$t_i$为输入数字$i$时算法的运行时间（或者说“执行的操作数”），那么可以得到一个数列$\{t_N\}$。</p>

  <p>假如存在一个<em>简单表达式</em>$q_N$，使得</p>

  <div class="kdmath">$$
t_N\sim q_N
$$</div>

  <p>那么记这个算法的时间复杂度为$O(q_N)$。</p>
</blockquote>

<p>思考题：根据同阶无穷大的定义，证明：</p>
<ul>
  <li>$O(N^2+2N)\sim O(N^2)$</li>
</ul>

<h2 id="3-无穷级数">#3 无穷级数</h2>

<p>即便有了这样的定义，我们就将问题化解为了：<em>寻找一个简单表达式，使得它和“<strong>所有质数的倒数和</strong>”是同阶无穷大</em>。</p>

<p>在这之前，我们可以使用一个已经被证明过的结论：质数分布是$O(N\log N)$的。记第$n$个质数为$p_n$，则：</p>

<div class="kdmath">$$
p_n\sim n\ln n
$$</div>

<p>从这里还不能完全得出我们想要的结论，但我们已经可以对开头提到的无穷级数进行化简了：</p>

<div class="kdmath">$$
\sum_{n=1}^\infty \frac 1{p_n}\sim \sum_{n=1}^\infty \frac 1{n\ln n}
$$</div>

<blockquote>
  <p>引理1：若$a_n, b_n$均<strong>非负</strong>且为同阶无穷小，即$a_n\sim b_n$，则</p>

  <div class="kdmath">$$
\sum_{n=1}^\infty a_n\sim \sum_{n=1}^\infty b_n
$$</div>

  <p>证明：根据同阶无穷小的定义，可得：</p>

  <div class="kdmath">$$
\lim_{n\to\infty}\frac{a_n}{b_n}=c
$$</div>

  <p>根据极限的$\epsilon-N$定义，对于任给的$\epsilon\gt0$，总存在$N\gt0$，使得所有$n\gt N$都有：</p>

  <div class="kdmath">$$
c-\epsilon \lt \frac{a_n}{b_n}\lt c+\epsilon
$$</div>

  <p>因为$n$可以取任何大于$N$的值，再根据恒等式$\frac{a}{b}\lt\frac{a+c}{b+d}\lt\frac{c}{d}$，可以将所有形如$\frac{a_n}{b_n}$的分式合并而不影响其性质：</p>

  <div class="kdmath">$$
c-\epsilon \lt \frac{\sum_{n=N}^\infty a_n}{\sum_{n=N}^\infty b_n} \lt c+\epsilon
$$</div>

  <p>换句话说，存在$N\gt0$使得</p>

  <div class="kdmath">$$
\frac{\sum_{n=N}^\infty a_n}{\sum_{n=N}^\infty b_n}
$$</div>

  <p>是有限且非0的。</p>

  <p>又因为$\sum_{n=1}^{N-1}a_n$和$\sum_{n=1}^{N-1}b_n$是有限的，所以</p>

  <div class="kdmath">$$
\frac{\sum_{n=1}^{N-1}a_n}{\sum_{n=1}^{N-1}b_n}
$$</div>

  <p>是有限的。</p>

  <p>根据恒等式$\frac{a}{b}\lt\frac{a+c}{b+d}\lt\frac{c}{d}$，可以得到：</p>

  <div class="kdmath">$$
\frac{\sum_{n=1}^{N-1}a_n + \sum_{n=N}^\infty a_n}{\sum_{n=1}^{N-1}b_n + \sum_{n=N}^\infty b_n}=\frac{\sum_{n=1}^\infty a_n}{\sum_{n=1}^\infty b_n}
$$</div>

  <p>一定也是有限且非0的。证毕。</p>
</blockquote>

<p>经过此次化简，至少题目看起来像道代数题而不是数论题了，但无穷级数$\sum_{n=1}^\infty \frac 1{n\ln n}$仍然让人没有头绪。</p>

<blockquote>
  <p>引理2：对于一个<strong>单调函数</strong>$f(n)$</p>

  <div class="kdmath">$$
\sum_{n=1}^\infty f(n) \sim \int_1^\infty f(n)\mathrm dn
$$</div>

  <p>证明：</p>

  <p><img src="/img/eto-0.png" alt="eto-0" /></p>

  <div class="kdmath">$$
\int_1^\infty f(n)\mathrm dn=\sum_{k=1}^\infty \int_k^{k+1}f(n)\mathrm dn
$$</div>

  <p>不妨假设函数$f(n)\gt0$，则$f(n)$单调减。又因为$\lim_{n\to\infty}f(n)=0$，因此：</p>

  <div class="kdmath">$$
\begin{align*}
& \sum_{k=1}^\infty f(k)-\sum_{k=1}^\infty \int_k^{k+1}f(n)\mathrm dn \\
= & \sum_{k=1}^\infty\left[ f(k)-\int_k^{k+1}f(n)\mathrm dn \right] \\
\le & \sum_{k=1}^\infty[ f(k)-f(k+1) ] \\
= & f(1) - 0 \\
= & f(1)
\end{align*}
$$</div>

  <p>也就是说$\sum_{n=1}^\infty f(n)$和$\int_1^\infty f(x)\mathrm dx$之间至多相差常数$f(1)$，又因为两者均不为$0$，那么两者之比一定有限且非$0$。</p>

  <p>证毕</p>
</blockquote>

<p>有了这个结论，我们就能直接得到：</p>

<div class="kdmath">$$
\sum_{n=1}^\infty \frac 1{n\ln n} \sim \int_1^\infty \frac{\mathrm dn}{n\ln n}\sim \ln\ln n
$$</div>

<p>回到最初的问题：</p>

<div class="kdmath">$$
N\cdot\sum_{p\text{ is prime}}p \sim N\sum_{n=1}^\infty \frac 1{n\ln n} \sim N\ln\ln N
$$</div>

<p>也就是说，埃氏筛的时间复杂度是$O(N\log\log N)$级别的。</p>

<h2 id="思考题">思考题</h2>

<ol>
  <li>（简单）请用本文中的定理证明：
<span class="kdmath">$\sum_{n=1}^\infty\frac 1n \sim \ln n$</span></li>
  <li>（困难）请不用本文提到的方法证明题目1</li>
</ol>

<h2 id="参考资料">参考资料</h2>

<p>[1] “Sieve of Eratosthenes.” <em>Wikipedia</em>, <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</a>. Accessed 18 Aug. 2022.</p>

<p>[2] “Distribution of Primes.” <em>Brilliant</em>, <a href="https://brilliant.org/wiki/distribution-of-primes/">https://brilliant.org/wiki/distribution-of-primes/</a>. Accessed 18 Aug. 2022.</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="algorithm" /><category term="math" /><category term="time-complexity" /><summary type="html"><![CDATA[埃拉托斯特尼筛法（Sieve of Erastosthenis），简称埃氏筛，是一种可以在极少时间复杂度内算出$n$以内的所有质数的算法。]]></summary></entry><entry><title type="html">git原理简介</title><link href="mqcreaple.github.io/blog/2022/03/04/git.html" rel="alternate" type="text/html" title="git原理简介" /><published>2022-03-04T00:00:00-05:00</published><updated>2022-03-04T00:00:00-05:00</updated><id>mqcreaple.github.io/blog/2022/03/04/git</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/03/04/git.html"><![CDATA[<p>相信大家都对<a href="https://git-scm.com/">git</a>耳熟能详了。Git是一个简单易用的版本管理工具，用户可以在git中修改文件、提交commit（更新到本地仓库）、同步远程仓库等。本篇文章将主要讨论git更新文件和提交commit背后的原理。</p>

<p>前置知识：git基本操作，详见<a href="https://www.runoob.com/git/">runoob</a>和<a href="https://www.w3schools.com/git/">w3schools</a>。</p>

<h2 id="一些名词">一些名词</h2>
<ul>
  <li><strong>工作区（working tree）</strong>表示除去<code>/.git</code>以外的工作目录，即通常写代码的位置。</li>
  <li><strong>暂存区/索引（index）</strong>是执行完<code>git add</code>指令时文件被添加到的地方。如果没有执行过<code>git add</code>命令，git并不会为你自动保存。</li>
  <li><strong>版本库（repository）</strong>是所有当前暂存区和历史上commit过的文件，暂存区可以看作是版本库的一个子集。所有版本库的文件都保存在<code>/.git</code>目录下。</li>
</ul>

<p>所有的历史文件、文件目录、commmit记录等全部保存为二进制对象，统一保存在/.git/objects目录下，文件名为该文件的SHA-1哈希值且没有后缀。</p>

<ul>
  <li>blob：全称为Binary Large Object，是常规文件保存在<code>/.git/objects</code>下的形式。</li>
  <li>tree：目录文件保存在<code>/.git/objects</code>下的形式。</li>
  <li>commit：commit记录保存在<code>/.git/objects</code>下的形式。</li>
</ul>

<pre><code class="language-plaintext">└── objects
    ├── 41
    │   └── a1d4060cf09286c1cd8fe8bdab89ce26b71086
    ├── ce
    │   └── 013625030ba8dba906f756967f9e9ca394464a
    ├── dc
    │   └── a98923d43cd634f4359f8a1f897bf585100cfe
    ├── info
    └── pack
</code></pre>

<p>上图的文件目录中，三个object的SHA-1值分别为：<code>41a1d4...</code>，<code>ce0136...</code>，和<code>dca989...</code>。</p>

<p>可以使用指令：</p>

<pre><code class="language-shell">git hash-object 文件名
</code></pre>

<p>计算一个文件的SHA-1哈希值。</p>

<h2 id="head指针和commit">HEAD指针和commit</h2>

<p><code>HEAD</code>是一个指针，默认指向当前分支的最新一个commit（存储了commit文件的哈希值）。每一次提交新的commit时，<code>HEAD</code>也会相应前移。<code>HEAD</code>存储在<code>/.git/HEAD</code>文件中。</p>

<p>每一个分支也有各自的head，指向当前分支的最后一个commit，各分支的head存储在<code>/.git/refs/heads/</code>分支名文件中。每一次执行<code>git checkout</code>切换分支的时候，实际上就是让全局的<code>HEAD</code>赋值成了另一个分支的head。</p>

<p>总结一下，现在讲过的<code>/.git</code>目录结构都有：</p>

<pre><code class="language-plaintext">.git
├── HEAD          全局HEAD指针
├── objects
│   └── 二进制对象都在这里
└── refs
    └── heads
        └── 各个分支的head
</code></pre>

<p>除了第一个commit，以后的每个commit都会记录上一个commit的哈希值，这样就形成了一个树形结构。</p>

<p>当整个项目只有一个分支时，所有的commit形成一条链：</p>

<div class="mermaid">
graph RL
A[commit<br />a5e2] --&gt; B[commit<br />3d97]
B --&gt; C[commit<br />9cd6]
C --&gt; D[commit<br />729f]
D --&gt; E[commit<br />4375]
E --&gt; F[......]
subgraph master: head
A
end
</div>

<p>有多个分支时，则是这样的：</p>

<div class="mermaid">
graph RL
A[commit<br />a5e2] --&gt; B[commit<br />3d97]
B --&gt; C[commit<br />9cd6]
C --&gt; D[commit<br />729f]
D --&gt; E[commit<br />4375]
E --&gt; F[......]
subgraph master: head
A
end
G[commit<br />fc6a] --&gt; E
H[commit<br />7032] --&gt; G
subgraph branch1: head
H
end
</div>

<h2 id="文件和目录">文件和目录</h2>

<p>之前说过，blob对象和tree对象都存在<code>.git/objects/</code>目录下。Tree对象存储了其他一系列文件的哈希值，可以理解成是一个多叉树的结点，而一般文件是根节点。</p>

<div class="mermaid">
graph TD
A[[root]] --&gt; B([readme.md])
A --&gt; C([.gitignore])
A --&gt; D[[src]]
D --&gt; E([main.cpp])
D --&gt; F([main.h])
A --&gt; G[[test]]
G --&gt; H([test.cpp])
</div>

<p>暂存区/索引对应着<code>/.git/index</code>文件，它记录了当前暂存的所有文件和目录的哈希值。每一次执行<code>git add</code>指令，程序就会在<code>/.git/objects</code>目录中生成一个对应着该文件的blob对象，同时将这个对象的地址加到<code>/.git/index</code>中。</p>

<p>每一个commit结点指向了一个tree节点，表示某一次commit的根目录。两次commit中不变文件不会被创建新对象。</p>

<p><img src="/img/git-file-0.svg" alt="git-file-0" /></p>

<p>这时，如果我们添加了一个<code>.gitignore</code>文件并且执行<code>git add .gitignore</code>命令，就会创建一个新的blob对象并添加进索引。</p>

<p><img src="/img/git-file-1.svg" alt="git-file-1" /></p>

<p>再接下来提交commit，程序就会新建一个表示根目录的tree对象并且指向所有索引（index）中的文件和文件夹。最后再处理commit结点，将其指向上一次的commit，即完成了git提交，如图：</p>

<p><img src="/img/git-file-2.svg" alt="git-file-2" /></p>

<h2 id="总结">总结</h2>

<blockquote>
  <p>Git的所有对象，包括文件、目录、和commit，全部存储在<code>/.git/object/</code>文件夹下。</p>

  <p>Commit结点指向其上一次的commit，形成一个树形结构，每个叶节点对应一个分支的head。</p>

  <p>全局的<code>HEAD</code>指针指向任意一个commit结点，通常是一个特定分支的head。</p>

  <p>blob对应一般的文件，tree对应文件夹，同一个文件夹下所有文件和文件夹组成一个树形结构，但同一个文件有可能被不同版本的文件夹同时指向。</p>

  <p>每次add文件时，git会生成一个新的blob对象并添加到index中。</p>

  <p>每次进行commit时，git会生成tree对象并令其指向所有的子文件，最后让commit结点指向根目录文件夹，同时设置commit结点的上一个结点，最后完成提交。</p>
</blockquote>

<p>Git的版本管理逻辑和信息竞赛里的“可持久化算法”思想很像，都是尽量避免记录过多重复的内容从而减少空间占用。</p>

<p>Git在文件和目录这个树形结构之上，还有一个“commit”的分支结构，这意味着它可以应对更复杂的需求，但也意味着使用者需要记忆更多的命令。</p>

<p>本文仅是一个简单介绍，没有涵盖诸如分支合并和tag等更复杂的功能，如果以后有时间可以更新。</p>

<h2 id="参考资料">参考资料</h2>

<p>[1] Chacon, Scott and Straub, Ben. “Pro Git v2”. Git, <a href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a>.</p>

<p>[2] Wiegley, John. “Git from the Bottom to Up”. GitHub, <a href="https://jwiegley.github.io/git-from-the-bottom-up/">https://jwiegley.github.io/git-from-the-bottom-up/</a>.</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="git" /><category term="github" /><summary type="html"><![CDATA[相信大家都对git耳熟能详了。Git是一个简单易用的版本管理工具，用户可以在git中修改文件、提交commit（更新到本地仓库）、同步远程仓库等。本篇文章将主要讨论git更新文件和提交commit背后的原理。]]></summary></entry><entry><title type="html">2.0公告 &amp;amp; jekyll介绍</title><link href="mqcreaple.github.io/blog/2022/03/01/jekyll.html" rel="alternate" type="text/html" title="2.0公告 &amp;amp; jekyll介绍" /><published>2022-03-01T00:00:00-05:00</published><updated>2022-03-01T00:00:00-05:00</updated><id>mqcreaple.github.io/blog/2022/03/01/jekyll</id><content type="html" xml:base="mqcreaple.github.io/blog/2022/03/01/jekyll.html"><![CDATA[<h2 id="公告">公告</h2>

<p>大约有三四个月没有发新的博客了，不知道还有没有人看。。。</p>

<p>自从这个版本之后，我将舍弃我自己做的那个博客文章发布系统，而采用一个现成的工具：jekyll。主要原因嘛，就是<del>懒得继续写代码</del>jekyll做的比我自己写的系统好用。毕竟造别人已经造过的轮子是无意义的（</p>

<p>现在旧版博客文章还没有完全迁移过来，以后也会陆陆续续全部搞完。</p>

<h2 id="jekyll介绍"><a href="https://jekyllrb.com/">Jekyll</a>介绍</h2>

<p><a href="https://jekyllrb.com/">Jekyll的官方网站</a>上也有详细的文档，第一次使用的话完全可以照着文档操作。我在这里也简单地介绍一下：</p>

<ol>
  <li>Jekyll是用Ruby写成的，安装前请先确保电脑上有ruby环境和ruby的包管理工具rubygems。</li>
  <li>使用如下指令安装Jekyll：
    <pre><code class="language-shell">gem install bundler jekyll
</code></pre>
  </li>
  <li>接下来使用如下指令创建新工程：
    <pre><code class="language-shell">jekyll new 工程名称
</code></pre>
  </li>
  <li>进入目录，你应该看到这样的目录结构
    <pre><code class="language-plaintext">.
├── 404.html
├── Gemfile
├── Gemfile.lock
├── _config.yml
├── about.markdown
├── index.markdown
└── _posts
 └── xxxx-xx-xx-welcome-to-jekyll.markdown
</code></pre>
    <p>简单解释一下：</p>
    <ul>
      <li><code>_config.yml</code>存放了这个工程的基本信息，比如博客标题、描述、作者的邮箱等，也可以在_config.yml上面继续添加新的信息。</li>
      <li><code>Gemfile</code>和<code>Gemfile.lock</code>是一些关于Gem的信息，可以暂时不用管。</li>
      <li><code>404.html</code>是404错误页面，如果用户试图访问一个你没有写过的页面，就会自动跳转到这个页面上。</li>
      <li><code>index.markdown</code>(写成<code>index.md</code>也可以被系统识别)是博客的主页，即在浏览器输入博客地址后第一个看见的页面。</li>
      <li><code>about.markdown</code>(同上，<code>about.md</code>也被允许)是个人介绍页面。</li>
      <li><code>_posts</code>文件夹下放各个博客文章，每个文章都是一个Markdown文件。文章的文件名都应该是<code>YYYY-MM-dd-TITLE.md</code>格式，即4位年份、2为月份、2位日期，后面跟着文章标题，空格用<code>-</code>代替。</li>
    </ul>
  </li>
  <li>Jekyll会将所有在根目录下和<code>_posts</code>目录下的Markdown文件全部编译成HTML，连同其他文件放在<code>_site</code>目录下。也就是说，进行编译后，<code>_site</code>文件夹下就是一个完整的网站，各个博客会被按照类别和日期整理起来。
    <pre><code class="language-shell">bundle exec jekyll serve
</code></pre>
    <p>会进行编译并且将_site目录下的网站运行在http://localhost:4000/上。当服务程序跑起来时，_posts下的Markdown文件发生改动也会实时编译并更改对应的网页内容。</p>
  </li>
  <li>Jekyll的Markdown，准确来说是“加强版Markdown”。每个Markdown文件都有一个header，像这样：
    <pre><code class="language-yaml">---
layout: post
title: XXX-XXX
permalink: /aaa/bbb/
category: blog
---
</code></pre>
    <p>其中</p>
    <ul>
      <li><code>title</code>后面的内容会被自动添加为文件的一级标题，因此并不需要在写Markdown时再写一遍标题。</li>
      <li><code>category</code>是文件的类别，比如这里是<code>blog</code>的话就会在编译为HTML时将其放在<code>_site/blog/</code>文件夹下。</li>
      <li><code>layout</code>是页面的布局方式，Jekyll有一些预定义的layout，比如<code>home</code>, <code>post</code>, <code>page</code>等，也可以自己定义布局方式，比如两列布局、三列布局，将写好的HTML文件放在<code>_layout/</code>文件夹下就可以。但这需要一定的HTML基础。</li>
      <li>默认情况下，编译后的Markdown文件会被放在<code>年/月/日/标题.html</code>目录下。如果不想放在这里，可以更改<code>permalink</code>变量。上例中文件就会被放在<code>/aaa/bbb/index.html</code>。 还有一些其他可以定义的头部参数，详见官网。</li>
    </ul>
  </li>
  <li>Markdown文件中还可以使用变量。形如<code>{{site._____}}</code>的字符串会在编译时被替换成<code>_config.yml</code>里对应的值，例如在我的定义下：
    <pre><code class="language-markdown">My email is {{site.email}}
</code></pre>
    <p>就会变成：</p>
    <pre><code class="language-plaintext">My email is gmq14159@gmail.com
</code></pre>
    <p>类似的，<code>{{page.____}}</code>可以返回Markdown Header里面的对应变量值。详细解释请看Jekyll官方文档。</p>
  </li>
</ol>

<p>关于Jekyll就先讲这么多，更多的信息也可以在网上找到。</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="bulletin" /><category term="jekyll" /><category term="writing" /><summary type="html"><![CDATA[公告]]></summary></entry><entry><title type="html">为何非弹性碰撞下动量守恒而能量不守恒？</title><link href="mqcreaple.github.io/blog/2021/12/19/simulation2.html" rel="alternate" type="text/html" title="为何非弹性碰撞下动量守恒而能量不守恒？" /><published>2021-12-19T00:00:00-05:00</published><updated>2021-12-19T00:00:00-05:00</updated><id>mqcreaple.github.io/blog/2021/12/19/simulation2</id><content type="html" xml:base="mqcreaple.github.io/blog/2021/12/19/simulation2.html"><![CDATA[<h2 id="1-模拟">1. 模拟</h2>

<p>假设现在有两种不同的分子，同种分子之间有引力，异种分子之间有斥力。</p>

<p>我们使用一个理想模型：同种分子之间的使用弹簧连接，弹簧会主动维护一个固定长度$l_0$；异种分子之间的斥力满足平方反比定律。具体公式如下：</p>

<div class="kdmath">$$
\bm F_1=k_1(\bm r_{12} - \bm l_0)
$$</div>

<div class="kdmath">$$
\bm F_2=k_2\cdot\frac{\bm r_{12}}{r_{12}^2}
$$</div>

<p>其中$F_1$为同种分子之间的引力，$F_2$为异种分子之间的斥力。</p>

<p>模拟结果如下：</p>

<ol>
  <li>$k_1:k_2=5:1$，近似为理想刚体的弹性碰撞</li>
</ol>

<p><img src="/img/sim_animation1.gif" alt="animation1" /></p>

<ol>
  <li>$k_1:k_2=1:1$</li>
</ol>

<p><img src="/img/sim_animation2.gif" alt="animation2" /></p>

<ol>
  <li>$k_1:k_2=0.75:1$，碰撞为塑性碰撞</li>
</ol>

<p><img src="/img/sim_animation3.gif" alt="animation3" /></p>

<h2 id="分析">分析</h2>

<p>从这些模拟动画中可以看出在塑性碰撞之后，固体内部的分子自身产生了微小振动，将一部分物体的平动动能转化成了分子的振动动能（即内能）。这就是我们问题的答案：塑性碰撞将宏观物体的能量转化成了微观分子的能量，因此宏观上能量减少了。</p>

<p>值得注意的是，分子的振动并不能带走宏观物体的动量，因为分子的振动是随机的，并且在各个方向上出现的概率相等，因此统计上分子的动量之和应当为0。这也是为什么不论在弹性还是在塑性碰撞中，物体的动量都是守恒的。</p>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="simulation" /><category term="julia" /><category term="physics" /><summary type="html"><![CDATA[1. 模拟]]></summary></entry><entry><title type="html">算法化求导</title><link href="mqcreaple.github.io/blog/2021/09/11/derivative-m.html" rel="alternate" type="text/html" title="算法化求导" /><published>2021-09-11T00:00:00-04:00</published><updated>2021-09-11T00:00:00-04:00</updated><id>mqcreaple.github.io/blog/2021/09/11/derivative-m</id><content type="html" xml:base="mqcreaple.github.io/blog/2021/09/11/derivative-m.html"><![CDATA[<p>求导是一种算符，输入一个表达式，输出另一个表达式</p>

<p>我们学过求导的运算法则，例如$(u+v)’=u’+v’$等等，将这些法则运用于某个表达式，即可实现算法化求导</p>

<p>首先，我们要从表达式树说起</p>

<h2 id="表达式树">表达式树</h2>

<p>任何一个表达式，都可以被拆解成一棵二叉树，其中叶结点为数字或字母，非叶结点则为运算符和函数</p>

<p>例如如下的表达式：</p>

<div class="kdmath">$$
f(x)=3x^2+2\sin(x)
$$</div>

<p>可以被拆解成如下的表达式树：</p>

<div class="mermaid">
graph TD
A((+)) --&gt; B((*))
A --&gt; C((*))
B --&gt; D[3]
B --&gt; E((^))
E --&gt; F[x]
E --&gt; G[2]
C --&gt; H[2]
C --&gt; I((sin))
I --&gt; J[x]
</div>

<p>计算$f(x)$的过程也很简单，只需要将所有未知数都替换成某个特定的值$x_0$，接着从下往上递归，将所有非叶结点替换为计算结果，最后根结点的数值就是答案了</p>

<p>以上面的表达式树为例，如果我们想要计算$f\left(\dfrac{\pi}{2}\right)$的数值，首先把所有$x$结点换成$\frac\pi2$</p>

<div class="mermaid">
graph TD
A((+)) --&gt; B((*))
A --&gt; C((*))
B --&gt; D[3]
B --&gt; E((^))
E --&gt; F[π/2]
E --&gt; G[2]
C --&gt; H[2]
C --&gt; I((sin))
I --&gt; J[π/2]
</div>

<p>接下来从下向上递归计算。先将$\left(\dfrac\pi2\right)^2$替换为$\dfrac{\pi^2}{4}$，将$\sin\left(\dfrac\pi2\right)$替换为$1$</p>

<div class="mermaid">
graph TD
A((+)) --&gt; B((*))
A --&gt; C((*))
B --&gt; D[3]
B --&gt; E[π^2/4]
C --&gt; H[2]
C --&gt; I[1]
</div>

<p>继续重复上述操作：</p>

<div class="mermaid">
graph TD
A((+)) --&gt; B[3π^2/4]
A --&gt; C[2]
</div>

<p>最终得到答案：$\dfrac{3\pi^2}{4}+2$</p>

<h2 id="树上操作求导">树上操作&amp;求导</h2>

<p>我们暂且使用：</p>

<pre><code class="language-java">class Node {
    private String operator;
    private Node left;
    private Node right;
    Node(char operator, Node left, Node right) {
        this.operator = operator;
        this.left = left;
        this.right = right;
    }
}
</code></pre>

<p>来表示一个表达式树的非叶结点</p>

<h3 id="加减法">加减法</h3>

<p>我们不妨从最简单的加法运算开始考虑</p>

<p>当某个结点是<code>+</code>运算时，我们不妨设左右两端的表达式分别为$f(x)$和$g(x)$，那么这个结点就表示了函数$h(x)=f(x)+g(x)$。</p>

<pre><code>    +
   / \
f(x) g(x)
</code></pre>

<p><em>（省流大师</em></p>

<p>那么，根据导数的运算律，我们可以得到：</p>

<div class="kdmath">$$
h'(x)=(f+g)'(x)=f'(x)+g'(x)
$$</div>

<p>也就是说，先分别计算这棵表达式树的左右子树的导数，接着将它们套在一个<code>+</code>结点上，就是这个表达式树的导数</p>

<pre><code>                 +               +
derivative {    / \    } =     /   \
             f(x) g(x)     f'(x)  g'(x)
</code></pre>

<p>写成代码的形式，就是：</p>

<pre><code class="language-java">if(root.operator == "+") {
    return new Node(
        "+",
        derivative(root.left),
        derivative(root.right)
    );
}
</code></pre>

<p>对于减法，也是同理：</p>

<pre><code>                 -               -
derivative {    / \    } =     /   \
             f(x) g(x)     f'(x)  g'(x)
</code></pre>

<pre><code class="language-java">if(root.operator == "-") {
    return new Node(
        "-",
        derivative(root.left),
        derivative(root.right)
    );
}
</code></pre>

<h3 id="乘法除法">乘法&amp;除法</h3>

<p>乘法运算则略微复杂一些。如果$h(x)=f(x)g(x)$，根据导数运算律。有：</p>

<div class="kdmath">$$
h'(x)=f(x)g'(x)+g(x)f'(x)
$$</div>

<p>也就是：</p>

<pre><code>                                   +
                 *              /     \
derivative {    / \    } =    *         *
             f(x) g(x)      /   \     /   \
                         f(x) g'(x) g(x) f'(x)
</code></pre>

<p>写成代码：</p>

<pre><code class="language-java">if(root.operator == "*") {
    return new Node(
        "-",
        new Node(
            "*",
            root.left,
            derivative(root.right)
        ),
        new Node(
            "*",
            root.right,
            derivative(root.left)
        )
    );
}
</code></pre>

<p>除法则更复杂一些：</p>

<div class="kdmath">$$
\left(\dfrac{f(x)}{g(x)}\right)'=\dfrac{f'(x)g(x)-f(x)g'(x)}{g(x)^2}
$$</div>

<p><del>表达式树实在懒得画了</del></p>

<p>也就是：</p>

<pre><code class="language-java">if(root.operator == "/") {
    return new Node(
        "/",
        new Node(
            "-",
            new Node(
                "*"
                root.right,
                derivative(root.left)
            ),
            new Node(
                "*",
                root.left,
                derivative(root.right)
            )
        ),
        new Node(
            "^",
            root.right,
            new NumberNode(2)
        )
    );
}
</code></pre>

<h3 id="乘方">乘方</h3>
<p>到了乘方这里，事情就有点难办了</p>

<p>我们知道指数函数的导数公式$(a^x)’=a^x\ln a$，也知道幂函数的导数公式$(x^a)’=ax^{a-1}$，但是现在问题是：未知数可能同时出现在底数和指数上</p>

<p>换句话说，我们想要求的是：</p>

<div class="kdmath">$$
\left(f(x)^{g(x)}\right)'
$$</div>

<pre><code>                 ^
derivative {    / \    } = ?
             f(x) g(x)
</code></pre>

<p>这里我们要用到一点小技巧</p>

<p>首先令</p>

<div class="kdmath">$$
y=f(x)^{g(x)}
$$</div>

<p>接着，两边同时求对数：</p>

<div class="kdmath">$$
\ln y=\ln f(x)^{g(x)}=g(x)\ln f(x)
$$</div>

<p>接下来，两边对$x$求导，得到：</p>

<div class="kdmath">$$
\frac{\mathrm d\ln y}{\mathrm dx}=\frac{\mathrm d(g(x)\ln f(x))}{\mathrm dx}
$$</div>

<p>对等式左侧使用链式求导法则：</p>

<div class="kdmath">$$
\frac{\mathrm d\ln y}{\mathrm dx}=\frac{\mathrm d\ln y}{\mathrm dy}\cdot\frac{\mathrm dy}{\mathrm dx}=\frac 1y\cdot\frac{\mathrm dy}{\mathrm dx}
$$</div>

<p>同时对等式右侧使用导数的乘法法则：</p>

<div class="kdmath">$$
\begin{align*}
\frac{\mathrm d(g(x)\ln f(x))}{\mathrm dx} &= g(x)\frac{\mathrm d\ln f(x)}{\mathrm df(x)}\frac{\mathrm df(x)}{\mathrm dx}+\ln f(x)\cdot\frac{\mathrm dg(x)}{\mathrm dx} \\
& =\frac{g(x)}{f(x)}f'(x)+g'(x)\ln f(x)
\end{align*}
$$</div>

<p>最终我们得到：</p>

<div class="kdmath">$$
\frac 1y\cdot y'=\frac{g(x)}{f(x)}f'(x)+g'(x)\ln f(x)
$$</div>

<p>$y’$即为所求，因此将等式左侧的$\frac1y$乘到右侧，并将$y$替换为$f(x)^{g(x)}$，我们得到：</p>

<div class="kdmath">$$
y'=\left(f(x)^{g(x)}\right)'=f(x)^{g(x)}\left(\frac{g(x)}{f(x)}f'(x)+g'(x)\ln f(x)\right)
$$</div>

<p>这就是两个表达式乘方的导数</p>

<p>由于这玩意实在太长，它的代码形式和表达式树形式我就不列出来了。大家只需要知道这玩意能算出来就行了</p>

<h3 id="叶结点的处理">叶结点的处理</h3>

<p>当我们运算到叶结点（即常数和变量）时，就可以直接按照如下方法处理：</p>

<p><span class="kdmath">$text{返回值}=\begin{cases}1, \text{结点值}=\text{求导变量}\\0, \text{结点值}\neq\text{求导变量}\end{cases}$</span></p>

<p>对$x$求导时，只有$x’$会返回$1$。其余情况，包括常数的导数，和多元函数中其他变量（比如$y, z$）对$x$的导数，都会返回$0$</p>

<h2 id="优化">优化</h2>
<p>我们不妨随便找一个函数进行一下运算，比如：</p>

<div class="kdmath">$$
f(x)=x^2
$$</div>

<pre><code>  ^
 / \
x   2
</code></pre>

<p>代入之前得到的指数求导表达式：</p>

<div class="kdmath">$$
(x^2)'=x^2(2'\cdot\ln x+\dfrac2x\cdot x')
$$</div>

<p>建立的表达式树如下：</p>

<pre><code>        ×
    /       \
  ^           +
 / \       /     \
x   2    ×         *
       /   \      / \
    (2)'   ln    ÷   x'
           |    / \
           x   2   x
</code></pre>

<p>接着根据叶结点的处理规则，将$2’$替换成$0$，将$x’$替换成$1$，得到了表达式树：</p>

<pre><code>        ×
    /       \
  ^           +
 / \       /     \
x   2    ×         *
       /   \      / \
      0    ln    ÷   1
           |    / \
           x   2   x
</code></pre>

<p>可以看到，表达式树中有许多诸如<code>×0</code>，<code>×1</code>，<code>÷1</code>之类的冗余表达。为了去除这些冗余，我们需要对表达式树进行优化</p>

<h3 id="初级优化">初级优化</h3>
<p>结点的所有子结点均为常数时，直接合并成单个常数结点，例如$2+3$直接合并为$5$</p>
<ul>
  <li>加法：$a+0=0+a=a$</li>
  <li>减法：$a-0=a$, $0-a=-a$, $a-a=0$</li>
  <li>乘法：$a\times0=0$, $a\times1=a$</li>
  <li>除法：$a/0=\text{NaN}$, $a/1=a$, $0/a=0$, $a/a=1$</li>
  <li>乘方：$a^0=1$, $a^1=a$, $0^a=0$, $1^a=1$</li>
  <li>其它：$\ln1=0$, $\sin\pi=0$等</li>
</ul>

<h3 id="中级优化">中级优化</h3>

<p>涉及到某个结点和它的一级子结点</p>

<ul>
  <li>加减法：$a+(-b)=a-b$</li>
  <li>乘除法：$a\times(1/b)=a/b$</li>
  <li>乘方：$(a^n)\cdot a=a^{n+1}$, $(a^n)/a=a^{n-1}$</li>
  <li>对数：$a^{\log_ab}=b$…</li>
</ul>

<h3 id="高级优化">高级优化</h3>

<p>这些优化本身不一定能够让式子变得更加简洁，它要求机器能够判断展开后表达式是否能够进一步化简</p>

<ul>
  <li>乘法分配律：$(a+b)c=ac+bc$</li>
  <li>乘方运算律：$a^{b+c}=a^b\cdot a^c$</li>
  <li>对数运算律：$\log(ab)=\log a+\log b$</li>
</ul>]]></content><author><name>MqCreaple</name></author><category term="blog" /><category term="math" /><category term="calculus" /><category term="algorithm" /><summary type="html"><![CDATA[求导是一种算符，输入一个表达式，输出另一个表达式]]></summary></entry></feed>