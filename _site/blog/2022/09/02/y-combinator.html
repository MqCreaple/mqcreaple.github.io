<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<meta name="author" content="MqCreaple">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="/favicon.png">
<link rel="stylesheet" href="/css/main.css">



<!-- font awesome -->
<link rel="stylesheet" href="/css/font-awesome.min.css">

<!-- katex -->
<link rel="stylesheet" href="/css/katex.min.css">

<!-- highlightjs -->
<script src="/js/highlight.min.js"></script>
<link rel="stylesheet" href="/css/github-dark.min.css">
<script>hljs.highlightAll();</script>

<!-- mermaid -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>mermaid.initialize({startOnLoad:true});</script>
    <title>Y combinator和递归 - My Blog | MqCreaple</title>
</head>
<body>
<div id='container'>
    
<div id="header">
    <div id="navbar" class="inline">
        <a href="/" class="strong">My Blog | MqCreaple</a>
        <a href="/aboutme/"><i class="fa-solid fa-user"></i>about me</a>
        <a href="/blog/"><i class="fa-regular fa-file-lines"></i>blog</a>
        <a href="/app/"><i class="fa-solid fa-cubes-stacked"></i>app</a>
        <a href="/feed.xml"><i class="fa-solid fa-rss"></i>RSS</a>
    </div>
</div>
    <div id='main'>
        <div id='left'>
            <div class='card article'>
                
                <h1>Y combinator和递归</h1>
                <link rel="stylesheet" href="/app/lambda-playground/lambda-playground.css" />

<script src="/app/lambda-playground/lambda-playground.js" onload="autoRender()"></script>

<p><strong>如果你不了解λ演算，请阅读<a href="/blog/2022/08/27/lambda.html">上一篇博客</a>以获得最佳食用体验</strong></p>

<p><em>注：本文的λ表达式中所有出现的下划线<code>_</code>，都表示“这个值我懒得算且不关心”</em></p>

<h2 id="y组合子">Y组合子</h2>

<p>其实，并不是所有的λ表达式都可以求值。比如说，一个经典的构造就是：</p>

<pre><code class="language-plaintext">((λx. (x x)) (λx. (x x)))
</code></pre>

<p class="lambda-r">[ [ "λx", [ "x", "x" ] ], [ "λx", [ "x", "x" ] ] ]</p>

<p>这个表达式很有意思。当你把后面的表达式代入前面的<code>x</code>中时，你又会得到和原来一摸一样的表达式，你永远也无法化简它。换句话说，它是<strong>不可求值</strong>的。</p>

<p>而我们对这个表达式简单地变一下，就得到了另一个表达式：</p>

<pre><code class="language-plaintext">((λx. f (x x)) (λx. f (x x)))
</code></pre>

<p class="lambda-r">[ [ "λx", [ "f", [ "x", "x" ] ] ], [ "λx", [ "f", [ "x", "x" ] ] ] ]</p>

<p>当你把后一项代入前一项时，它不仅得到了原来的表达式，而且还在外面多套上了一层函数<code>f</code>。在进行一次替换操作，函数外面就又多了一层<code>f</code>，你可以一直这样无穷无尽地迭代下去。</p>

<p>稍稍将外面这个函数改一下，就得到了著名的<strong>Y组合子(Y combinator)</strong>：</p>

<pre><code class="language-plaintext">Y := λf. ((λx. f (x x)) (λx. f (x x)))
</code></pre>

<p>Y组合子的一大性质就是：</p>

<pre><code class="language-plaintext">(Y f) = (f (Y f))
</code></pre>

<p>由于它和函数的不动点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x=f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>长得很像，所以Y组合子也叫<strong>不动点组合子(fixed point combinator)</strong>。</p>

<p><em>注：Y组合子并不是唯一的不动点组合子。比如由Alan Turing给出的Θ组合子</em></p>

<pre><code class="language-plaintext">Θ := ((λx. λy. y (x x y)) (λx. λy. y (x x y)))
</code></pre>

<p><em>它同样满足不动点组合子的性质：</em></p>

<pre><code class="language-plaintext">(Θ f) = (f (Θ f))
</code></pre>

<p>根据不动点组合子的性质，任何不动点组合子<code>fix</code>都有：</p>

<pre><code class="language-plaintext">(fix f) = (f (fix f))
        = (f (f (fix f)))
        = (f (f (f (fix f))))
        = ...
        = (n f (fix f))
</code></pre>

<p>其中<code>n</code>为任意有限的自然数。这个式子我们在之后会很频繁地用到。如果你忘记了自然数的意义，可以回到<a href="/blog/2022/08/27/lambda.html">上一篇博客</a>。</p>

<h2 id="函数递归">函数递归</h2>

<p>Y组合子的一大用途，就是在λ代数中表示“递归”。</p>

<p>例如，你可能会这样写一个求阶乘的函数：</p>

<pre><code class="language-plaintext">fac = λx. (if (x==0)
                (1)
                (x*(fac (x-1))))
</code></pre>

<p>（为了方便起见，这里我就不写成前缀表达式了）</p>

<blockquote>
  <p>注：<code>if</code>语句</p>

  <p><code>(if b x y)</code>的定义是：如果<code>b</code>为真，返回<code>x</code>，否则返回<code>y</code>。</p>

  <p>根据我们对布尔值<code>T</code>和<code>F</code>的定义：</p>

  <pre><code class="language-plaintext">T := λa. λb. a
F := λa. λb. b
</code></pre>

  <p>语句<code>(if b x y)</code>可以看作是<code>(b x y)</code>的另一种写法</p>
</blockquote>

<p>可惜的是，λ表达式里并不允许递归。但是有了Y组合子，我们也可以实现类似递归的效果。</p>

<p>首先我们重写一下刚刚的<code>fac</code>函数：</p>

<pre><code class="language-plaintext">fac = λf. λx. (if (x==0)
                    (1)
                    (x*(f (x-1))))
</code></pre>

<p>现在<code>fac</code>变成了接受一个函数<code>f</code>和参数<code>x</code>的函数。那么接下来：</p>

<pre><code class="language-plaintext">(Y fac 5)
</code></pre>

<p>就可以正确地返回我们想要的结果。证明如下：</p>

<pre><code class="language-plaintext">(Y fac 5) = ((fac (Y fac)) 5)                       ; 利用(Y f)=(f (Y f))
          = (if (5==0) (1) (5*((Y fac) (5-1))))     ; 将5代入x，(Y fac)代入f
          = 5*((Y fac) 4)                           ; 展开if
          = 5*(fac (Y fac) 4)                       ; 还是(Y f)=(f (Y f))
          = 5*(if (4==0) (1) (4*((Y fac) (4-1))))   ; 继续展开
          = 5*4*((Y fac) 3)
          = ...
          = 5*4*3*2*1*((Y fac) 0)
          = 5*4*3*2*1*(fac (Y fac) 0)
          = 5*4*3*2*1*(if (0==0) (1) (0*((Y fac) (0-1))))
          = 5*4*3*2*1*1
          = 5!
</code></pre>

<p>更一般地，对于一个函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>：</p>

<div class="kdmath"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo>=</mo><mi>λ</mi><msub><mi>x</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mtext> </mtext><mi>λ</mi><msub><mi>x</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mtext> </mtext><mi>λ</mi><msub><mi>x</mi><mn>3</mn></msub><mi mathvariant="normal">.</mi><mtext> </mtext><mo>⋯</mo><mtext> </mtext><mi>λ</mi><msub><mi>x</mi><mi>n</mi></msub><mi mathvariant="normal">.</mi><mtext> </mtext><mo stretchy="false">[</mo><mtext>BODY</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">
f=\lambda x_1.\ \lambda x_2.\ \lambda x_3.\ \cdots\ \lambda x_n.\ [\text{BODY}]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mspace"> </span><span class="mord mathnormal">λ</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mspace"> </span><span class="mord mathnormal">λ</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">λ</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mspace"> </span><span class="mopen">[</span><span class="mord text"><span class="mord">BODY</span></span><span class="mclose">]</span></span></span></span></span></div>

<p>而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>的函数体中使用了递归（即：调用了自己），那么我们可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>改写为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mtext>’</mtext></mrow><annotation encoding="application/x-tex">f’</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">’</span></span></span></span>使得它能够在我们的λ代数中运行：</p>

<div class="kdmath"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>λ</mi><mi>g</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mi>λ</mi><msub><mi>x</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mtext> </mtext><mi>λ</mi><msub><mi>x</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mtext> </mtext><mo>⋯</mo><mtext> </mtext><mi>λ</mi><msub><mi>x</mi><mi>n</mi></msub><mi mathvariant="normal">.</mi><mtext> </mtext><mo stretchy="false">[</mo><mtext>BODY</mtext><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>f</mi><mo>:</mo><mo>=</mo><mi>g</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">
f&#x27;=\lambda g.\ \lambda x_1.\ \lambda x_2.\ \cdots\ \lambda x_n.\ [\text{BODY}][f:=g]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9963em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mspace"> </span><span class="mord mathnormal">λ</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mspace"> </span><span class="mord mathnormal">λ</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">λ</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mspace"> </span><span class="mopen">[</span><span class="mord text"><span class="mord">BODY</span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">]</span></span></span></span></span></div>

<p>后面的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mtext>BODY</mtext><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>f</mi><mo>:</mo><mo>=</mo><mi>g</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\text{BODY}][f:=g]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord text"><span class="mord">BODY</span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">]</span></span></span></span>表示将函数体里所有出现的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>全部替换成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>。如果你没有理解为什么要这样做，可以回看一下上面阶乘的例子。</p>

<p>进行求值的时候，只需要做：</p>

<div class="kdmath"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>Y</mi><mtext> </mtext><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mtext> </mtext><msub><mi>x</mi><mn>1</mn></msub><mtext> </mtext><msub><mi>x</mi><mn>2</mn></msub><mtext> </mtext><msub><mi>x</mi><mn>3</mn></msub><mtext> </mtext><mo>⋯</mo><mtext> </mtext><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
((Y\ f&#x27;)\ x_1\ x_2\ x_3\ \cdots\ x_n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></div>

<p>就相当于计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>代入参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值。</p>

<h2 id="列表和懒惰求值">列表和懒惰求值</h2>

<h3 id="列表">列表</h3>

<p>你应该还记得上篇文章的思考题里出现了一个<code>pair</code>函数。它满足：</p>

<pre><code class="language-plaintext">(first (pair a b)) = a
(second (pair a b)) = b
</code></pre>

<p>一个可行的构造利用了布尔值<code>T</code>和<code>F</code>的性质：</p>

<pre><code class="language-plaintext">pair := λa. λb. λt. (t a b)              ; 其中t为一个布尔值
first := λp. (p T)
second := λp. (p F)
</code></pre>

<p>在<code>pair</code>的基础上，你还可以构造出另一个数据结构：列表<code>list</code>。</p>

<pre><code class="language-plaintext">(list3 a b c) := λNIL. (pair a (pair b (pair c NIL)))
(list4 a b c d) := λNIL. (pair a (pair b (pair c (pair d NIL))))
(list5 a b c d e) := λNIL. (pair a (pair b (pair c (paid d (pair e NIL)))))
</code></pre>

<p>其中<code>NIL</code>是一个占位符，用来标志列表结尾。</p>

<p>一个特殊的列表是空列表：<code>list0</code></p>

<pre><code class="language-plaintext">list0 := λNIL. NIL
</code></pre>

<p>有了这些定义之后，我们就可以用递归的语法来定义列表的一些操作。比如：</p>

<h4 id="列表判空">列表判空</h4>

<p>要求：只有当传入的列表是空列表时，返回<code>T</code>，否则返回<code>F</code></p>

<pre><code class="language-lisp">null := λl. (l F (λx. λy. λz. F) T)
</code></pre>

<p>首先我们发现，除了空列表以外，其他列表都是<code>λNIL. (pair _ _)</code>的形式。将<code>pair</code>函数展开得到：<code>λNIL. λb. (b _ _)</code>。如果将函数<code>null</code>作用于这个非空列表，就会得到：</p>

<pre><code class="language-plaintext">(null l) = ((λl. (l F (λx. λy. λz. F) T)) (λNIL. λb. (b _ _)))
         = ((λNIL. λb. (b _ _)) F (λx. λy. λz. F) T)
         = ((λx. λy. λz. F) _ _ T)                       ; 函数接收3个参数并返回常值F
         = F
</code></pre>

<p>而空列表则会返回：</p>

<pre><code class="language-plaintext">(null list0) = ((λl. (l F (λx. λy. λz. F) T) (λNIL. NIL))
             = ((λNIL. NIL) F (λx. λy. λz. F) T)
             = (F (λx. λy. λz. F) T)
             = ((λa. λb. b) (λx. λy. λz. T) T)
             = T
</code></pre>

<h4 id="列表的第一个元素">列表的第一个元素</h4>

<pre><code class="language-plaintext">car := (first (l _))
</code></pre>
<p><code>car</code>返回了列表的第一个元素，前提是列表<code>l</code>非空。</p>

<p>类似地，可以写出<code>cdr</code>，返回列表除了第一个元素以外的其他元素构成的列表：</p>

<pre><code class="language-plaintext">cdr := λNIL. (second (l NIL))
</code></pre>

<p><code>car</code>和<code>cdr</code>这两个函数名可能看起来很奇怪，但这两个函数名来源于最古老的函数式编程语言：Lisp。<del>这也是Lisp的函数命名经常被吐槽的原因之一</del></p>

<h4 id="列表长度">列表长度</h4>

<p>有了<code>null</code>函数，很多列表的操作都能用递归实现了。比如列表的长度计算：</p>

<pre><code class="language-lisp">length := λl. (if (null l)
                    (0)
                    ((length (cdr l))+1))
</code></pre>

<p>注意到<code>(second l)</code>返回列表<code>l</code>从第二项到末尾的子列表，它的长度一定是原列表的长度减去1。</p>

<p>我们可以用前文所说的方法将函数转化为一个非递归函数，并用Y组合子求值。</p>

<h4 id="列表第n项">列表第<code>n</code>项</h4>

<p>假设下标从0开始。</p>

<pre><code class="language-lisp">nth := λl. λn. (if (null l)
                     (error "Index out of bound!")      ; 如果是空列表，报错
                     (if (n==0)
                          (car l)
                          (nth (cdr l) (n-1))))
</code></pre>

<p>这里利用<code>(nth l n) = (nth (cdr l) (n-1))</code>递归查找第<code>n</code>项。</p>

<h4 id="添加元素">添加元素</h4>

<pre><code class="language-lisp">append := λl. λa. λNIL. (l (pair a NIL))
</code></pre>

<p>在列表末尾追加元素<code>a</code>，相当于把列表的<code>NIL</code>替换成<code>(pair a NIL)</code>。</p>

<pre><code class="language-lisp">prepend := λl. λa. λNIL. (pair a (l NIL))
</code></pre>

<p>在列表前面添加元素<code>a</code>，相当于在原来的<code>l</code>外面套一层函数<code>(pair a)</code>。</p>

<h4 id="筛选元素">筛选元素</h4>

<p>函数<code>(filter c l)</code>返回列表<code>l</code>中所有满足条件<code>c</code>的元素构成的新列表。</p>

<pre><code class="language-lisp">filter = λc. λl.
         (if (null l)
               (list0)                                    ; 如果l是空列表，返回一个空列表
               (if (c (car l))
                     (prepend (filter (cdr l) c) (car l))
                     (filter (cdr l) c)))
</code></pre>

<p><del>如果你试着手打一下这一层套一层的括号，就能理解Lisp的痛了</del></p>

<p>例如我们有一个列表<code>l = [1, 2, 3, 4] = λNIL. (pair 1 (pair 2 (pair 3 (pair 4 NIL))))</code>，那么：</p>

<pre><code class="language-plaintext">(filter (λx. x&gt;2) l)
</code></pre>

<p>就会返回列表：<code>[3, 4]</code>。而：</p>

<pre><code class="language-plaintext">(filter (λx. x%2==0) l)
</code></pre>

<p>就会返回列表：<code>[2, 4]</code></p>

<h3 id="无限长列表">无限长列表</h3>

<p>既然我们定义了有限长的列表，那么是否可以定义无限长的列表？</p>

<p>不妨看一下这个递归函数：</p>

<pre><code class="language-plaintext">r := λNIL. (pair 1 (r NIL))
</code></pre>

<p>它展开后会得到一个无限重复<code>1</code>的列表：</p>

<pre><code class="language-plaintext">λNIL. (pair 1 (pair 1 (pair 1 (pair 1 (......)))))
</code></pre>

<p>稍稍更改一下，还可以得到由所有自然数构成的列表：</p>

<pre><code class="language-plaintext">s := λn. λNIL. (pair n (s n+1 NIL))
(s 0) = λNIL. (pair 0 (pair 1 (pair 2 (pair 3 (......)))))
</code></pre>

<p>接下来我们探讨一下类似这样的列表的性质：</p>

<h4 id="判空">判空</h4>

<p>以上文中的<code>r=(1, 1, 1, 1, ...)</code>为例：</p>

<pre><code class="language-plaintext">r' = λf. λNIL. (pair 1 (f NIL))
(null r) = (null (Y r'))
         = ((Y r') F (λx. λy. λz. F) T)
         = ((λNIL. pair 1 (Y r' NIL)) F (λx. λy. λz. F) T)
         = ((λx. λy. λz. F) 1 (Y r' _) T)
         = F
</code></pre>

<p>这个结果也在意料之内，因为无限长的列表肯定不是空的。</p>

<h4 id="第n个元素">第<code>n</code>个元素</h4>

<p>先看看<code>r=[1, 1, 1, 1, ...]</code>：</p>

<pre><code class="language-plaintext">r' = λf. λNIL. (pair 1 (f NIL))
(nth r n) = (nth (Y r') n)
          = (if (null (Y r'))
                  (_)
                  (if (n==0)
                        (car (Y r'))
                        (nth (cdr (Y r')) (n-1))))
          = (if (n==0)                                 ; 根据前文的结论，(null r) = F，跳过第一个分支
                  (car (Y r'))
                  (nth (cdr (Y r')) (n-1)))
</code></pre>

<blockquote>
  <p>引理：</p>

  <pre><code class="language-plaintext">(car (Y r')) = (car (r' (Y r')))
             = (car (λNIL. pair 1 (Y r' NIL)))
             = 1
</code></pre>

  <pre><code class="language-plaintext">(cdr (Y r')) = (cdr (r' (Y r')))
             = (cdr (λNIl. pair 1 (Y r' NIL)))
             = λNIL. (Y r' NIL)
             = (Y r')
</code></pre>
  <p>换句话说，列表<code>(Y r')</code>的第一个元素永远是<code>1</code>，而它从第二个元素开始的子列表就是自己</p>
</blockquote>

<p>回到上面的证明：</p>

<pre><code class="language-plaintext">(nth r n) = (if (n==0)
                  (1)
                  (nth r n-1))
</code></pre>

<p>由于<code>n</code>是自然数，函数重复足够多轮数之后，一定会让<code>n</code>减少到<code>0</code>，此时函数返回<code>1</code>。也就是：</p>

<pre><code class="language-plaintext">(nth r n) = 1
</code></pre>

<p>接着我们再说<code>s</code>。使用类似的方法可以得到：</p>

<pre><code class="language-plaintext">s' = λf. λn. λNIL. (pair n (f n+1 NIL))
(car (s n)) = (car (Y s' n)) = n
(cdr (s n)) = (cdr (Y s' n)) = (s n+1)
</code></pre>

<p>根据这两个结论，可以推出来：</p>

<pre><code class="language-plaintext">(nth (s n) m) = (if (m==0)
                      (car (s n))
                      (nth (cdr (s n)) m-1))
              = (if (m==0)
                      (n)
                      (nth (s n+1) m-1))
</code></pre>

<p>根据数学归纳法，不难知道：<code>(nth (s n) m)</code>的返回值为<code>n+m</code>。特别地，<code>(nth (s 0) m)</code>就是<code>m</code>。</p>

<h3 id="懒惰求值">懒惰求值</h3>

<p>当然，无限长列表的应用远不止这些。比如，斐波那契数列：</p>

<pre><code class="language-lisp">fib = λa. λb. λNIL. (pair a (fib b a+b NIL))
(fib 1 1)       ; [1, 1, 2, 3, 5, 8, 13, ...]
</code></pre>

<p>甚至我们可以使用埃氏筛算法，写出一个装满所有质数的列表：</p>

<pre><code class="language-lisp">sieve := λl. (prepend
               (sieve (filter (λx. x%(car l)!=0) (cdr l)))  ; 去掉(cdr l)中所有(car l)的倍数
               (car l))

(sieve (s 2))           ; [2, 3, 5, 7, 11, 13, 17, ...]
</code></pre>

<p>如果你使用过haskell或者其他支持数组懒惰求值的编程语言，应该或多或少了解过这种写法。它允许你使用有限的语言来描述一个无限长的数列！</p>

<p><em>当然，懒惰求值只能表示出<strong>可计算</strong>的无限序列，例如上面说的斐波那契数列和质数数列，或者π的第n位等。这是因为，λ演算的计算能力和图灵机是等价的，任何不能用图灵机算出的数值同样也不能用λ演算算出来。</em></p>

                
            </div>
        </div>
        <div id='right'>
            <div class="card" id="avatar">
    <img src="/favicon.png" alt="avatar" id="image">
    <a href="/blog/aboutme/" id="name">MqCreaple</a>
    <div class="inline" id="accounts">
        <a href="https://github.com/MqCreaple"><i class="fa-brands fa-github"></i></a>
        <a href="https://space.bilibili.com/507017613"><i class="fa-brands fa-bilibili"></i></a>
        <a href="https://www.zhihu.com/people/gmq12"><i class="fa-brands fa-zhihu"></i></a>
        <a href="mailto:gmq14159@gmail.com"><i class="fa-regular fa-envelope"></i></a>
    </div>
</div>
        </div>
    </div>
    <div id="footer">
    <div style="margin: 2%">
        <p>Copyright &copy; GMQ 2021 - 2022, Blog of MqCreaple (gmq12), version 2.2 </p>
        <p>Powered by <a href="jekyllrb.com">Jekyll</a> | <a href="mailto:gmq14159@gmail.com">Contact Me</a></p>
    </div>
</div>
</div>
</body>
</html>